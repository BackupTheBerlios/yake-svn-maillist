<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Yake-svn] r1157 - trunk/yake/yapp/common
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yake-svn/2005-December/index.html" >
   <LINK REL="made" HREF="mailto:yake-svn%40lists.berlios.de?Subject=Re%3A%20%5BYake-svn%5D%20r1157%20-%20trunk/yake/yapp/common&In-Reply-To=%3C200512072204.jB7M4PEn019749%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000226.html">
   <LINK REL="Next"  HREF="000228.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Yake-svn] r1157 - trunk/yake/yapp/common</H1>
    <B>codeandroid at BerliOS</B> 
    <A HREF="mailto:yake-svn%40lists.berlios.de?Subject=Re%3A%20%5BYake-svn%5D%20r1157%20-%20trunk/yake/yapp/common&In-Reply-To=%3C200512072204.jB7M4PEn019749%40sheep.berlios.de%3E"
       TITLE="[Yake-svn] r1157 - trunk/yake/yapp/common">codeandroid at berlios.de
       </A><BR>
    <I>Wed Dec  7 23:04:25 CET 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000226.html">[Yake-svn] r1156 - trunk/yake/yapp/raf
</A></li>
        <LI>Next message: <A HREF="000228.html">[Yake-svn] r1158 - trunk/yake/yake/input
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#227">[ date ]</a>
              <a href="thread.html#227">[ thread ]</a>
              <a href="subject.html#227">[ subject ]</a>
              <a href="author.html#227">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: codeandroid
Date: 2005-12-07 23:04:25 +0100 (Wed, 07 Dec 2005)
New Revision: 1157

Added:
   trunk/yake/yapp/common/yakeCEGUIHelpers.h
   trunk/yake/yapp/common/yakeCameraControllers.h
Log:
camera controllers, CEGUI helpers

Added: trunk/yake/yapp/common/yakeCEGUIHelpers.h
===================================================================
--- trunk/yake/yapp/common/yakeCEGUIHelpers.h	2005-12-07 22:03:57 UTC (rev 1156)
+++ trunk/yake/yapp/common/yakeCEGUIHelpers.h	2005-12-07 22:04:25 UTC (rev 1157)
@@ -0,0 +1,175 @@
+#ifndef YAKE_CEGUI_HELPERS_H
+#define YAKE_CEGUI_HELPERS_H
+
+namespace yake {
+	/** 
+	 * Convert Yake button id to corresponding CEGUI button id
+	 * @param buttonID Yake button id
+	 * @return CEGUI button id
+	 */
+	CEGUI::MouseButton convertYakeButtonToCegui( int buttonID )
+	{
+		switch (buttonID)
+		{
+		case 0:
+			return CEGUI::LeftButton;
+		case 1:
+			return CEGUI::RightButton;
+		case 2:
+			return CEGUI::MiddleButton;
+		case 3:
+			return CEGUI::X1Button;
+		default:
+			return CEGUI::LeftButton;
+		}
+	}
+
+	/**
+	 *   Get character corresponding to passed keycode.
+	 * @param keyCode 
+	 * @param modifiers Shows if shift button was pressed
+	 * @return Character
+	 * @todo move this into yake::input
+	 * @remarks Taken from the mighty OGRE3D :)
+	 */
+	char getKeyChar(int keyCode, long modifiers)
+	{
+		//HACK ripped from OgreInput
+		//TODO Ogre is rendering engine... should Yake input system contain this method?
+		using namespace yake::input;
+
+		if (modifiers == 0)
+		{
+			switch (keyCode)
+			{
+			case KC_1: return '1';
+			case KC_2: return '2';
+			case KC_3: return '3';
+			case KC_4: return '4';
+			case KC_5: return '5';
+			case KC_6: return '6';
+			case KC_7: return '7';
+			case KC_8: return '8';
+			case KC_9: return '9';
+			case KC_0: return '0';
+			case KC_MINUS: return '-';			/* - on main keyboard */
+			case KC_EQUALS: return '=';
+			case KC_Q: return 'q';
+			case KC_W: return 'w';
+			case KC_E: return 'e';
+			case KC_R: return 'r';
+			case KC_T: return 't';
+			case KC_Y: return 'y';
+			case KC_U: return 'u';
+			case KC_I: return 'i';
+			case KC_O: return 'o';
+			case KC_P: return 'p';
+			case KC_LBRACKET: return '[';
+			case KC_RBRACKET: return ']';
+			case KC_A: return 'a';
+			case KC_S: return 's';
+			case KC_D: return 'd';
+			case KC_F: return 'f';
+			case KC_G: return 'g';
+			case KC_H: return 'h';
+			case KC_J: return 'j';
+			case KC_K: return 'k';
+			case KC_L: return 'l';
+			case KC_SEMICOLON: return ';';
+			case KC_APOSTROPHE: return '\'';
+			case KC_GRAVE: return '`';			/* accent grave */
+			case KC_BACKSLASH: return '\\';
+			case KC_Z: return 'z';
+			case KC_X: return 'x';
+			case KC_C: return 'c';
+			case KC_V: return 'v';
+			case KC_B: return 'b';
+			case KC_N: return 'n';
+			case KC_M: return 'm';
+			case KC_COMMA: return ',';
+			case KC_PERIOD: return '.';			/* . on main keyboard */
+			case KC_SLASH: return '/';			/* '/' on main keyboard */
+			case KC_MULTIPLY: return '*';		/* * on numeric keypad */
+			case KC_SPACE: return ' ';
+			case KC_NUMPAD7: return '7';
+			case KC_NUMPAD8: return '8';
+			case KC_NUMPAD9: return '9';
+			case KC_SUBTRACT: return '-';		/* - on numeric keypad */
+			case KC_NUMPAD4: return '4';
+			case KC_NUMPAD5: return '5';
+			case KC_NUMPAD6: return '6';
+			case KC_ADD: return '+';			/* + on numeric keypad */
+			case KC_NUMPAD1: return '1';
+			case KC_NUMPAD2: return '2';
+			case KC_NUMPAD3: return '3';
+			case KC_NUMPAD0: return '0';
+			case KC_DECIMAL: return '.';		/* . on numeric keypad */
+			case KC_NUMPADEQUALS: return '=';	/* = on numeric keypad (NEC PC98) */
+			case KC_AT: return '@';				/*                     (NEC PC98) */
+			case KC_COLON: return ':';			/*                     (NEC PC98) */
+			case KC_UNDERLINE: return '_';		/*                     (NEC PC98) */
+			case KC_NUMPADCOMMA: return ',';	/* , on numeric keypad (NEC PC98) */
+			case KC_DIVIDE: return '/';			/* / on numeric keypad */
+			}
+		}
+		else //HACK if ( modifiers == InputEvent::SHIFT_MASK)
+		{
+			switch (keyCode)
+			{
+			case KC_1: return '!';
+			case KC_2: return '@';
+			case KC_3: return '#';
+			case KC_4: return '$';
+			case KC_5: return '%';
+			case KC_6: return '^';
+			case KC_7: return '&amp;';
+			case KC_8: return '*';
+			case KC_9: return '(';
+			case KC_0: return ')';
+			case KC_MINUS: return '_';
+			case KC_EQUALS: return '+';
+			case KC_Q: return 'Q';
+			case KC_W: return 'W';
+			case KC_E: return 'E';
+			case KC_R: return 'R';
+			case KC_T: return 'T';
+			case KC_Y: return 'Y';
+			case KC_U: return 'U';
+			case KC_I: return 'I';
+			case KC_O: return 'O';
+			case KC_P: return 'P';
+			case KC_LBRACKET: return '{';
+			case KC_RBRACKET: return '}';
+			case KC_A: return 'A';
+			case KC_S: return 'S';
+			case KC_D: return 'D';
+			case KC_F: return 'F';
+			case KC_G: return 'G';
+			case KC_H: return 'H';
+			case KC_J: return 'J';
+			case KC_K: return 'K';
+			case KC_L: return 'L';
+			case KC_SEMICOLON: return ':';
+			case KC_APOSTROPHE: return '&quot;';
+			case KC_GRAVE: return '~';			/* accent grave */
+			case KC_BACKSLASH: return '|';
+			case KC_Z: return 'Z';
+			case KC_X: return 'X';
+			case KC_C: return 'C';
+			case KC_V: return 'V';
+			case KC_B: return 'B';
+			case KC_N: return 'N';
+			case KC_M: return 'M';
+			case KC_COMMA: return '&lt;';
+			case KC_PERIOD: return '&gt;';			/* . on main keyboard */
+			case KC_SLASH: return '?';			/* '/' on main keyboard */
+			case KC_MULTIPLY: return '*';		/* * on numeric keypad */
+			case KC_SPACE: return ' ';
+			}
+		}
+		return 0;
+	}
+
+} // namespace yake
+
+#endif

Added: trunk/yake/yapp/common/yakeCameraControllers.h
===================================================================
--- trunk/yake/yapp/common/yakeCameraControllers.h	2005-12-07 22:03:57 UTC (rev 1156)
+++ trunk/yake/yapp/common/yakeCameraControllers.h	2005-12-07 22:04:25 UTC (rev 1157)
@@ -0,0 +1,57 @@
+#ifndef YAKE_CAMERACONTROLLERS_H
+#define YAKE_CAMERACONTROLLERS_H
+
+namespace yake {
+
+	class TopDownCameraController
+	{
+	public:
+		TopDownCameraController();
+
+		void setCamera(graphics::ICamera*);
+
+		void setTarget( const Point3&amp; );
+		void setOffset( const Vector3&amp; );
+		Vector3 getOffset() const;
+
+		void update(const real dt);
+	private:
+		Point3				mTargetPos;
+		graphics::ICamera*	mCam;
+		Vector3				mCamOffset;
+	};
+	/** @todo move into .inl file! */
+	TopDownCameraController::TopDownCameraController() :
+		mCam(0),
+		mTargetPos(Point3::kZero),
+		mCamOffset(Vector3(2,0,2))
+	{
+	}
+	void TopDownCameraController::setCamera(graphics::ICamera* cam)
+	{
+		mCam = cam;
+	}
+	void TopDownCameraController::setTarget( const Point3&amp; pt )
+	{
+		mTargetPos = pt;
+	}
+	void TopDownCameraController::setOffset( const Vector3&amp; offset )
+	{
+		mCamOffset = offset;
+	}
+	Vector3 TopDownCameraController::getOffset() const
+	{
+		return mCamOffset;
+	}
+	void TopDownCameraController::update(const real dt)
+	{
+		if (!mCam)
+			return;
+		const Point3 targetCamPos = mTargetPos + mCamOffset;
+		mCam-&gt;translate( 0.5 * (targetCamPos - mCam-&gt;getPosition()) );
+		mCam-&gt;lookAt( mTargetPos );
+	}
+
+} // namespace yake
+
+#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000226.html">[Yake-svn] r1156 - trunk/yake/yapp/raf
</A></li>
	<LI>Next message: <A HREF="000228.html">[Yake-svn] r1158 - trunk/yake/yake/input
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#227">[ date ]</a>
              <a href="thread.html#227">[ thread ]</a>
              <a href="subject.html#227">[ subject ]</a>
              <a href="author.html#227">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yake-svn">More information about the Yake-svn
mailing list</a><br>
</body></html>
