<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Yake-svn] r1302 - in trunk/yake: . common/media/vehicles src/yake/audio src/yake/base src/yake/base/math src/yake/base/native/Linux src/yake/graphics src/yake/plugins/baseLuaBindings src/yake/plugins/graphicsLuaBindings src/yake/plugins/graphicsOgre src/yake/plugins/inputOgre src/yake/plugins/physicsODE src/yake/samples/base/debug src/yake/thread src/yapp src/yapp/base/event src/yapp/loader src/yapp/model src/yapp/plugins src/yapp/plugins/ceguiOgreRendererAdapter src/yapp/plugins/terrainPhysMgr src/yapp/raf src/yapp/samples src/yapp/samples/base/vehicle src/yapp/samples/gui/console src/yapp/samples/misc/cmdrmayhem src/yapp/samples/model/XODE src/yapp/samples/model/dotLink src/yapp/vehicle yake/audio yake/base yake/base/math yake/base/mpl yake/base/native yake/base/templates yake/graphics yake/object yake/physics yake/plugins/graphicsOgre yake/plugins/inputOgre yake/plugins/physicsODE yake/prop yake/samples/common yake/scripting yake/statemachine yake/thread yapp/common yapp/l! oader yapp/model yapp/plugins yapp/plugins/ceguiOgreRendererAdapter yapp/plugins/terrainPhysMgr yapp/raf yapp/vehicle
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yake-svn/2006-March/index.html" >
   <LINK REL="made" HREF="mailto:yake-svn%40lists.berlios.de?Subject=Re%3A%20%5BYake-svn%5D%20r1302%20-%20in%20trunk/yake%3A%20.%20common/media/vehicles%20src/yake/audio%20src/yake/base%20src/yake/base/math%20src/yake/base/native/Linux%20src/yake/graphics%20src/yake/plugins/baseLuaBindings%20src/yake/plugins/graphicsLuaBindings%20src/yake/plugins/graphicsOgre%20src/yake/plugins/inputOgre%20src/yake/plugins/physicsODE%20src/yake/samples/base/debug%20src/yake/thread%20src/yapp%20src/yapp/base/event%20src/yapp/loader%20src/yapp/model%20src/yapp/plugins%20src/yapp/plugins/ceguiOgreRendererAdapter%20src/yapp/plugins/terrainPhysMgr%20src/yapp/raf%20src/yapp/samples%20src/yapp/samples/base/vehicle%20src/yapp/samples/gui/console%20src/yapp/samples/misc/cmdrmayhem%20src/yapp/samples/model/XODE%20src/yapp/samples/model/dotLink%20src/yapp/vehicle%20yake/audio%20yake/base%20yake/base/math%20yake/base/mpl%20yake/base/native%20yake/base/templates%20yake/graphics%20yake/object%20yake/physics%20yake/plugins/graphicsOgre%20yake/plugins/inputOgre%20yake/plugins/physicsODE%20yake/prop%20yake/samples/common%20yake/scripting%20yake/statemachine%20yake/thread%20yapp/common%20yapp/l%21%0A%20oader%20yapp/model%20yapp/plugins%20yapp/plugins/ceguiOgreRendererAdapter%20yapp/plugins/terrainPhysMgr%20yapp/raf%20yapp/vehicle&In-Reply-To=%3C200603191755.k2JHtb8G010705%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000371.html">
   <LINK REL="Next"  HREF="000373.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Yake-svn] r1302 - in trunk/yake: . common/media/vehicles src/yake/audio src/yake/base src/yake/base/math src/yake/base/native/Linux src/yake/graphics src/yake/plugins/baseLuaBindings src/yake/plugins/graphicsLuaBindings src/yake/plugins/graphicsOgre src/yake/plugins/inputOgre src/yake/plugins/physicsODE src/yake/samples/base/debug src/yake/thread src/yapp src/yapp/base/event src/yapp/loader src/yapp/model src/yapp/plugins src/yapp/plugins/ceguiOgreRendererAdapter src/yapp/plugins/terrainPhysMgr src/yapp/raf src/yapp/samples src/yapp/samples/base/vehicle src/yapp/samples/gui/console src/yapp/samples/misc/cmdrmayhem src/yapp/samples/model/XODE src/yapp/samples/model/dotLink src/yapp/vehicle yake/audio yake/base yake/base/math yake/base/mpl yake/base/native yake/base/templates yake/graphics yake/object yake/physics yake/plugins/graphicsOgre yake/plugins/inputOgre yake/plugins/physicsODE yake/prop yake/samples/common yake/scripting yake/statemachine yake/thread yapp/common yapp/l! oader yapp/model yapp/plugins yapp/plugins/ceguiOgreRendererAdapter yapp/plugins/terrainPhysMgr yapp/raf yapp/vehicle</H1>
    <B>codeandroid at BerliOS</B> 
    <A HREF="mailto:yake-svn%40lists.berlios.de?Subject=Re%3A%20%5BYake-svn%5D%20r1302%20-%20in%20trunk/yake%3A%20.%20common/media/vehicles%20src/yake/audio%20src/yake/base%20src/yake/base/math%20src/yake/base/native/Linux%20src/yake/graphics%20src/yake/plugins/baseLuaBindings%20src/yake/plugins/graphicsLuaBindings%20src/yake/plugins/graphicsOgre%20src/yake/plugins/inputOgre%20src/yake/plugins/physicsODE%20src/yake/samples/base/debug%20src/yake/thread%20src/yapp%20src/yapp/base/event%20src/yapp/loader%20src/yapp/model%20src/yapp/plugins%20src/yapp/plugins/ceguiOgreRendererAdapter%20src/yapp/plugins/terrainPhysMgr%20src/yapp/raf%20src/yapp/samples%20src/yapp/samples/base/vehicle%20src/yapp/samples/gui/console%20src/yapp/samples/misc/cmdrmayhem%20src/yapp/samples/model/XODE%20src/yapp/samples/model/dotLink%20src/yapp/vehicle%20yake/audio%20yake/base%20yake/base/math%20yake/base/mpl%20yake/base/native%20yake/base/templates%20yake/graphics%20yake/object%20yake/physics%20yake/plugins/graphicsOgre%20yake/plugins/inputOgre%20yake/plugins/physicsODE%20yake/prop%20yake/samples/common%20yake/scripting%20yake/statemachine%20yake/thread%20yapp/common%20yapp/l%21%0A%20oader%20yapp/model%20yapp/plugins%20yapp/plugins/ceguiOgreRendererAdapter%20yapp/plugins/terrainPhysMgr%20yapp/raf%20yapp/vehicle&In-Reply-To=%3C200603191755.k2JHtb8G010705%40sheep.berlios.de%3E"
       TITLE="[Yake-svn] r1302 - in trunk/yake: . common/media/vehicles src/yake/audio src/yake/base src/yake/base/math src/yake/base/native/Linux src/yake/graphics src/yake/plugins/baseLuaBindings src/yake/plugins/graphicsLuaBindings src/yake/plugins/graphicsOgre src/yake/plugins/inputOgre src/yake/plugins/physicsODE src/yake/samples/base/debug src/yake/thread src/yapp src/yapp/base/event src/yapp/loader src/yapp/model src/yapp/plugins src/yapp/plugins/ceguiOgreRendererAdapter src/yapp/plugins/terrainPhysMgr src/yapp/raf src/yapp/samples src/yapp/samples/base/vehicle src/yapp/samples/gui/console src/yapp/samples/misc/cmdrmayhem src/yapp/samples/model/XODE src/yapp/samples/model/dotLink src/yapp/vehicle yake/audio yake/base yake/base/math yake/base/mpl yake/base/native yake/base/templates yake/graphics yake/object yake/physics yake/plugins/graphicsOgre yake/plugins/inputOgre yake/plugins/physicsODE yake/prop yake/samples/common yake/scripting yake/statemachine yake/thread yapp/common yapp/l! oader yapp/model yapp/plugins yapp/plugins/ceguiOgreRendererAdapter yapp/plugins/terrainPhysMgr yapp/raf yapp/vehicle">codeandroid at berlios.de
       </A><BR>
    <I>Sun Mar 19 18:55:37 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000371.html">[Yake-svn] r1301 - in trunk/yake/common/bin: debug release
</A></li>
        <LI>Next message: <A HREF="000373.html">[Yake-svn] r1303 - in trunk/yake/src/yapp/samples: . physics physics/paging_terrain
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#372">[ date ]</a>
              <a href="thread.html#372">[ thread ]</a>
              <a href="subject.html#372">[ subject ]</a>
              <a href="author.html#372">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: codeandroid
Date: 2006-03-19 18:54:00 +0100 (Sun, 19 Mar 2006)
New Revision: 1302

Added:
   trunk/yake/src/yapp/plugins/terrainPhysMgr/
   trunk/yake/src/yapp/plugins/terrainPhysMgr/TerrainOdeActor.cpp
   trunk/yake/src/yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.cpp
   trunk/yake/yapp/plugins/terrainPhysMgr/
   trunk/yake/yapp/plugins/terrainPhysMgr/TerrainOdeActor.h
   trunk/yake/yapp/plugins/terrainPhysMgr/TerrainOdeShape.h
   trunk/yake/yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.h
Modified:
   trunk/yake/SConstruct
   trunk/yake/buildspec.xml
   trunk/yake/common/media/vehicles/jet.xml
   trunk/yake/src/yake/audio/yakeAudio.cpp
   trunk/yake/src/yake/base/math/yakeQuaternion.cpp
   trunk/yake/src/yake/base/native/Linux/yakeApplication.cpp
   trunk/yake/src/yake/base/native/Linux/yakeCriticalSection.cpp
   trunk/yake/src/yake/base/native/Linux/yakeDebug.cpp
   trunk/yake/src/yake/base/native/Linux/yakeLibrary.cpp
   trunk/yake/src/yake/base/native/Linux/yakeTime.cpp
   trunk/yake/src/yake/base/yakeDebugLogAppender.cpp
   trunk/yake/src/yake/graphics/yakeGraphicsSystem.cpp
   trunk/yake/src/yake/plugins/baseLuaBindings/yakeLuaBinder.cpp
   trunk/yake/src/yake/plugins/graphicsLuaBindings/yakeLuaBinder.cpp
   trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreCamera.cpp
   trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreCore.cpp
   trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreEntity.cpp
   trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreGeometryAccess.cpp
   trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreLight.cpp
   trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreNode.cpp
   trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreParticleSystem.cpp
   trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreViewport.cpp
   trunk/yake/src/yake/plugins/graphicsOgre/yakeGraphicsWorld.cpp
   trunk/yake/src/yake/plugins/inputOgre/InputSystemOgre.cpp
   trunk/yake/src/yake/plugins/physicsODE/OdeActor.cpp
   trunk/yake/src/yake/plugins/physicsODE/OdeBallJoint.cpp
   trunk/yake/src/yake/plugins/physicsODE/OdeBody.cpp
   trunk/yake/src/yake/plugins/physicsODE/OdeFixedJoint.cpp
   trunk/yake/src/yake/plugins/physicsODE/OdeHinge2Joint.cpp
   trunk/yake/src/yake/plugins/physicsODE/OdeHingeJoint.cpp
   trunk/yake/src/yake/plugins/physicsODE/OdeJoint.cpp
   trunk/yake/src/yake/plugins/physicsODE/OdeMaterial.cpp
   trunk/yake/src/yake/plugins/physicsODE/OdeRay.cpp
   trunk/yake/src/yake/plugins/physicsODE/OdeShapes.cpp
   trunk/yake/src/yake/plugins/physicsODE/OdeSliderJoint.cpp
   trunk/yake/src/yake/plugins/physicsODE/OdeUniversalJoint.cpp
   trunk/yake/src/yake/plugins/physicsODE/OdeWorld.cpp
   trunk/yake/src/yake/samples/base/debug/yakeUnitTest.cpp
   trunk/yake/src/yake/thread/yakeThread.cpp
   trunk/yake/src/yapp/Makefile.am
   trunk/yake/src/yapp/base/event/Makefile.am
   trunk/yake/src/yapp/loader/yakeDotLinkLoader.cpp
   trunk/yake/src/yapp/loader/yakeDotScene.cpp
   trunk/yake/src/yapp/loader/yakeModelMovableLinkCreator.cpp
   trunk/yake/src/yapp/loader/yakeXODEParser.cpp
   trunk/yake/src/yapp/model/Makefile.am
   trunk/yake/src/yapp/model/yakeComplexModel.cpp
   trunk/yake/src/yapp/model/yakeModelMovableLink.cpp
   trunk/yake/src/yapp/model/yakePhysical.cpp
   trunk/yake/src/yapp/model/yakePhysicalDataImporter.cpp
   trunk/yake/src/yapp/plugins/ceguiOgreRendererAdapter/plugin.cpp
   trunk/yake/src/yapp/raf/yakeApplication.cpp
   trunk/yake/src/yapp/raf/yakeApplicationState.cpp
   trunk/yake/src/yapp/raf/yakeRtApplicationState.cpp
   trunk/yake/src/yapp/samples/Makefile.am
   trunk/yake/src/yapp/samples/base/vehicle/yakeDemo.cpp
   trunk/yake/src/yapp/samples/gui/console/yakeConsoleDemo.cpp
   trunk/yake/src/yapp/samples/misc/cmdrmayhem/yakeDemo.cpp
   trunk/yake/src/yapp/samples/model/XODE/yakeXODELoaderDemo.cpp
   trunk/yake/src/yapp/samples/model/dotLink/yakeDotLinkDemo.cpp
   trunk/yake/src/yapp/vehicle/yakeDotVehicle.cpp
   trunk/yake/src/yapp/vehicle/yakeMountPoint.cpp
   trunk/yake/src/yapp/vehicle/yakeNativeOde.cpp
   trunk/yake/src/yapp/vehicle/yakeOdeEngine.cpp
   trunk/yake/src/yapp/vehicle/yakeVehicle.cpp
   trunk/yake/yake/audio/yakeAudio.h
   trunk/yake/yake/audio/yakeAudioSystem.h
   trunk/yake/yake/audio/yakePCH.h
   trunk/yake/yake/base/math/yakeColor.h
   trunk/yake/yake/base/math/yakeColor.inl
   trunk/yake/yake/base/math/yakeGeometry.h
   trunk/yake/yake/base/math/yakeMath.h
   trunk/yake/yake/base/math/yakeMatrix3.h
   trunk/yake/yake/base/math/yakeQuaternion.h
   trunk/yake/yake/base/math/yakeVector3.h
   trunk/yake/yake/base/mpl/yakeBuildArguments.h
   trunk/yake/yake/base/mpl/yakeBuildIteration.h
   trunk/yake/yake/base/native/yakeNative.h
   trunk/yake/yake/base/templates/yakePointer.h
   trunk/yake/yake/base/templates/yakeRegistry.h
   trunk/yake/yake/base/yake.h
   trunk/yake/yake/base/yakeConfigFile.h
   trunk/yake/yake/base/yakeLibrary.h
   trunk/yake/yake/base/yakeMovable.h
   trunk/yake/yake/base/yakeProcessor.h
   trunk/yake/yake/base/yakeString.h
   trunk/yake/yake/base/yakeTaggedListenerManager.h
   trunk/yake/yake/graphics/yakeGeometryAccess.h
   trunk/yake/yake/graphics/yakeGraphicalWorld.h
   trunk/yake/yake/graphics/yakeGraphicsSystem.h
   trunk/yake/yake/object/ClassAndObjectIdManager.inl
   trunk/yake/yake/object/ObjectContainer.h
   trunk/yake/yake/object/ObjectManager.h
   trunk/yake/yake/object/ObjectManager.inl
   trunk/yake/yake/object/common.h
   trunk/yake/yake/physics/yakeAffectorZone.h
   trunk/yake/yake/physics/yakePhysicsActor.h
   trunk/yake/yake/physics/yakePhysicsAffectors.h
   trunk/yake/yake/physics/yakePhysicsAvatar.h
   trunk/yake/yake/physics/yakePhysicsBody.h
   trunk/yake/yake/physics/yakePhysicsBodyGroup.h
   trunk/yake/yake/physics/yakePhysicsJoint.h
   trunk/yake/yake/physics/yakePhysicsMaterial.h
   trunk/yake/yake/physics/yakePhysicsMotors.h
   trunk/yake/yake/physics/yakePhysicsPrerequisites.h
   trunk/yake/yake/physics/yakePhysicsShape.h
   trunk/yake/yake/physics/yakePhysicsWorld.h
   trunk/yake/yake/plugins/graphicsOgre/graphicsOgreCamera.h
   trunk/yake/yake/plugins/graphicsOgre/graphicsOgreCore.h
   trunk/yake/yake/plugins/graphicsOgre/graphicsOgreEntity.h
   trunk/yake/yake/plugins/graphicsOgre/graphicsOgreGeometryAccess.h
   trunk/yake/yake/plugins/graphicsOgre/graphicsOgreLight.h
   trunk/yake/yake/plugins/graphicsOgre/graphicsOgreNode.h
   trunk/yake/yake/plugins/graphicsOgre/graphicsOgreParticleSystem.h
   trunk/yake/yake/plugins/graphicsOgre/graphicsOgreViewport.h
   trunk/yake/yake/plugins/graphicsOgre/yakeGraphicsSystem.h
   trunk/yake/yake/plugins/graphicsOgre/yakeGraphicsWorld.h
   trunk/yake/yake/plugins/graphicsOgre/yakePCH.h
   trunk/yake/yake/plugins/inputOgre/InputSystemOgre.h
   trunk/yake/yake/plugins/physicsODE/OdeActor.h
   trunk/yake/yake/plugins/physicsODE/OdeAvatar.h
   trunk/yake/yake/plugins/physicsODE/OdeBody.h
   trunk/yake/yake/plugins/physicsODE/OdeJoint.h
   trunk/yake/yake/plugins/physicsODE/OdeMaterial.h
   trunk/yake/yake/plugins/physicsODE/OdeRay.h
   trunk/yake/yake/plugins/physicsODE/OdeShapes.h
   trunk/yake/yake/plugins/physicsODE/OdeWorld.h
   trunk/yake/yake/prop/prerequisites.h
   trunk/yake/yake/prop/prop_def.h
   trunk/yake/yake/prop/prop_holder.h
   trunk/yake/yake/prop/rtti_class.h
   trunk/yake/yake/samples/common/yakeExampleApplication.h
   trunk/yake/yake/scripting/yakeScriptingSystem.h
   trunk/yake/yake/statemachine/fsm_core.h
   trunk/yake/yake/thread/ZThreadMutexForwarder.h
   trunk/yake/yake/thread/ZThreadThreadForwarder.h
   trunk/yake/yake/thread/yakeThread.h
   trunk/yake/yake/thread/yakeThreadPrerequisites.h
   trunk/yake/yapp/common/yakeCameraControllers.h
   trunk/yake/yapp/loader/yakeDotScene.h
   trunk/yake/yapp/loader/yakeXODE.h
   trunk/yake/yapp/loader/yakeXODEParser.h
   trunk/yake/yapp/model/yakeComplexModel.h
   trunk/yake/yapp/model/yakeGraphical.h
   trunk/yake/yapp/model/yakeModel.h
   trunk/yake/yapp/model/yakeModelLink.h
   trunk/yake/yapp/model/yakeModelMovableLink.h
   trunk/yake/yapp/model/yakePhysical.h
   trunk/yake/yapp/model/yakePhysicalDataImporter.h
   trunk/yake/yapp/plugins/ceguiOgreRendererAdapter/pch.h
   trunk/yake/yapp/raf/pch.h
   trunk/yake/yapp/raf/yakeApplication.h
   trunk/yake/yapp/raf/yakeApplicationState.h
   trunk/yake/yapp/raf/yakePrerequisites.h
   trunk/yake/yapp/vehicle/yakeDotVehicle.h
   trunk/yake/yapp/vehicle/yakeInterfaces.h
   trunk/yake/yapp/vehicle/yakeMountPoint.h
   trunk/yake/yapp/vehicle/yakeNativeOde.h
   trunk/yake/yapp/vehicle/yakeTemplates.h
   trunk/yake/yapp/vehicle/yakeVehicle.h
   trunk/yake/yapp/vehicle/yakeVehicleSystem.h
Log:
patch #1453160 by mj, slightly modified by psy;
major points includes linux compatibility, OGRE Dagon compatibility, vehicles enhancements, physics enhancements, paging landscape ode&lt;-&gt;ogre physics plugin, and various other fixes.

Modified: trunk/yake/SConstruct
===================================================================
--- trunk/yake/SConstruct	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/SConstruct	2006-03-19 17:54:00 UTC (rev 1302)
@@ -39,6 +39,19 @@
 
 cc_flags = '-DGCC_3_1 -DEXT_HASH -DYAKE_DEBUG -DYAKE_DEBUG_BUILD'
 
+# optimization flags
+optimization_flags = ' -O3 '
+
+# debug flag. -g[Level]
+debug_flags = ' -g '
+
+# if you want to profile with GNU gprof
+profiler_flags = ' -pg '
+
+# if you want to test code coverage with GNU gcov
+code_coverage_flags = ' -fprofile-arcs -ftest-coverage '
+
+
 lib_includes = build.commonIncludes
 build_dir = build.commonPaths['ObjectDir']
 bin_build_dir = build.commonPaths['ProgramInstallDir']

Modified: trunk/yake/buildspec.xml
===================================================================
--- trunk/yake/buildspec.xml	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/buildspec.xml	2006-03-19 17:54:00 UTC (rev 1302)
@@ -10,6 +10,7 @@
 			&lt;include&gt;.&lt;/include&gt;
 			&lt;include&gt;dependencies/ttl&lt;/include&gt;
 			&lt;include&gt;dependencies/OGRE&lt;/include&gt;
+			&lt;include&gt;dependencies/PLSM&lt;/include&gt;
 			&lt;include&gt;dependencies/ode/include&lt;/include&gt;
 			&lt;include&gt;dependencies/luabind&lt;/include&gt;
 			&lt;include&gt;/usr/local/include/CEGUI&lt;/include&gt;
@@ -33,6 +34,7 @@
 		name=&quot;yakeTemplates&quot;
 		src=&quot;src/yake/base/templates&quot;
 	&gt;
+		&lt;libadd&gt;yakeNative&lt;/libadd&gt;
 	&lt;/BuildSharedLibrary&gt;
 
 	&lt;BuildSharedLibrary
@@ -109,6 +111,12 @@
 		&lt;libadd&gt;ZThread&lt;/libadd&gt;
         &lt;/BuildSharedLibrary&gt;
 
+        &lt;BuildSharedLibrary
+                name=&quot;yakeObject&quot;
+                src=&quot;src/yake/object&quot;
+        &gt;
+                &lt;libadd&gt;yakeBase&lt;/libadd&gt;
+        &lt;/BuildSharedLibrary&gt;
 
 &lt;!--
 	&lt;BuildSharedLibrary
@@ -226,27 +234,19 @@
 	&lt;/BuildSharedLibrary&gt;
 
 	&lt;BuildSharedLibrary
-		name=&quot;yappStatemachine&quot;	
-		src=&quot;src/yapp/statemachine&quot;
-	&gt;
-		&lt;libadd&gt;yappBase&lt;/libadd&gt;
-	&lt;/BuildSharedLibrary&gt;
-
-	&lt;BuildSharedLibrary
 		name=&quot;yappMsg&quot;	
 		src=&quot;src/yapp/msg&quot;
 	&gt;
 		&lt;libadd&gt;yappBase&lt;/libadd&gt;
 	&lt;/BuildSharedLibrary&gt;
 
-	&lt;BuildSharedLibrary
+	&lt;!--&lt;BuildSharedLibrary
 		name=&quot;yappEnt&quot;	
 		src=&quot;src/yapp/ent&quot;
 	&gt;
 		&lt;libadd&gt;yappBase&lt;/libadd&gt;
-		&lt;libadd&gt;yappStatemachine&lt;/libadd&gt;
 		&lt;libadd&gt;yappMsg&lt;/libadd&gt;
-	&lt;/BuildSharedLibrary&gt;
+	&lt;/BuildSharedLibrary&gt;--&gt;
 
 	&lt;BuildSharedLibrary
 		name=&quot;yappVehicle&quot;	
@@ -261,8 +261,11 @@
 		src=&quot;src/yapp/raf&quot;
 	&gt;
 		&lt;libadd&gt;yappBase&lt;/libadd&gt;
+		&lt;libadd&gt;yakeCEGUIOgreAdapter&lt;/libadd&gt;
+		&lt;libadd&gt;CEGUIOgreRenderer&lt;/libadd&gt;
 	&lt;/BuildSharedLibrary&gt;
 
+	
 	&lt;BuildSharedLibrary
 		name=&quot;yakeCEGUIOgreAdapter&quot;
 		src=&quot;src/yapp/plugins/ceguiOgreRendererAdapter&quot;
@@ -271,21 +274,28 @@
 		&lt;libadd&gt;OgreMain&lt;/libadd&gt;
 	&lt;/BuildSharedLibrary&gt;
 
-	&lt;BuildSharedLibrary
+	&lt;!--&lt;BuildSharedLibrary
 		name=&quot;yappEntLua&quot;
 		src=&quot;src/yapp/plugins/entLua&quot;
 	&gt;
 		&lt;libadd&gt;yappEnt&lt;/libadd&gt;
-	&lt;/BuildSharedLibrary&gt;
+	&lt;/BuildSharedLibrary&gt;--&gt;
 
 	&lt;BuildSharedLibrary
 		name=&quot;yappmodelLuaBindings&quot;
 		src=&quot;src/yapp/plugins/modelLuaBindings&quot;
 	&gt;
-		&lt;libadd&gt;yappEnt&lt;/libadd&gt;
+		&lt;!--libadd&gt;yappEnt&lt;/libadd--&gt;
 		&lt;libadd&gt;luabind&lt;/libadd&gt;
 	&lt;/BuildSharedLibrary&gt;
 
+	&lt;BuildSharedLibrary
+		name=&quot;yappTerrainPhysicsManager&quot;
+		src=&quot;src/yapp/plugins/terrainPhysMgr&quot;
+	&gt;
+		&lt;libadd&gt;PagingLandscape&lt;/libadd&gt;
+	&lt;/BuildSharedLibrary&gt;	
+
 &lt;!-- SAMPLES --&gt;
 
 	&lt;List name=&quot;common_libs&quot;&gt;
@@ -344,10 +354,25 @@
 	&gt;
 		&lt;libadd&gt;common_libs&lt;/libadd&gt;	
 		&lt;libadd&gt;yappModel&lt;/libadd&gt;	
+		&lt;libadd&gt;yappVehicle&lt;/libadd&gt;	
+		&lt;libadd&gt;yappraf&lt;/libadd&gt;
+	&lt;/BuildProgram&gt;
+
+	&lt;!--
+	&lt;BuildProgram
+		name=&quot;TerrainDemo&quot;
+		src=&quot;src/yapp/samples/ode_terrain_demo&quot;
+	&gt;
+		&lt;libadd&gt;common_libs&lt;/libadd&gt;	
+		&lt;libadd&gt;yappModel&lt;/libadd&gt;	
 		&lt;libadd&gt;yappStatemachine&lt;/libadd&gt;	
 		&lt;libadd&gt;yappVehicle&lt;/libadd&gt;	
 		&lt;libadd&gt;yappraf&lt;/libadd&gt;
+		&lt;libadd&gt;PagingLandscape&lt;/libadd&gt;
+		&lt;libadd&gt;yappTerrainPhysicsManager&lt;/libadd&gt;
+		&lt;libadd&gt;dl&lt;/libadd&gt;
 	&lt;/BuildProgram&gt;	
+	--&gt;
 
 	&lt;BuildProgram
 		name=&quot;consoleDemo&quot;
@@ -360,7 +385,16 @@
 		&lt;libadd&gt;luabind&lt;/libadd&gt;
 		&lt;libadd&gt;CEGUIOgreRenderer&lt;/libadd&gt;
 	&lt;/BuildProgram&gt;
-		
+	&lt;!--&lt;BuildProgram 
+		name=&quot;cmdrmayhem&quot;
+		src=&quot;src/yapp/samples/misc/cmdrmayhem&quot;
+	&gt;
+		&lt;libadd&gt;common_libs&lt;/libadd&gt;
+		&lt;libadd&gt;yappModel&lt;/libadd&gt;	
+		&lt;libadd&gt;yappVehicle&lt;/libadd&gt;
+		&lt;libadd&gt;yappraf&lt;/libadd&gt;
+	&lt;/BuildProgram&gt;
+	--&gt;
 
 &lt;/BuildSpec&gt;
 

Modified: trunk/yake/common/media/vehicles/jet.xml
===================================================================
--- trunk/yake/common/media/vehicles/jet.xml	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/common/media/vehicles/jet.xml	2006-03-19 17:54:00 UTC (rev 1302)
@@ -49,6 +49,14 @@
 		&lt;engine name=&quot;upward&quot; type=&quot;MountedThruster&quot; mountPoint=&quot;bottom&quot;&gt;
 			&lt;forces min=&quot;0.&quot; max=&quot;250.&quot; dieOff=&quot;10&quot; rise=&quot;20&quot; /&gt;
 		&lt;/engine&gt;
+		&lt;!-- bottom (downward) thruster --&gt;
+		&lt;mountPoint name=&quot;top&quot;&gt;
+			&lt;position x=&quot;0&quot; y=&quot;0&quot; z=&quot;0&quot; /&gt;
+			&lt;direction x=&quot;0&quot; y=&quot;1&quot; z=&quot;0&quot; /&gt;
+		&lt;/mountPoint&gt;
+		&lt;engine name=&quot;downward&quot; type=&quot;MountedThruster&quot; mountPoint=&quot;top&quot;&gt;
+			&lt;forces min=&quot;0.&quot; max=&quot;250.&quot; dieOff=&quot;10&quot; rise=&quot;20&quot; /&gt;
+		&lt;/engine&gt;
 		&lt;!-- two axles --&gt;
 		&lt;axle name=&quot;front&quot; /&gt;
 		&lt;axle name=&quot;rear&quot; /&gt;
@@ -64,4 +72,4 @@
 			&lt;position x=&quot;3&quot; y=&quot;-3&quot; z=&quot;-3&quot; /&gt;
 		&lt;/wheel&gt;
 	&lt;/vehicleTemplate&gt;
-&lt;/dotvehicle&gt;
\ No newline at end of file
+&lt;/dotvehicle&gt;

Modified: trunk/yake/src/yake/audio/yakeAudio.cpp
===================================================================
--- trunk/yake/src/yake/audio/yakeAudio.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/audio/yakeAudio.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -37,3 +37,4 @@
 
 }
 }
+

Modified: trunk/yake/src/yake/base/math/yakeQuaternion.cpp
===================================================================
--- trunk/yake/src/yake/base/math/yakeQuaternion.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/base/math/yakeQuaternion.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -83,7 +83,7 @@
         }
     }
 
-	//-----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
     void Quaternion::ToRotationMatrix (Matrix3&amp; kRot) const
     {
         real fTx  = real(2.0)*x;

Modified: trunk/yake/src/yake/base/native/Linux/yakeApplication.cpp
===================================================================
--- trunk/yake/src/yake/base/native/Linux/yakeApplication.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/base/native/Linux/yakeApplication.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -72,3 +72,4 @@
 
 } // native
 } // yake
+

Modified: trunk/yake/src/yake/base/native/Linux/yakeCriticalSection.cpp
===================================================================
--- trunk/yake/src/yake/base/native/Linux/yakeCriticalSection.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/base/native/Linux/yakeCriticalSection.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -35,8 +35,6 @@
 //============================================================================
 namespace yake
 {
-namespace base
-{
 namespace native
 {
 
@@ -58,5 +56,5 @@
 }
 
 } // native
-} // base
 } // yake
+

Modified: trunk/yake/src/yake/base/native/Linux/yakeDebug.cpp
===================================================================
--- trunk/yake/src/yake/base/native/Linux/yakeDebug.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/base/native/Linux/yakeDebug.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -41,8 +41,6 @@
 //============================================================================
 namespace yake
 {
-namespace base
-{
 namespace native
 {
 
@@ -92,5 +90,5 @@
 }
 
 } // native
-} // base
 } // yake
+

Modified: trunk/yake/src/yake/base/native/Linux/yakeLibrary.cpp
===================================================================
--- trunk/yake/src/yake/base/native/Linux/yakeLibrary.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/base/native/Linux/yakeLibrary.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -34,29 +34,25 @@
 
 extern &quot;C&quot;
 {
-#	include &lt;dlfcn.h&gt;
+#include &lt;dlfcn.h&gt;
+#include &lt;assert.h&gt;
 }
 
 // Yake
 #include &lt;yake/base/yakePCH.h&gt;
-#include &lt;yake/base/templates/yakeSmartAssert.h&gt;
-#include &lt;yake/base/yakeException.h&gt;
+#include &lt;yake/base/native/yakeNative.h&gt;
 
 //============================================================================
 //    INTERFACE STRUCTURES / UTILITY CLASSES
 //============================================================================
 namespace yake
 {
-namespace base
-{
 namespace native
 {
 
-YAKE_DECLARE_GLOBAL;
 YAKE_BASE_NATIVE_API LibraryHandle library_Load( const char* pFilename )
 {
-	YAKE_DECLARE_FUNCTION( yake::base::native::library_Load );
-	YAKE_ASSERT( pFilename ).debug( &quot;Invalid filename.&quot; );
+	assert( pFilename &amp;&amp; &quot;Invalid filename.&quot; );
 
 	// Due to Linux libraries naming we decided to add some &quot;brand&quot; prefix
 	String yakeLibPrefix( &quot;libyake&quot; );
@@ -75,32 +71,44 @@
 	
 	String name = yakeName;
 	
-	YAKE_LOG( &quot;Trying to load &quot; + name );
+#ifdef YAKE_DEBUG
+	debug_Print( String( &quot;Trying to load &quot; + name ).c_str() );
+#endif
+
 	LibraryHandle handle = ( LibraryHandle )dlopen( name.c_str(), RTLD_LAZY );
 	
 	// trying to load library with libyapp prefix
 	if ( handle == NULL )
 	{
-		YAKE_LOG( &quot;dlerror returned:&quot; + String( dlerror() ) );
+#ifdef YAKE_DEBUG
+		debug_Print( String( &quot;dlerror returned:&quot; + String( dlerror() ) ).c_str() );
+#endif
 		
 		name = yappName;
 		
-		YAKE_LOG( &quot;Now trying to load &quot; + name );
+#ifdef YAKE_DEBUG
+		debug_Print( String( &quot;Now trying to load &quot; + name ).c_str() );
+#endif
+
 		handle = ( LibraryHandle )dlopen( name.c_str(), RTLD_LAZY );
 	}
 	
 	if ( handle == NULL )
-		throw Exception( &quot;Failed to load &quot; + String( pFilename ) + String( &quot; with both libyake and libyapp prefixes due to &quot; ) + String( dlerror() ) , &quot;native::Linux::library_Load&quot; );
+		throw &quot;Failed to load &quot; + String( pFilename ) 
+		    + String( &quot; with both libyake and libyapp prefixes due to &quot; ) 
+		    + String( dlerror() );
 
-	YAKE_LOG( &quot;successfully loaded &quot; + name );
+#ifdef YAKE_DEBUG
+	debug_Print( String( &quot;successfully loaded &quot; + name ).c_str() );
+#endif
 	
 	return handle;
 }
 
 YAKE_BASE_NATIVE_API void* library_GetSymbol( LibraryHandle library, const char* pFunction )
 {
-	YAKE_ASSERT( library ).debug( &quot;Invalid library handle.&quot; );
-	YAKE_ASSERT( pFunction ).debug( &quot;Invalid library function.&quot; );
+	assert( library &amp;&amp; &quot;Invalid library handle.&quot; );
+	assert( pFunction &amp;&amp; &quot;Invalid library function.&quot; );
 
 	// Get the Procedure's Address.
 	void* address = dlsym( const_cast&lt; void* &gt;( library ), pFunction );
@@ -110,12 +118,12 @@
  
 YAKE_BASE_NATIVE_API void library_Free( LibraryHandle library )
 {
-	YAKE_ASSERT( library ).debug( &quot;Invalid library handle&quot; );
+	assert( library &amp;&amp; &quot;Invalid library handle&quot; );
 
 	dlclose( const_cast&lt; void* &gt;( library ) );
 }
 
 
 } // native
-} // base
 } // yake
+

Modified: trunk/yake/src/yake/base/native/Linux/yakeTime.cpp
===================================================================
--- trunk/yake/src/yake/base/native/Linux/yakeTime.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/base/native/Linux/yakeTime.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -123,3 +123,4 @@
 	
 } // timer
 } // yake
+

Modified: trunk/yake/src/yake/base/yakeDebugLogAppender.cpp
===================================================================
--- trunk/yake/src/yake/base/yakeDebugLogAppender.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/base/yakeDebugLogAppender.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -52,3 +52,4 @@
 	}
 } // base
 } // yake
+

Modified: trunk/yake/src/yake/graphics/yakeGraphicsSystem.cpp
===================================================================
--- trunk/yake/src/yake/graphics/yakeGraphicsSystem.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/graphics/yakeGraphicsSystem.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -94,18 +94,18 @@
 	}
 
 	/** @Remarks Code has been taken more or less directly from Ogre's OgreCamera.cpp. */
-	Ray ICamera::createCameraToViewportRay(const real screenX, const real screenY) const
+	math::Ray ICamera::createCameraToViewportRay(const real screenX, const real screenY) const
 	{
 		real centeredScreenX = (screenX - 0.5f);
 		real centeredScreenY = (0.5f - screenY);
 
 		const real nearDist = getNearClipDistance();
 
-		real normalizedSlope = Math::Tan(getFOV() / 2); // getFOV() returns FOVy
+		real normalizedSlope = math::Math::Tan(getFOV() / 2); // getFOV() returns FOVy
 		real viewportYToWorldY = normalizedSlope * nearDist * 2;
 		real viewportXToWorldX = viewportYToWorldY * getAspectRatio();
 
-		Vector3 rayOrigin, rayDirection;
+		math::Vector3 rayOrigin, rayDirection;
 		if (getProjectionType() == PT_PERSPECTIVE)
 		{
 			rayOrigin = getPosition(); //@todo fixme should be: getDerivedPosition()
@@ -123,10 +123,11 @@
 			rayOrigin.z = 0.0f;
 			rayOrigin = getOrientation() * rayOrigin; //@todo fixme should be: getDerivedOrientation() * rayOrigin;
 			rayOrigin = getPosition() + rayOrigin; //@todo fixme should be: getDerivedPosition() + rayOrigin;
-			rayDirection = getOrientation() * Vector3::kUnitZ; //@todo fixme should be: getDerivedDirection();
+			rayDirection = getOrientation() * math::Vector3::kUnitZ; //@todo fixme should be: getDerivedDirection();
 		}
-		return Ray( rayOrigin, rayDirection );
+		return math::Ray( rayOrigin, rayDirection );
 	}
 
 } // graphics
 } // yake
+

Modified: trunk/yake/src/yake/plugins/baseLuaBindings/yakeLuaBinder.cpp
===================================================================
--- trunk/yake/src/yake/plugins/baseLuaBindings/yakeLuaBinder.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/baseLuaBindings/yakeLuaBinder.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -56,6 +56,7 @@
 				    class_&lt;Color&gt;(&quot;Color&quot;)
 				    .def( constructor&lt;&gt;() )
 				    .def( constructor&lt;real,real,real,real&gt;() )
+				    .def( constructor&lt; const Color&amp; &gt;() )
 				    //FIXME some strange members in anonymous union::struct
 				    /*						.def_readwrite( &quot;r&quot;, &amp;Color::r )
 				    						.def_readwrite( &quot;g&quot;, &amp;Color::g )

Modified: trunk/yake/src/yake/plugins/graphicsLuaBindings/yakeLuaBinder.cpp
===================================================================
--- trunk/yake/src/yake/plugins/graphicsLuaBindings/yakeLuaBinder.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/graphicsLuaBindings/yakeLuaBinder.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -112,18 +112,13 @@
 				    .def( &quot;setMaterial&quot;, &amp;IEntity::setMaterial )
 				    .def( &quot;setSubEntityMaterial&quot;, &amp;IEntity::setSubEntityMaterial )
 				    .def( &quot;setCastsShadow&quot;, &amp;IEntity::setCastsShadow )
+				    .def( &quot;setRenderDetail&quot;, &amp;IEntity::setRenderDetail )
 				];
 				YAKE_LOG( &quot;IEntity bound...&quot; );
 
 				module( YAKE_GRAPHICS_MODULE )
 				[
 				    class_&lt;ICamera, bases&lt;Movable, GraphicsEntity&gt; &gt;( &quot;ICamera&quot; )
-				    .enum_( &quot;SceneDetailLevel&quot; )
-				    [
-				        value( &quot;SDL_POINTS&quot;, ICamera::SDL_POINTS ),
-				        value( &quot;SDL_WIREFRAME&quot;, ICamera::SDL_WIREFRAME ),
-				        value( &quot;SDL_SOLID&quot;, ICamera::SDL_SOLID )
-				    ]
 				    .enum_( &quot;ProjectionType&quot; )
 				    [
 				        value( &quot;PT_ORTHOGRAPHIC&quot;, ICamera::PT_ORTHOGRAPHIC ),
@@ -149,10 +144,11 @@
 				    .def( &quot;setFixedYawAxis&quot;, &amp;ICamera::setFixedYawAxis )
 				    .def( &quot;moveRelative&quot;, &amp;ICamera::moveRelative )
 				    .def( &quot;lookAt&quot;, &amp;ICamera::lookAt )
-				    .def( &quot;rotate&quot;, (void(ICamera::*)(const Quaternion&amp;))&amp;ICamera::rotate )
-				    .def( &quot;rotateAxisAngle&quot;, (void(ICamera::*)(const Vector3&amp;, real))&amp;ICamera::rotate )
+				    .def( &quot;rotate&quot;, (void(ICamera::*)(const math::Quaternion&amp;))&amp;ICamera::rotate )
+				    .def( &quot;rotateAxisAngle&quot;, (void(ICamera::*)(const math::Vector3&amp;, real))&amp;ICamera::rotate )
 				    .def( &quot;pitch&quot;, &amp;ICamera::pitch )
 				    .def( &quot;yaw&quot;, &amp;ICamera::yaw )
+				    .def( &quot;roll&quot;, &amp;ICamera::roll )
 				    .def( &quot;createCameraToViewportRay&quot;, &amp;ICamera::createCameraToViewportRay )
 				    .def( &quot;getProjectionMatrix&quot;, &amp;ICamera::getProjectionMatrix )
 				    .def( &quot;getViewMatrix&quot;, &amp;ICamera::getViewMatrix )
@@ -191,6 +187,8 @@
 				    .def( &quot;getAttachedCamera&quot;, &amp;IViewport::getAttachedCamera )
 				    .def( &quot;setDimensions&quot;, &amp;IViewport::setDimensions )
 				    .def( &quot;setZ&quot;, &amp;IViewport::setZ )
+				    .def( &quot;setBackgroundColor&quot;, &amp;IViewport::setBackgroundColor )
+				    .def( &quot;getBackgroundColor&quot;, &amp;IViewport::getBackgroundColor )
 				];
 				YAKE_LOG( &quot;IViewport bound...&quot; );
 

Modified: trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreCamera.cpp
===================================================================
--- trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreCamera.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreCamera.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -32,7 +32,7 @@
 namespace ogre3d {
 
 	//------------------------------------------------------
-	OgreCamera::OgreCamera( Ogre::SceneManager * sceneMgr ) : mSceneMgr( sceneMgr ), mCam( 0 )
+	OgreCamera::OgreCamera( Ogre::SceneManager* sceneMgr ) : mSceneMgr( sceneMgr ), mCam( 0 )
 	{
 		YAKE_ASSERT( sceneMgr ).debug(&quot;need a scene manager!&quot;);
 		mCam = mSceneMgr-&gt;createCamera( yake::uniqueName::create(&quot;sn_&quot;) );
@@ -69,66 +69,90 @@
 	}
 
 	//------------------------------------------------------
-	void OgreCamera::setPosition( const Vector3 &amp; position )
+	void OgreCamera::setPosition( const math::Vector3&amp; position )
 	{
 		YAKE_ASSERT( mCam ).debug(&quot;need a camera!&quot;);
 		mCam-&gt;setPosition( VEC_YAKE2OGRE( position ) );
 	}
 
 	//------------------------------------------------------
-	Vector3 OgreCamera::getPosition() const
+	math::Vector3 OgreCamera::getPosition() const
 	{
 		YAKE_ASSERT( mCam ).debug(&quot;need a camera!&quot;);
 		return VEC_OGRE2YAKE( mCam-&gt;getPosition() );
 	}
 
 	//------------------------------------------------------
-	void OgreCamera::setOrientation( const Quaternion &amp; orientation )
+	math::Vector3 OgreCamera::getDerivedPosition() const
 	{
 		YAKE_ASSERT( mCam ).debug(&quot;need a camera!&quot;);
+		return VEC_OGRE2YAKE( mCam-&gt;getDerivedPosition() );
+	}
+
+	//------------------------------------------------------
+	void OgreCamera::setOrientation( const math::Quaternion &amp; orientation )
+	{
+		YAKE_ASSERT( mCam ).debug(&quot;need a camera!&quot;);
 		mCam-&gt;setOrientation( QUAT_YAKE2OGRE( orientation ) );
 	}
 
 	//------------------------------------------------------
-	Quaternion OgreCamera::getOrientation() const
+	math::Quaternion OgreCamera::getOrientation() const
 	{
 		YAKE_ASSERT( mCam ).debug(&quot;need a camera!&quot;);
 		return QUAT_OGRE2YAKE( mCam-&gt;getOrientation() );
 	}
 
 	//------------------------------------------------------
+	math::Quaternion OgreCamera::getDerivedOrientation() const
+	{
+		YAKE_ASSERT( mCam ).debug(&quot;need a camera!&quot;);
+		return QUAT_OGRE2YAKE( mCam-&gt;getDerivedOrientation() );
+	}
+
+	//------------------------------------------------------
 	void OgreCamera::setDetailLevel( SceneDetailLevel sd )
 	{
+// for Ogre 1.1.0 &quot;Dagon&quot; compatibility
+#if OGRE_VERSION_MINOR &gt;= 1 
+		mCam-&gt;setPolygonMode( Ogre::PolygonMode( sd ) );
+#else
 		mCam-&gt;setDetailLevel( Ogre::SceneDetailLevel( sd ) );
+#endif
 	}
 	
 	//------------------------------------------------------
-	ICamera::SceneDetailLevel OgreCamera::getDetailLevel() const
+	SceneDetailLevel OgreCamera::getDetailLevel() const
 	{
+// for Ogre 1.1.0 &quot;Dagon&quot; compatibility
+#if OGRE_VERSION_MINOR &gt;= 1 
+		return SceneDetailLevel( mCam-&gt;getPolygonMode() );
+#else
 		return SceneDetailLevel( mCam-&gt;getDetailLevel() );
+#endif
 	}
 	
 	//------------------------------------------------------
-	void OgreCamera::setDirection( const Vector3&amp; rVec )
+	void OgreCamera::setDirection( const math::Vector3&amp; rVec )
 	{
 		//@todo cleaner implementation
 		mCam-&gt;setDirection( VEC_YAKE2OGRE( rVec ) );
 	}
 	
 	//------------------------------------------------------
-	Vector3 OgreCamera::getDirection() const
+	math::Vector3 OgreCamera::getDirection() const
 	{
 		return VEC_OGRE2YAKE( mCam-&gt;getDirection() );
 	}
 	
 	//------------------------------------------------------
-	Vector3 OgreCamera::getUp() const
+	math::Vector3 OgreCamera::getUp() const
 	{
 		return VEC_OGRE2YAKE( mCam-&gt;getUp() );
 	}
 	
 	//------------------------------------------------------
-	Vector3 OgreCamera::getRight() const
+	math::Vector3 OgreCamera::getRight() const
 	{
 		return VEC_OGRE2YAKE( mCam-&gt;getRight() );
 	}
@@ -140,19 +164,19 @@
 	}
 	
 	//------------------------------------------------------
-	void OgreCamera::setFixedYawAxis( const Vector3&amp; yawAxis )
+	void OgreCamera::setFixedYawAxis( const math::Vector3&amp; yawAxis )
 	{
 		mCam-&gt;setFixedYawAxis( true, VEC_YAKE2OGRE( yawAxis ) );
 	}
 	
 	//------------------------------------------------------
-	void OgreCamera::moveRelative( const Vector3&amp; rVec )
+	void OgreCamera::moveRelative( const math::Vector3&amp; rVec )
 	{
 		mCam-&gt;moveRelative( VEC_YAKE2OGRE( rVec ) );
 	}
 	
 	//------------------------------------------------------
-	void OgreCamera::lookAt( const Vector3&amp; target )
+	void OgreCamera::lookAt( const math::Vector3&amp; target )
 	{
 		mCam-&gt;lookAt( VEC_YAKE2OGRE( target ) );
 	}
@@ -216,7 +240,7 @@
 	}
 
 	//------------------------------------------------------
-	Matrix4 OgreCamera::getProjectionMatrix() const
+	math::Matrix4 OgreCamera::getProjectionMatrix() const
 	{
 		YAKE_ASSERT( mCam ).debug(&quot;need a camera!&quot;);
 // for Ogre 1.1.0 &quot;Dagon&quot; compatibility
@@ -228,7 +252,7 @@
 	}
 
 	//------------------------------------------------------
-	Matrix4 OgreCamera::getViewMatrix() const
+	math::Matrix4 OgreCamera::getViewMatrix() const
 	{
 		YAKE_ASSERT( mCam ).debug(&quot;need a camera!&quot;);
 		return MATRIX4_OGRE2YAKE( mCam-&gt;getViewMatrix() );

Modified: trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreCore.cpp
===================================================================
--- trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreCore.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreCore.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -108,7 +108,6 @@
 				{
 					mRSys = (*it);
 					String str = mRSys-&gt;getName().c_str();
-					//if (str.find(&quot;3D9&quot;))
 					if ( str.find(&quot;GL&quot;) )
 						found = true;
 					++it;
@@ -127,6 +126,14 @@
 				mRSys-&gt;setConfigOption(&quot;VSync&quot;, &quot;No&quot;);
 				mRSys-&gt;setConfigOption(&quot;Video Mode&quot;, &quot;800 x 600 @ 32-bit colour&quot;);
 #else
+				if ( mConfig[ &quot;show_config_dialog&quot; ] == &quot;no&quot; )
+				{
+				    if ( !mRoot-&gt;restoreConfig() )
+				    {
+					return;
+				    }
+				}
+				else				
 				if (!mRoot-&gt;showConfigDialog())
 				{
 					return;
@@ -175,7 +182,14 @@
 	{
 		StringMap::const_iterator itFind = mConfig.find(&quot;scenemanager&quot;);
 		if (itFind == mConfig.end())
+		{
+// for Ogre 1.1.0 &quot;Dagon&quot; compatibility
+#if OGRE_VERSION_MINOR &gt;= 1 
+			mSceneMgr = mRoot-&gt;createSceneManager( ST_GENERIC, &quot;YakeSM&quot; );
+#else
 			mSceneMgr = mRoot-&gt;getSceneManager( ST_GENERIC );
+#endif
+		}
 		else
 		{
 			String val = itFind-&gt;second;
@@ -190,7 +204,12 @@
 				YAKE_ASSERT( 1==0 ).warning(&quot;unknown scene manager config option. Using fallback: generic.&quot;);
 				mSceneType = ST_GENERIC;
 			}
+// for Ogre 1.1.0 &quot;Dagon&quot; compatibility
+#if OGRE_VERSION_MINOR &gt;= 1 
+			mSceneMgr = mRoot-&gt;createSceneManager( mSceneType, &quot;YakeSM&quot; );
+#else
 			mSceneMgr = mRoot-&gt;getSceneManager( mSceneType );
+#endif
 		}
 		YAKE_ASSERT( mSceneMgr );
 	}
@@ -206,7 +225,7 @@
 				Ogre::SceneNode::ObjectIterator itObj = pSN-&gt;getAttachedObjectIterator();
 				while (itObj.hasMoreElements())
 				{
-					YAKE_LOG_WARNING(String(&quot;gfx rootnode.obj '&quot;) &lt;&lt; String(itObj.getNext()-&gt;getName().c_str()) &lt;&lt; &quot;'&quot;);
+					YAKE_LOG_WARNING( &quot;gfx rootnode.obj '&quot; + itObj.getNext()-&gt;getName() + &quot;'&quot; );
 				}
 			}
 			if (pSN-&gt;numChildren() &gt; 0)
@@ -214,7 +233,7 @@
 				Ogre::SceneNode::ChildNodeIterator itN = pSN-&gt;getChildIterator();
 				while (itN.hasMoreElements())
 				{
-					YAKE_LOG_WARNING(String(&quot;gfx rootnode.node '&quot;) &lt;&lt; String(itN.getNext()-&gt;getName().c_str()) &lt;&lt; &quot;'&quot;);
+					YAKE_LOG_WARNING( &quot;gfx rootnode.node '&quot; + itN.getNext()-&gt;getName() + &quot;'&quot; );
 				}
 			}
 			pSN-&gt;detachAllObjects();
@@ -251,13 +270,13 @@
 		while (seci.hasMoreElements())
 		{
 			secName = seci.peekNextKey();
-            ConfigFile::SettingsMultiMap *settings = seci.getNext();
-            ConfigFile::SettingsMultiMap::iterator i;
-            for (i = settings-&gt;begin(); i != settings-&gt;end(); ++i)
-            {
-                typeName = i-&gt;first;
-                archName = i-&gt;second;
-				Ogre::ResourceGroupManager::getSingleton().addResourceLocation(archName, typeName, secName);
+			ConfigFile::SettingsMultiMap *settings = seci.getNext();
+			ConfigFile::SettingsMultiMap::iterator i;
+			for (i = settings-&gt;begin(); i != settings-&gt;end(); ++i)
+			{
+			    typeName = i-&gt;first;
+			    archName = i-&gt;second;
+			    Ogre::ResourceGroupManager::getSingleton().addResourceLocation(archName, typeName, secName);
 			}
 		}
 	}
@@ -343,3 +362,4 @@
 }
 }
 }
+

Modified: trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreEntity.cpp
===================================================================
--- trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreEntity.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreEntity.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -34,7 +34,7 @@
 namespace ogre3d {
 
 	//------------------------------------------------------
-	OgreEntity::OgreEntity( ::Ogre::SceneManager * sceneMgr, const String &amp; mesh ) : mSceneMgr( sceneMgr ), mEntity( 0 )
+	OgreEntity::OgreEntity( Ogre::SceneManager* sceneMgr, const String&amp; mesh ) : mSceneMgr( sceneMgr ), mEntity( 0 )
 	{
 		YAKE_ASSERT( mSceneMgr ).debug(&quot;need a scene manager!&quot;);
 		YAKE_TRY
@@ -78,14 +78,14 @@
 	}
 
 	//------------------------------------------------------
-	void OgreEntity::setMaterial( const String &amp; materialName )
+	void OgreEntity::setMaterial( const String&amp; materialName )
 	{
 		if (mEntity)
 			mEntity-&gt;setMaterialName( materialName );
 	}
 
 	//------------------------------------------------------
-	void OgreEntity::setSubEntityMaterial( const String &amp; subEntity, const String &amp; materialName )
+	void OgreEntity::setSubEntityMaterial( const String&amp; subEntity, const String&amp; materialName )
 	{
 		if (mEntity)
 		{
@@ -115,6 +115,26 @@
 			mEntity-&gt;setCastShadows( castsShadow );
 	}
 
+	//------------------------------------------------------
+	void OgreEntity::setRenderDetail( SceneDetailLevel sdl )
+	{
+	    YAKE_ASSERT( mEntity ).error( &quot;need an entity&quot; );
+// for Ogre 1.1.0 &quot;Dagon&quot; compatibility
+#if OGRE_VERSION_MINOR &gt;= 1 
+	    // in Dagon material system becomes more consistent. So
+	    // polygon mode is considered to be a part of the render state,
+	    // i.e. material. If you want to change polygon mode you're 
+	    // encouraged to change entity ( subentity ) material.
+	    // This implementation just sets polygon mode override flag so 
+	    // entity's polygon mode can be overrided by camera's setting.
+	    YAKE_ASSERT( false ).warning( &quot;Deprecated method. Read comments in the code.&quot; );
+	    mEntity-&gt;setPolygonModeOverrideable( true );
+#else
+	    mEntity-&gt;setRenderDetail( Ogre::SceneDetailLevel( sdl ) );
+#endif
+	}
+
 }
 }
 }
+

Modified: trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreGeometryAccess.cpp
===================================================================
--- trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreGeometryAccess.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreGeometryAccess.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -314,7 +314,7 @@
 	}
 
 	//-----------------------------------------------------
-	bool OgreSubmeshAccess::setPosition( uint32 index, const Vector3 &amp; position )
+	bool OgreSubmeshAccess::setPosition( uint32 index, const math::Vector3 &amp; position )
 	{
 		YAKE_ASSERT( mpLockedPositions != 0 ).warning(&quot;should be locked!&quot;);
 		YAKE_ASSERT( mhwvbPositions.isNull() == false ).warning(&quot;need a hwvb!&quot;);
@@ -371,7 +371,7 @@
 	}
 
 	//-----------------------------------------------------
-	bool OgreSubmeshAccess::setTexCoord( uint16 set, uint16 index, const Vector3 &amp; uv )
+	bool OgreSubmeshAccess::setTexCoord( uint16 set, uint16 index, const math::Vector3 &amp; uv )
 	{
 		YAKE_ASSERT( mpLockedTexCoords[set] != 0 ).warning(&quot;should be locked!&quot;);
 		YAKE_ASSERT( mhwvbTexCoords[set].isNull() == false ).warning(&quot;need a hwvb!&quot;);
@@ -431,7 +431,7 @@
 	}
 
 	//-----------------------------------------------------
-	bool OgreSubmeshAccess::setColour( uint32 index, const Color &amp; colour )
+	bool OgreSubmeshAccess::setColour( uint32 index, const math::Color&amp; colour )
 	{
 		YAKE_ASSERT( mpLockedColours != 0 ).warning(&quot;should be locked!&quot;);
 		YAKE_ASSERT( mhwvbColours.isNull() == false ).warning(&quot;need a hwvb!&quot;);
@@ -540,7 +540,7 @@
 	}
 
 	//-----------------------------------------------------
-	bool OgreSubmeshAccess::setNormal( uint32 index, const Vector3 &amp; normal )
+	bool OgreSubmeshAccess::setNormal( uint32 index, const math::Vector3 &amp; normal )
 	{
 		YAKE_ASSERT( mpLockedNormals != 0 ).warning(&quot;should be locked!&quot;);
 		YAKE_ASSERT( mhwvbNormals.isNull() == false ).warning(&quot;need a hwvb!&quot;);
@@ -556,3 +556,4 @@
 }
 }
 }
+

Modified: trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreLight.cpp
===================================================================
--- trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreLight.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreLight.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -117,14 +117,14 @@
 	}
 
 	//------------------------------------------------------
-	void OgreLight::setDiffuseColour( const Color&amp; colour )
+	void OgreLight::setDiffuseColour( const math::Color&amp; colour )
 	{
 		YAKE_ASSERT( mLight ).debug( &quot;need actual light!&quot; );
 		mLight-&gt;setDiffuseColour( COL_YAKE2OGRE( colour ) );
 	}
 
 	//------------------------------------------------------
-	void OgreLight::setSpecularColour( const Color&amp; colour )
+	void OgreLight::setSpecularColour( const math::Color&amp; colour )
 	{
 		YAKE_ASSERT( mLight ).debug( &quot;need actual light!&quot; );
 		mLight-&gt;setSpecularColour( COL_YAKE2OGRE( colour ) );
@@ -208,42 +208,42 @@
 	}
 
 	//------------------------------------------------------
-	void OgreLight::setPosition( const Vector3&amp; rPosition )
+	void OgreLight::setPosition( const math::Vector3&amp; rPosition )
 	{
 		YAKE_ASSERT( mLight ).debug( &quot;need actual light!&quot; );
 		mLight-&gt;setPosition( VEC_YAKE2OGRE( rPosition ) );
 	}
 
 	//------------------------------------------------------
-	Vector3 OgreLight::getPosition() const
+	math::Vector3 OgreLight::getPosition() const
 	{
 		YAKE_ASSERT( mLight ).debug( &quot;need actual light!&quot; );
 		return VEC_OGRE2YAKE( mLight-&gt;getPosition() );
 	}
 
 	//------------------------------------------------------
-	void OgreLight::setOrientation( const Quaternion &amp; orientation )
+	void OgreLight::setOrientation( const math::Quaternion &amp; orientation )
 	{
 		YAKE_ASSERT( mLight ).debug( &quot;need actual light!&quot; );
-		setDirection( orientation * Vector3(0,0,1) );
+		setDirection( orientation * math::Vector3(0,0,1) );
 	}
 
 	//------------------------------------------------------
-	Quaternion OgreLight::getOrientation() const
+	math::Quaternion OgreLight::getOrientation() const
 	{
 		YAKE_ASSERT( mLight ).debug( &quot;not implemented...&quot; );
-		return Quaternion::kIdentity;
+		return math::Quaternion::kIdentity;
 	}
 
 	//------------------------------------------------------
-	void OgreLight::setDirection( const Vector3&amp; direction )
+	void OgreLight::setDirection( const math::Vector3&amp; direction )
 	{
 		YAKE_ASSERT( mLight ).debug( &quot;need actual light!&quot; );
 		mLight-&gt;setDirection( VEC_YAKE2OGRE( direction ) );
 	}
 
 	//------------------------------------------------------
-	Vector3 OgreLight::getDirection() const
+	math::Vector3 OgreLight::getDirection() const
 	{
 		YAKE_ASSERT( mLight ).debug( &quot;need actual light!&quot; );
 		return VEC_OGRE2YAKE( mLight-&gt;getDirection() );
@@ -252,3 +252,4 @@
 } // ogre3d
 } // graphics
 } // yake
+

Modified: trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreNode.cpp
===================================================================
--- trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreNode.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreNode.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -37,20 +37,22 @@
 namespace ogre3d {
 
 	//------------------------------------------------------
-	OgreNode::OgreNode( GraphicalWorld&amp; owningWorld, Ogre::SceneManager * sceneMgr, const String&amp; name /*= &quot;&quot;*/ ) : 
+	OgreNode::OgreNode( GraphicalWorld&amp; owningWorld, Ogre::SceneManager* sceneMgr, const String&amp; name /*= &quot;&quot;*/ ) : 
 			mWorld( owningWorld ),
 			mSceneNode( 0 ) ,mSceneMgr( sceneMgr ), mParentNode(0)
 	{
 		YAKE_ASSERT( sceneMgr ).debug(&quot;need a scene manager!&quot;);
+
 		String ogreid = name;
 		if (ogreid.empty())
-			ogreid = uniqueName::create(&quot;sn_&quot;+name+&quot;_&quot;);
+			ogreid = uniqueName::create( &quot;sn_&quot; );
 		mName = ogreid;
 		mSceneNode = static_cast&lt; Ogre::SceneNode* &gt;( mSceneMgr-&gt;getRootSceneNode()-&gt;createChild( ogreid ) );
 		YAKE_ASSERT( mSceneNode ).warning(&quot;Couldn't create a scene node!&quot;);
+
 		mSceneNode-&gt;setPosition( 0, 0, 0 );
+		
 		mWorld.reg( this );
-		//YAKE_LOG(String(&quot;gfx: new node '&quot;) &lt;&lt; name &lt;&lt; &quot;' ogreid='&quot; &lt;&lt; String(mSceneNode-&gt;getName().c_str()) &lt;&lt; &quot;'&quot;);
 	}
 
 	//------------------------------------------------------
@@ -149,26 +151,26 @@
 	}
 
 	//------------------------------------------------------
-	void OgreNode::setPosition( const Vector3 &amp; position )
+	void OgreNode::setPosition( const math::Vector3 &amp; position )
 	{
 		YAKE_ASSERT( mSceneNode ).debug(&quot;need a scene node!&quot;);
 		mSceneNode-&gt;setPosition( VEC_YAKE2OGRE( position ) );
 	}
 
 	//------------------------------------------------------
-	Vector3 OgreNode::getPosition() const
+	math::Vector3 OgreNode::getPosition() const
 	{
 		YAKE_ASSERT( mSceneNode ).debug(&quot;need a scene node!&quot;);
 		return VEC_OGRE2YAKE( mSceneNode-&gt;getPosition() );
 	}
 
 	//------------------------------------------------------
-	Vector3 OgreNode::getPosition( ISceneNode::TransformSpace ts ) const
+	math::Vector3 OgreNode::getPosition( ISceneNode::TransformSpace ts ) const
 	{
 		switch( ts )
 		{
 			case TS_LOCAL:
-				return Vector3();
+				return math::Vector3();
 				
 			case TS_PARENT:
 				return getPosition();
@@ -178,74 +180,82 @@
 			
 			default:
 				YAKE_ASSERT( 0 ).error( &quot;Unknown transform space&quot; );
-				return Vector3();
+				return math::Vector3();
 		}
 	}
 
 	//------------------------------------------------------
-	void OgreNode::setOrientation( const Quaternion &amp; orientation )
+	void OgreNode::setOrientation( const math::Quaternion &amp; orientation )
 	{
 		YAKE_ASSERT( mSceneNode ).debug(&quot;need a scene node!&quot;);
 		mSceneNode-&gt;setOrientation( QUAT_YAKE2OGRE( orientation ) );
 	}
 
 	//------------------------------------------------------
-	Quaternion OgreNode::getOrientation() const
+	math::Quaternion OgreNode::getOrientation() const
 	{
 		YAKE_ASSERT( mSceneNode ).debug(&quot;need a scene node!&quot;);
 		return QUAT_OGRE2YAKE( mSceneNode-&gt;getOrientation() );
 	}
 
 	//------------------------------------------------------
-	void OgreNode::setScale( const Vector3 &amp; scale )
+	void OgreNode::setScale( const math::Vector3 &amp; scale )
 	{
 		YAKE_ASSERT( mSceneNode ).debug(&quot;need a scene node!&quot;);
 		mSceneNode-&gt;setScale( VEC_YAKE2OGRE( scale ) );
 	}
 
 	//------------------------------------------------------
-	Vector3 OgreNode::getScale() const
+	math::Vector3 OgreNode::getScale() const
 	{
 		YAKE_ASSERT( mSceneNode ).debug(&quot;need a scene node!&quot;);
 		return VEC_OGRE2YAKE( mSceneNode-&gt;getScale() );
 	}
 
 	//------------------------------------------------------
-	Vector3 OgreNode::getDerivedPosition() const
+	void OgreNode::setInheritScale( bool inherit )
 	{
 		YAKE_ASSERT( mSceneNode ).debug(&quot;need a scene node!&quot;);
+
+		mSceneNode-&gt;setInheritScale( inherit );
+	}
+
+	//------------------------------------------------------
+	math::Vector3 OgreNode::getDerivedPosition() const
+	{
+		YAKE_ASSERT( mSceneNode ).debug(&quot;need a scene node!&quot;);
 		return VEC_OGRE2YAKE( mSceneNode-&gt;_getDerivedPosition() );
 	}
 
 	//------------------------------------------------------
-	void OgreNode::getDerivedPosition( Vector3&amp; retPos ) const
+	void OgreNode::getDerivedPosition( math::Vector3&amp; retPos ) const
 	{
 		YAKE_ASSERT( mSceneNode ).debug(&quot;need a scene node!&quot;);
 		retPos = VEC_OGRE2YAKE( mSceneNode-&gt;_getDerivedPosition() );
 	}
 
 	//------------------------------------------------------
-	Quaternion OgreNode::getDerivedOrientation() const
+	math::Quaternion OgreNode::getDerivedOrientation() const
 	{
 		YAKE_ASSERT( mSceneNode ).debug(&quot;need a scene node!&quot;);
 		return QUAT_OGRE2YAKE( mSceneNode-&gt;_getDerivedOrientation() );
 	}
 
 	//------------------------------------------------------
-	void OgreNode::getDerivedOrientation( Quaternion&amp; retRot ) const
+	void OgreNode::getDerivedOrientation( math::Quaternion&amp; retRot ) const
 	{
 		YAKE_ASSERT( mSceneNode ).debug(&quot;need a scene node!&quot;);
 		retRot = QUAT_OGRE2YAKE( mSceneNode-&gt;_getDerivedOrientation() );
 	}
 
 	//------------------------------------------------------
-	void OgreNode::translate( const Vector3&amp; rDelta, const TransformSpace relativeTo /*= TS_PARENT*/ )
+	void OgreNode::translate( const math::Vector3&amp; rDelta, const TransformSpace relativeTo /*= TS_PARENT*/ )
 	{
 		mSceneNode-&gt;translate( VEC_YAKE2OGRE(rDelta), TS_YAKE2OGRE(relativeTo) );
 	}
 
 	//------------------------------------------------------
-	void OgreNode::rotate( const Quaternion&amp; rDelta, const TransformSpace relativeTo /*= TS_PARENT*/ )
+	void OgreNode::rotate( const math::Quaternion&amp; rDelta, const TransformSpace relativeTo /*= TS_PARENT*/ )
 	{
 		mSceneNode-&gt;rotate( QUAT_YAKE2OGRE(rDelta), TS_YAKE2OGRE(relativeTo) );
 	}
@@ -372,8 +382,14 @@
 	ISceneNode* OgreNode::createChildNode( const String&amp; name /*= &quot;&quot;*/ )
 	{
 		YAKE_ASSERT( mSceneNode ).debug(&quot;need a scene node!&quot;);
+
 		OgreNode* pChild = new OgreNode( mWorld, mSceneMgr, name );
+
 		this-&gt;addChildNode( pChild );
+
+		pChild-&gt;setPosition( math::Vector3() );
+		pChild-&gt;setOrientation( math::Quaternion() );
+
 		return pChild;
 	}
 

Modified: trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreParticleSystem.cpp
===================================================================
--- trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreParticleSystem.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreParticleSystem.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -32,19 +32,34 @@
 namespace graphics {
 
 	//------------------------------------------------------
+// for Ogre 1.1.0 &quot;Dagon&quot; compatibility
+#if OGRE_VERSION_MINOR &gt;= 1 
+	OgreParticleSystem::OgreParticleSystem( Ogre::SceneManager&amp; rSMgr, const String&amp; rPSTempl ) : 
+		mSceneMgr( rSMgr ), mParticleSys( NULL )
+	{
+		mParticleSys = mSceneMgr.createParticleSystem( uniqueName::create( &quot;ps_&quot; ), rPSTempl );
+
+		YAKE_ASSERT( mParticleSys ).debug( &quot;Failed to create particle system!&quot; );
+	}
+#else
 	OgreParticleSystem::OgreParticleSystem( Ogre::ParticleSystemManager&amp; rPSMgr, const String&amp; rPSTempl ) : 
-																mParticleSysMgr( rPSMgr ), mParticleSys( NULL )
+		mParticleSysMgr( rPSMgr ), mParticleSys( NULL )
 	{
 		mParticleSys = mParticleSysMgr.createSystem( uniqueName::create( &quot;ps_&quot; ), rPSTempl );
 
 		YAKE_ASSERT( mParticleSys ).debug( &quot;Failed to create particle system!&quot; );
 	}
-
+#endif
 	//------------------------------------------------------
 	OgreParticleSystem::~OgreParticleSystem()
 	{
 		YAKE_ASSERT( mParticleSys );
+// for Ogre 1.1.0 &quot;Dagon&quot; compatibility
+#if OGRE_VERSION_MINOR &gt;= 1 
+		mSceneMgr.destroyParticleSystem( mParticleSys );
+#else
 		mParticleSysMgr.destroySystem( mParticleSys-&gt;getName() );
+#endif
 	}
 
 	//------------------------------------------------------
@@ -123,3 +138,4 @@
 
 } // graphics
 } // yake
+

Modified: trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreViewport.cpp
===================================================================
--- trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreViewport.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreViewport.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -49,7 +49,8 @@
 		mViewport = pWnd-&gt;addViewport( mCamera-&gt;getCamera_(), 100, 0., 0., 1., 1. );
 		YAKE_ASSERT( mViewport ).error(&quot;viewport creation failed!&quot;);
 
-		mViewport-&gt;setBackgroundColour( Ogre::ColourValue(0.2,0.2,0.3) );
+		// default - is a black background
+		mViewport-&gt;setBackgroundColour( Ogre::ColourValue( 0, 0, 0 ) );
 	}
 
 	//------------------------------------------------------
@@ -96,6 +97,19 @@
 	}
 
 	//------------------------------------------------------
+	void OgreViewport::setBackgroundColor( const math::Color&amp; col )
+	{
+	    mViewport-&gt;setBackgroundColour( COL_YAKE2OGRE( col ) );
+
+	}
+
+	//------------------------------------------------------
+	math::Color OgreViewport::getBackgroundColor() const
+	{
+	    return COL_OGRE2YAKE( mViewport-&gt;getBackgroundColour() );
+	}
+
+	//------------------------------------------------------
 	void OgreViewport::killViewport()
 	{
 		Ogre::RenderWindow* pWnd = mCore-&gt;getRenderWindow();

Modified: trunk/yake/src/yake/plugins/graphicsOgre/yakeGraphicsWorld.cpp
===================================================================
--- trunk/yake/src/yake/plugins/graphicsOgre/yakeGraphicsWorld.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/graphicsOgre/yakeGraphicsWorld.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -41,7 +41,7 @@
 #include &lt;yake/plugins/graphicsOgre/graphicsOgreCore.h&gt;
 #include &lt;yake/plugins/graphicsOgre/graphicsOgreParticleSystem.h&gt;
 #include &lt;yake/plugins/graphicsOgre/graphicsOgreGeometryAccess.h&gt;
-#define YAKE_USE_OSM
+
 #ifdef YAKE_USE_OSM
 #include &quot;OgreOSMScene.h&quot;
 #endif
@@ -171,7 +171,12 @@
 	IParticleSystem* GraphicalWorld::createParticleSystem( const String&amp; rPSTemplateName )
 	{
 		YAKE_ASSERT( msCore ).debug(&quot;need a core!&quot;);
+// for Ogre 1.1.0 &quot;Dagon&quot; compatibility
+#if OGRE_VERSION_MINOR &gt;= 1 
+		return new OgreParticleSystem( *msCore-&gt;getSceneMgr(), rPSTemplateName );
+#else
 		return new OgreParticleSystem( *msCore-&gt;getParticleSysMgr(), rPSTemplateName );
+#endif
 	}
 
 	//-----------------------------------------------------
@@ -251,7 +256,7 @@
 			if (contains(params,&quot;tex_count&quot;))
 				texCount = StringUtil::parseInt(params[&quot;tex_count&quot;]);
 
-			Color colour(0.6f,0.6f,0.6f,1.0f);
+			math::Color colour(0.6f,0.6f,0.6f,1.0f);
 			if (contains(params,&quot;colour.r&quot;))
 				colour.r = StringUtil::parseReal(params[&quot;colour.r&quot;]);
 			if (contains(params,&quot;colour.g&quot;))
@@ -354,7 +359,7 @@
 	}
 
 	//-----------------------------------------------------
-	IEntity* GraphicalWorld::pickEntity(const Ray&amp; ray)
+	IEntity* GraphicalWorld::pickEntity(const math::Ray&amp; ray)
 	{
 		YAKE_ASSERT( msCore );
 

Modified: trunk/yake/src/yake/plugins/inputOgre/InputSystemOgre.cpp
===================================================================
--- trunk/yake/src/yake/plugins/inputOgre/InputSystemOgre.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/inputOgre/InputSystemOgre.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -43,7 +43,7 @@
 	//-----------------------------------------------------------------------
 	MouseDeviceOgre::MouseDeviceOgre(Ogre::InputReader * inputReader) :
 				mInputReader(inputReader),
-				mPosition(Vector3::kZero)
+				mPosition(math::Vector3::kZero)
 	{
 		mButtons[0] = mButtons[1] = mButtons[2] = false;
 	}
@@ -68,7 +68,7 @@
 	}
 	
 	//-----------------------------------------------------------------------
-	Vector3 MouseDeviceOgre::getPosition() const
+	math::Vector3 MouseDeviceOgre::getPosition() const
 	{
 		return mPosition;
 	}

Modified: trunk/yake/src/yake/plugins/physicsODE/OdeActor.cpp
===================================================================
--- trunk/yake/src/yake/plugins/physicsODE/OdeActor.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/physicsODE/OdeActor.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -1,28 +1,28 @@
 /*
-   ------------------------------------------------------------------------------------
-   This file is part of YAKE
-   Copyright  2004 The YAKE Team
-   For the latest information visit <A HREF="http://www.yake.org">http://www.yake.org</A> 
-   ------------------------------------------------------------------------------------
-   This program is free software; you can redistribute it and/or modify it under
-   the terms of the GNU Lesser General Public License as published by the Free Software
-   Foundation; either version 2 of the License, or (at your option) any later
-   version.
+------------------------------------------------------------------------------------
+This file is part of YAKE
+Copyright  2004 The YAKE Team
+For the latest information visit <A HREF="http://www.yake.org">http://www.yake.org</A> 
+------------------------------------------------------------------------------------
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU Lesser General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
 
-   This program is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
-   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+This program is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 
-   You should have received a copy of the GNU Lesser General Public License along with
-   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
-   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
-   <A HREF="http://www.gnu.org/copyleft/lesser.txt.">http://www.gnu.org/copyleft/lesser.txt.</A>
-   ------------------------------------------------------------------------------------
-   If you are interested in another license model contact the Yake Team via
-   E-Mail: <A HREF="https://lists.berlios.de/mailman/listinfo/yake-svn">team at yake.org.</A>
-   For more information see the LICENSE file in the root directory of the
-   source code distribution.
-   ------------------------------------------------------------------------------------
+You should have received a copy of the GNU Lesser General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+<A HREF="http://www.gnu.org/copyleft/lesser.txt.">http://www.gnu.org/copyleft/lesser.txt.</A>
+------------------------------------------------------------------------------------
+If you are interested in another license model contact the Yake Team via
+E-Mail: <A HREF="https://lists.berlios.de/mailman/listinfo/yake-svn">team at yake.org.</A>
+For more information see the LICENSE file in the root directory of the
+source code distribution.
+------------------------------------------------------------------------------------
 */
 #include &lt;yake/plugins/physicsODE/yakePCH.h&gt;
 #include &lt;yake/plugins/physicsODE/OdeWorld.h&gt;
@@ -32,106 +32,104 @@
 #include &lt;yake/plugins/physicsODE/OdeShapes.h&gt;
 
 namespace yake {
-namespace physics {
+	namespace physics {
 
-    //-----------------------------------------------------
-    //	OdeActor
-    //-----------------------------------------------------
-	
-    //-----------------------------------------------------
-    OdeActor::OdeActor( OdeWorld* pWorld, bool bDynamic ) :
-		mOdeWorld(pWorld),
+		//-----------------------------------------------------
+		//	OdeActor
+		//-----------------------------------------------------
+
+		//-----------------------------------------------------
+		OdeActor::OdeActor( OdeWorld* pWorld, bool bDynamic ) :
+	mOdeWorld(pWorld),
 		mBody(0)
-    {
+	{
 		if (bDynamic)
 		{
 			mBody = new OdeBody( mOdeWorld, *this );
 			YAKE_ASSERT( mBody ).error( &quot;Failed to create body!&quot; );
-			mBody-&gt;setPosition( Vector3::kZero );
-			mBody-&gt;setOrientation( Quaternion::kIdentity );
+			mBody-&gt;setPosition( math::Vector3::kZero );
+			mBody-&gt;setOrientation( math::Quaternion::kIdentity );
 		}
-		this-&gt;setPosition( Vector3::kZero );
-		this-&gt;setOrientation( Quaternion::kIdentity );
-    }
+		this-&gt;setPosition( math::Vector3::kZero );
+		this-&gt;setOrientation( math::Quaternion::kIdentity );
+	}
 
-    //-----------------------------------------------------
-    OdeActor::~OdeActor()
-    {
+	//-----------------------------------------------------
+	OdeActor::~OdeActor()
+	{
 		YAKE_SAFE_DELETE( mBody );
 		// destroy all shapes
 		mShapes.clear();
-    }
+	}
 
-    //-----------------------------------------------------
-    IWorld* OdeActor::getCreator() const
-    {
+	//-----------------------------------------------------
+	IWorld* OdeActor::getCreator() const
+	{
 		return mOdeWorld;
-    }
+	}
 
-    //-----------------------------------------------------
-    void OdeActor::setEnabled(const bool enabled)
-    {
+	//-----------------------------------------------------
+	void OdeActor::setEnabled(const bool enabled)
+	{
 		YAKE_ASSERT( 0 &amp;&amp; &quot;NOT IMPLEMENTED&quot; );
-    }
+	}
 
-    //-----------------------------------------------------
-    bool OdeActor::isEnabled() const
-    {
+	//-----------------------------------------------------
+	bool OdeActor::isEnabled() const
+	{
 		return true;
-    }
+	}
 
-    //-----------------------------------------------------
-    OdeGeom* OdeActor::createTransformGeomIfNeeded(	OdeGeom* pGeom,
-	    const Vector3&amp; rOffset,
-	    const Quaternion&amp; rRelOrientation )
-    {
-		//if ( rOffset == Vector3::kZero &amp;&amp; rRelOrientation == Quaternion::kIdentity )
-		//    return pGeom;
-
+	//-----------------------------------------------------
+	OdeGeom* OdeActor::createTransformGeom(	OdeGeom* pGeom,
+		const math::Vector3&amp; rOffset,
+		const math::Quaternion&amp; rRelOrientation )
+	{
 		OdeTransformGeom* pTrans = new OdeTransformGeom( mOdeWorld-&gt;_getOdeSpace(), this );
 		pTrans-&gt;attachGeom( pGeom );
 
-		pTrans-&gt;setPosition( rOffset );
-		pTrans-&gt;setOrientation( rRelOrientation );
+		pGeom-&gt;setPosition( rOffset );
+		pGeom-&gt;setOrientation( rRelOrientation );
 
 		return pTrans;
-    }
+	}
 
-    //-----------------------------------------------------
-    OdeGeom* OdeActor::createShapeFromDesc( const IShape::Desc&amp; rShapeDesc )
-    {
-		IShape::Desc* pShapeDesc = &amp;const_cast&lt;IShape::Desc&amp;&gt;( rShapeDesc );
+	//-----------------------------------------------------
+	OdeGeom* OdeActor::createShapeFromDesc( const IShape::Desc&amp; rShapeDesc )
+	{
+		YAKE_LOG_INFORMATION( String( &quot;OdeActor | creating geom. Position &quot; ) &lt;&lt; rShapeDesc.position  );
+		const IShape::Desc* pShapeDesc = &amp;( rShapeDesc );
 
 		IMaterial* pMaterial = this-&gt;getCreator()-&gt;getMaterial( pShapeDesc-&gt;material );
 
 		if ( !pMaterial )
 			pMaterial = this-&gt;getCreator()-&gt;getMaterial( &quot;default&quot; );
 
-		OdeMaterial* pOdeMaterial = pMaterial ? dynamic_cast&lt;OdeMaterial*&gt;( pMaterial ) : 0;
+		OdeMaterial* pOdeMaterial = pMaterial ? checked_cast&lt;OdeMaterial*&gt;( pMaterial ) : 0;
 		YAKE_ASSERT( pOdeMaterial );
 
 		OdeGeom* result = 0;
 
-		if ( IShape::SphereDesc* pSphereDesc = dynamic_cast&lt;IShape::SphereDesc*&gt;( pShapeDesc ) )
+		if ( const IShape::SphereDesc* pSphereDesc = checked_cast&lt;const IShape::SphereDesc*&gt;( pShapeDesc ) )
 		{
 			OdeSphere* pSphere = new OdeSphere( mOdeWorld-&gt;_getOdeSpace(), this, pSphereDesc-&gt;radius );
 
-			result = createTransformGeomIfNeeded( pSphere, rShapeDesc.position, rShapeDesc.orientation );
+			result = createTransformGeom( pSphere, rShapeDesc.position, rShapeDesc.orientation );
 		}
-		else if ( IShape::BoxDesc* pBoxDesc = dynamic_cast&lt;IShape::BoxDesc*&gt;( pShapeDesc ) )
+		else if ( const IShape::BoxDesc* pBoxDesc = checked_cast&lt;const IShape::BoxDesc*&gt;( pShapeDesc ) )
 		{
 			OdeBox* pBox = new OdeBox( mOdeWorld-&gt;_getOdeSpace(), 
 				this,
 				pBoxDesc-&gt;dimensions.x, 
 				pBoxDesc-&gt;dimensions.y,
 				pBoxDesc-&gt;dimensions.z  );
-			result = createTransformGeomIfNeeded( pBox, rShapeDesc.position, rShapeDesc.orientation );
+			result = createTransformGeom( pBox, rShapeDesc.position, rShapeDesc.orientation );
 		}
-		else if ( IShape::PlaneDesc* pPlaneDesc = dynamic_cast&lt;IShape::PlaneDesc*&gt;( pShapeDesc ) )
+		else if ( const IShape::PlaneDesc* pPlaneDesc = checked_cast&lt;const IShape::PlaneDesc*&gt;( pShapeDesc ) )
 		{
 			/// We are not making transform geom here.
 			/// Calculating absolute coordinates instead...
-			Vector3 normal( pPlaneDesc-&gt;orientation*pPlaneDesc-&gt;normal );
+			math::Vector3 normal( pPlaneDesc-&gt;orientation*pPlaneDesc-&gt;normal );
 			normal.normalise();
 
 			real d = pPlaneDesc-&gt;d + normal.dotProduct( pPlaneDesc-&gt;position ); 
@@ -144,15 +142,15 @@
 				d );
 			result = pPlane;
 		}
-		else if ( IShape::CapsuleDesc* pCapsuleDesc = dynamic_cast&lt;IShape::CapsuleDesc*&gt;( pShapeDesc ) )
+		else if ( const IShape::CapsuleDesc* pCapsuleDesc = checked_cast&lt;const IShape::CapsuleDesc*&gt;( pShapeDesc ) )
 		{
 			OdeCCylinder* pCapsule = new OdeCCylinder( mOdeWorld-&gt;_getOdeSpace(), 
 				this,
 				pCapsuleDesc-&gt;radius,
 				pCapsuleDesc-&gt;height  );
-			result = createTransformGeomIfNeeded( pCapsule, rShapeDesc.position, rShapeDesc.orientation );
+			result = createTransformGeom( pCapsule, rShapeDesc.position, rShapeDesc.orientation );
 		}
-		else if ( IShape::TriMeshDesc* pTriMeshDesc = dynamic_cast&lt;IShape::TriMeshDesc*&gt;( pShapeDesc ) )
+		else if ( const IShape::TriMeshDesc* pTriMeshDesc = checked_cast&lt;const IShape::TriMeshDesc*&gt;( pShapeDesc ) )
 		{
 			TriangleMeshId id = pTriMeshDesc-&gt;trimeshId_;
 			if (id == kTriangleMeshIdNone)
@@ -166,7 +164,7 @@
 
 			YAKE_ASSERT( pMesh ).error( &quot;Mesh with such id wasn't found!&quot; );
 
-			result = createTransformGeomIfNeeded( pMesh, rShapeDesc.position, rShapeDesc.orientation );
+			result = createTransformGeom( pMesh, rShapeDesc.position, rShapeDesc.orientation );
 		}
 
 		YAKE_ASSERT( result != 0 ).error( &quot;Unsupported shape type!&quot; );
@@ -180,71 +178,71 @@
 		{
 			mShapes.push_back( SharedPtr&lt;OdeGeom&gt;(result) );
 			// plane is not a movable geom. Its position is determined on creation!
-		// if (result-&gt;getType() != ST_PLANE)
-		// {
-		//     result-&gt;setPosition( pShapeDesc-&gt;position );
-		//     result-&gt;setOrientation( pShapeDesc-&gt;orientation );
-		// }
+			// if (result-&gt;getType() != ST_PLANE)
+			// {
+			//     result-&gt;setPosition( pShapeDesc-&gt;position );
+			//     result-&gt;setOrientation( pShapeDesc-&gt;orientation );
+			// }
 		}
 
 		return result;
-    }
+	}
 
-    //-----------------------------------------------------
-    bool operator == (const SharedPtr&lt;OdeGeom&gt;&amp; lhs, const OdeGeom* rhs)
-    {
+	//-----------------------------------------------------
+	bool operator == (const SharedPtr&lt;OdeGeom&gt;&amp; lhs, const OdeGeom* rhs)
+	{
 		return (lhs.get() == rhs);
-    }
+	}
 
-    //-----------------------------------------------------
-    void OdeActor::destroyShape( IShape* pShape )
-    {
-		OdeGeom* pGeom = dynamic_cast&lt;OdeGeom*&gt;( pShape );
+	//-----------------------------------------------------
+	void OdeActor::destroyShape( IShape* pShape )
+	{
+		OdeGeom* pGeom = checked_cast&lt;OdeGeom*&gt;( pShape );
 		ShapeList::iterator victim = std::find( mShapes.begin(), mShapes.end(), pGeom );
 		mShapes.erase( victim );
-    }
+	}
 
-    //-----------------------------------------------------
-    IShapePtrList OdeActor::getShapes() const
-    {
+	//-----------------------------------------------------
+	IShapePtrList OdeActor::getShapes() const
+	{
 		IShapePtrList ret;
 		//ret.reserve( mShapes.size() );
 		//std::copy( mShapes.begin(), mShapes.end(), std::back_inserter( mShapes ) );
 		for (ShapeList::const_iterator it = mShapes.begin(); it != mShapes.end(); ++it)
-			ret.push_back( dynamic_cast&lt;IShape*&gt;(it-&gt;get()) );
+			ret.push_back( checked_cast&lt;IShape*&gt;(it-&gt;get()) );
 		return ret;
-    }
+	}
 
-    //-----------------------------------------------------
-    // 	void OdeActor::postStep( real timeElapsed )
-    // 	{
-    // 		Vector&lt; OdeActor* &gt; its;
-    // 		for (CollisionList::iterator it = mCollisions.begin(); it != mCollisions.end(); ++it)
-    // 		{
-    // 			CollisionInfo&amp; info = it-&gt;second;
-    // 			info.time += timeElapsed;
-    // 			if (info.time &gt;= 0.1)
-    // 			{
-    // 				mLeaveCollisionSignal( this, it-&gt;first );
-    // 				its.push_back( it-&gt;first );
-    // 			}
-    // 		}
-    // 		VectorIterator&lt; Vector&lt; OdeActor* &gt; &gt; itErase(
-    // 			its.begin(), its.end() );
-    // 		while (itErase.hasMoreElements())
-    // 		{
-    // 			CollisionList::iterator itFind = mCollisions.find( itErase.getNext() );
-    // 			if (itFind != mCollisions.end())
-    // 				mCollisions.erase( itFind );
-    // 		}
-    // 		its.clear();
-    // 	}
+	//-----------------------------------------------------
+	// 	void OdeActor::postStep( real timeElapsed )
+	// 	{
+	// 		Vector&lt; OdeActor* &gt; its;
+	// 		for (CollisionList::iterator it = mCollisions.begin(); it != mCollisions.end(); ++it)
+	// 		{
+	// 			CollisionInfo&amp; info = it-&gt;second;
+	// 			info.time += timeElapsed;
+	// 			if (info.time &gt;= 0.1)
+	// 			{
+	// 				mLeaveCollisionSignal( this, it-&gt;first );
+	// 				its.push_back( it-&gt;first );
+	// 			}
+	// 		}
+	// 		VectorIterator&lt; Vector&lt; OdeActor* &gt; &gt; itErase(
+	// 			its.begin(), its.end() );
+	// 		while (itErase.hasMoreElements())
+	// 		{
+	// 			CollisionList::iterator itFind = mCollisions.find( itErase.getNext() );
+	// 			if (itFind != mCollisions.end())
+	// 				mCollisions.erase( itFind );
+	// 		}
+	// 		its.clear();
+	// 	}
 
 //#define DEBUG_COLLISIONS
 
-    //-----------------------------------------------------
-    void OdeActor::_collide( OdeActor* pOther, dGeomID geomA, dGeomID geomB, dJointGroup* contactJointGroup )
-    {
+	//-----------------------------------------------------
+	void OdeActor::_collide( OdeActor* pOther, dGeomID geomA, dGeomID geomB, dJointGroup* contactJointGroup )
+	{
 		YAKE_ASSERT( pOther ).debug( &quot;Need the other object participating in the collision!&quot; );
 		YAKE_ASSERT( contactJointGroup ).error( &quot;Need a joint group for contact joints!&quot; );
 
@@ -254,53 +252,77 @@
 
 		OdeGeom* pShapeA = reinterpret_cast&lt;OdeGeom*&gt;( dGeomGetData( geomA ) );
 		OdeGeom* pShapeB = reinterpret_cast&lt;OdeGeom*&gt;( dGeomGetData( geomB ) );
+		YAKE_ASSERT( pShapeA != NULL &amp;&amp; pShapeB != NULL ).error( &quot;shapes are corrupt!&quot; );
 
 #ifdef DEBUG_COLLISIONS
-	YAKE_LOG( &quot;Actor collision function entered...&quot; );
+		YAKE_LOG( &quot;Actor collision function entered...&quot; );
 #endif 
 
-		const OdeMaterial&amp; rMatA = *pShapeA-&gt;getMaterial();
-		const OdeMaterial&amp; rMatB = *pShapeB-&gt;getMaterial();
-
 		dContact contact[ MAX_CONTACTS ];
 
 		// initiating collision detection
 		int numCollided = dCollide( geomA, geomB, MAX_CONTACTS, &amp;contact[0].geom, sizeof( dContact ) );
 		if (numCollided == 0)
+		{
+#ifdef DEBUG_COLLISIONS
+			YAKE_LOG( &quot;No collisions...&quot; );
+#endif
 			return;
+		}
 
-		//HACK FIXME implement collision cache!!!
-		// fire collision events
-		CollisionCache::iterator itFind = mCollisions.find( pOther );
-		if ( itFind == mCollisions.end() )
-		{
-			// new collision
-			CollisionInfo info = 0;
-			mCollisions.insert( CollisionCache::value_type( pOther, info ) );
+#ifdef DEBUG_COLLISIONS
+		YAKE_LOG( &quot;Firing collision signals&quot; );
+#endif 
+		// collisions are fired...
+		this-&gt;mEnterCollisionSignal( ActorCollisionInfo( this, pShapeA, pOther, pShapeB ) );
+		pOther-&gt;mEnterCollisionSignal( ActorCollisionInfo( this, pShapeA, pOther, pShapeB ) );
 
-			//mEnterCollisionSignal( this, pOther );
-		}
-		else
+		const OdeMaterial* pMatA = pShapeA-&gt;getMaterial();
+		const OdeMaterial* pMatB = pShapeB-&gt;getMaterial();
+
+		// if materials are not supposed to produce any contact forces
+		// This is the case if we just want some collision detection and without
+		// any contact joints...
+		if ( pMatA == NULL || pMatB == NULL )
 		{
-			// still colliding, so reset timeout
-			itFind-&gt;second = 0;
+#ifdef DEBUG_COLLISIONS
+			YAKE_LOG( &quot;collision detection without materials...&quot; );
+#endif
+			return;
 		}
 
+		//HACK FIXME implement collision cache!!!
+		// fire collision events
+		//CollisionCache::iterator itFind = mCollisions.find( pOther );
+		//	if ( itFind == mCollisions.end() )
+		//	{
+		//	    // new collision
+		//	    CollisionInfo info = 0;
+		//	    mCollisions.insert( CollisionCache::value_type( pOther, info ) );
+		//
+		//	    //mEnterCollisionSignal( this, pOther );
+		//	}
+		//	else
+		//	{
+		//	    // still colliding, so reset timeout
+		//	    itFind-&gt;second = 0;
+		//	}
+
 		// calculate soft cfm parameter[0..10^-6] from softness [0..1]
-		float softness = ( rMatA.mSoftness + rMatB.mSoftness ) / 1000000.0f;
+		float softness = ( pMatA-&gt;mSoftness + pMatB-&gt;mSoftness ) / 1000000.0f;
 
 #ifdef DEBUG_COLLISIONS
 		YAKE_LOG( String(&quot;Collision: softness was set to &quot;) &lt;&lt; softness );
 #endif
 
-	    // create contact joints
-	    for ( int i = 0; i &lt; numCollided; ++i )
-	    {
+		// create contact joints
+		for ( int i = 0; i &lt; numCollided; ++i )
+		{
 			contact[i].surface.mode =
-			    dContactSoftERP
-			    |dContactSoftCFM
-			    |dContactBounce
-			    |dContactApprox1;
+				dContactSoftERP
+				|dContactSoftCFM
+				|dContactBounce
+				|dContactApprox1;
 
 			// Setting contact softness...
 			if ( softness &gt; 0 )
@@ -313,15 +335,15 @@
 
 			// determine surface friction coefficients
 			// frictionCoefficient [0..1]
-			real frictionCoefficient = std::min( rMatA.mFriction, rMatB.mFriction );
+			real frictionCoefficient = std::min( pMatA-&gt;mFriction, pMatB-&gt;mFriction );
 
 #ifdef DEBUG_COLLISIONS
-		YAKE_LOG( String(&quot;Collision: frictionCoefficient was set to &quot;) &lt;&lt; frictionCoefficient );
+			YAKE_LOG( String(&quot;Collision: frictionCoefficient was set to &quot;) &lt;&lt; frictionCoefficient );
 #endif
 
 			contact[i].surface.mu = frictionCoefficient; 
 
-			float friction2 = std::min( rMatA.mFriction2, rMatB.mFriction2 ); 
+			float friction2 = std::min( pMatA-&gt;mFriction2, pMatB-&gt;mFriction2 ); 
 			if ( friction2 &gt; 0.f )
 			{
 				contact[i].surface.mode |= dContactMu2;
@@ -336,11 +358,11 @@
 			//FIXME soft erp parameter should be correct
 			contact[i].surface.soft_erp = 0.9; 
 
-			real restitution = std::max( rMatA.mRestitution, rMatB.mRestitution );
+			real restitution = std::max( pMatA-&gt;mRestitution, pMatB-&gt;mRestitution );
 			contact[i].surface.bounce = restitution; 
 
 #ifdef DEBUG_COLLISIONS
-		YAKE_LOG( String(&quot;Collision: restitution was set to &quot;) &lt;&lt; restitution );
+			YAKE_LOG( String(&quot;Collision: restitution was set to &quot;) &lt;&lt; restitution );
 #endif
 
 			//FIXME bounce velocity needs to be tuned
@@ -350,13 +372,13 @@
 				contactJointGroup-&gt;id(),
 				contact + i );
 			dJointAttach ( contactJointID, dGeomGetBody( geomA ), dGeomGetBody( geomB ) );
-	    } // for each contact
-    }
+		} // for each contact
+	}
 
-    //-----------------------------------------------------
-    IShape* OdeActor::createShape( const IShape::Desc&amp; rShapeDesc, real massOrDensity, IBody::quantityType type )
-    {
-		if ( mBody &amp;&amp; dynamic_cast&lt;const IShape::PlaneDesc*&gt;( &amp;rShapeDesc ) )
+	//-----------------------------------------------------
+	IShape* OdeActor::createShape( const IShape::Desc&amp; rShapeDesc, real massOrDensity, IBody::quantityType type )
+	{
+		if ( mBody &amp;&amp; checked_cast&lt;const IShape::PlaneDesc*&gt;( &amp;rShapeDesc ) )
 			YAKE_ASSERT( false ).error( &quot;Attempted to attach immovable plane shape to movable actor!&quot; );
 
 		OdeGeom* pShape = createShapeFromDesc( rShapeDesc );
@@ -369,16 +391,16 @@
 
 			if (massOrDensity)
 			{
-			mBody-&gt;_applyMassDescFromShapeDesc( rShapeDesc, massOrDensity, type );
+				mBody-&gt;_applyMassDescFromShapeDesc( rShapeDesc, massOrDensity, type );
 			}
 		}
 
 		return pShape;
-    }
+	}
 
-    //-----------------------------------------------------
-    void OdeActor::setPosition( const Vector3&amp; rPosition )
-    {
+	//-----------------------------------------------------
+	void OdeActor::setPosition( const math::Vector3&amp; rPosition )
+	{
 		mPosition = rPosition;
 		if (mBody)
 			mBody-&gt;setPosition( rPosition );
@@ -389,11 +411,11 @@
 				i-&gt;get()-&gt;setPosition( mPosition );
 			}
 		}
-    }
+	}
 
-    //-----------------------------------------------------
-    void OdeActor::setOrientation( const Quaternion&amp; rOrientation )
-    {
+	//-----------------------------------------------------
+	void OdeActor::setOrientation( const math::Quaternion&amp; rOrientation )
+	{
 		mOrientation = rOrientation;
 
 		if (mBody)
@@ -405,36 +427,39 @@
 				i-&gt;get()-&gt;setOrientation( mOrientation );
 			}
 		}
-    }
+	}
 
-    //-----------------------------------------------------
-    Vector3 OdeActor::getPosition() const
-    {
+	//-----------------------------------------------------
+	math::Vector3 OdeActor::getPosition() const
+	{
 		if (mBody)
 			return mBody-&gt;getPosition();
+
 		return mPosition;
-    }
+	}
 
-    //-----------------------------------------------------
-    Quaternion OdeActor::getOrientation() const
-    {
+	//-----------------------------------------------------
+	math::Quaternion OdeActor::getOrientation() const
+	{
 		if (mBody)
 			return mBody-&gt;getOrientation();
+
 		return mOrientation;
-    }
+	}
 
-    //-----------------------------------------------------
-    IBody&amp; OdeActor::getBody() const
-    {
+	//-----------------------------------------------------
+	IBody&amp; OdeActor::getBody() const
+	{
 		YAKE_ASSERT( mBody );
 		return *mBody;
-    }
+	}
 
-    //-----------------------------------------------------
-    IBody* OdeActor::getBodyPtr() const
-    {
+	//-----------------------------------------------------
+	IBody* OdeActor::getBodyPtr() const
+	{
 		return mBody;
-    }
+	}
 
-} // physics
+	} // physics
 } // yake
+

Modified: trunk/yake/src/yake/plugins/physicsODE/OdeBallJoint.cpp
===================================================================
--- trunk/yake/src/yake/plugins/physicsODE/OdeBallJoint.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/physicsODE/OdeBallJoint.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -55,7 +55,7 @@
 	}
 	
 	//-----------------------------------------------------
-	void OdeBallJoint::setAxis( size_t axisIndex, Vector3 const&amp; rAxis )
+	void OdeBallJoint::setAxis( size_t axisIndex, const math::Vector3&amp; rAxis )
 	{
 		YAKE_ASSERT( false ).error( &quot;Ball joint doesn't have any axes!&quot; );
 	}
@@ -79,7 +79,7 @@
 	}
 
 	//-----------------------------------------------------
-	void OdeBallJoint::setAnchor( size_t anchorIndex, Vector3 const&amp; rAnchor )
+	void OdeBallJoint::setAnchor( size_t anchorIndex, const math::Vector3&amp; rAnchor )
 	{
 		YAKE_ASSERT( anchorIndex &lt; 1 ).error( &quot;Ball joint has only one anchor! You are trying to set more...&quot; );
 		

Modified: trunk/yake/src/yake/plugins/physicsODE/OdeBody.cpp
===================================================================
--- trunk/yake/src/yake/plugins/physicsODE/OdeBody.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/physicsODE/OdeBody.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -51,11 +51,13 @@
 			mOdeBody-&gt;setForce( 0, 0, 0 );
 			mOdeBody-&gt;setLinearVel( 0, 0, 0 );
 			mOdeBody-&gt;setAngularVel( 0, 0, 0 );
+
 			dMassSetSphere( &amp;mMass, 1, 1 );
-			setMass( 1 );
-			setPosition( Vector3(0,0,0) );
-			setOrientation( Quaternion::kIdentity );
+			mOdeBody-&gt;setMass( &amp;mMass );
 
+			setPosition( math::Vector3(0,0,0) );
+			setOrientation( math::Quaternion::kIdentity );
+
 			mOdeWorld-&gt;_addBody( this );
 		}
 
@@ -76,7 +78,6 @@
  		void OdeBody::setMass( real mass )
 		{
  			dMassAdjust( &amp;mMass, mass );
- 			
 			mOdeBody-&gt;setMass( &amp;mMass );
 		}
 		
@@ -94,50 +95,61 @@
 		 */
 		void parseMassDesc( const IBody::MassDesc&amp; desc, dMass* mass )
 		{
-			if ( const IBody::SphereMassDesc* sphereMassDesc = dynamic_cast&lt;const IBody::SphereMassDesc*&gt;( &amp;desc ) )
+			if ( const IBody::SphereMassDesc* sphereMassDesc =
+				checked_cast&lt;const IBody::SphereMassDesc*&gt;( &amp;desc ) )
 			{
 				if ( sphereMassDesc-&gt;qType == IBody::QT_DENSITY )
 					dMassSetSphere( mass, sphereMassDesc-&gt;quantity, sphereMassDesc-&gt;radius );
 				else
 					dMassSetSphereTotal( mass, sphereMassDesc-&gt;quantity, sphereMassDesc-&gt;radius );
 			}
-			else if ( const IBody::BoxMassDesc* boxMassDesc = dynamic_cast&lt;const IBody::BoxMassDesc*&gt;( &amp;desc ) )
+			else if ( const IBody::BoxMassDesc* boxMassDesc = checked_cast&lt;const IBody::BoxMassDesc*&gt;( &amp;desc ) )
 			{
 				if ( boxMassDesc-&gt;qType == IBody::QT_DENSITY )
-					dMassSetBox( mass, boxMassDesc-&gt;quantity, boxMassDesc-&gt;sizeX, boxMassDesc-&gt;sizeY, boxMassDesc-&gt;sizeZ );
+					dMassSetBox( mass, boxMassDesc-&gt;quantity, 
+						boxMassDesc-&gt;sizeX, boxMassDesc-&gt;sizeY, boxMassDesc-&gt;sizeZ );
 				else
-					dMassSetBoxTotal( mass, boxMassDesc-&gt;quantity, boxMassDesc-&gt;sizeX, boxMassDesc-&gt;sizeY, boxMassDesc-&gt;sizeZ );
+					dMassSetBoxTotal( mass, boxMassDesc-&gt;quantity, 
+						boxMassDesc-&gt;sizeX, boxMassDesc-&gt;sizeY, boxMassDesc-&gt;sizeZ );
 			}
-			else if ( const IBody::CapsuleMassDesc* capsuleMassDesc = dynamic_cast&lt;const IBody::CapsuleMassDesc*&gt;( &amp;desc ) )
+			else if ( const IBody::CapsuleMassDesc* capsuleMassDesc = 
+				checked_cast&lt;const IBody::CapsuleMassDesc*&gt;( &amp;desc ) )
 			{
 				if ( capsuleMassDesc-&gt;qType == IBody::QT_DENSITY )
 					dMassSetCappedCylinder( mass,
-												capsuleMassDesc-&gt;quantity,
-												2, 							// along Y axis
-												capsuleMassDesc-&gt;radius,
-												capsuleMassDesc-&gt;length );
+						capsuleMassDesc-&gt;quantity,
+						2, 							// along Y axis
+						capsuleMassDesc-&gt;radius,
+						capsuleMassDesc-&gt;length );
 				else
-					dMassSetCappedCylinderTotal( mass,
-												capsuleMassDesc-&gt;quantity,
-												2, 							// along Y axis
-												capsuleMassDesc-&gt;radius,
-												capsuleMassDesc-&gt;length );
+				    dMassSetCappedCylinderTotal( mass,
+					    capsuleMassDesc-&gt;quantity,
+					    2, 							// along Y axis
+					    capsuleMassDesc-&gt;radius,
+					    capsuleMassDesc-&gt;length );
 			}
-			else if ( const IBody::CylinderMassDesc* cylMassDesc = dynamic_cast&lt;const IBody::CylinderMassDesc*&gt;( &amp;desc ) )
+			else if ( const IBody::CylinderMassDesc* cylMassDesc = 
+				checked_cast&lt;const IBody::CylinderMassDesc*&gt;( &amp;desc ) )
 			{
 				if ( cylMassDesc-&gt;qType == IBody::QT_DENSITY )
 					dMassSetCylinder( mass,
-										cylMassDesc-&gt;quantity,
-										2,							// along Y axis
-										cylMassDesc-&gt;radius,
-										cylMassDesc-&gt;length );
+						cylMassDesc-&gt;quantity,
+						2,							// along Y axis
+						cylMassDesc-&gt;radius,
+						cylMassDesc-&gt;length );
 				else
 					dMassSetCylinderTotal( mass,
-										cylMassDesc-&gt;quantity,
-										2,							// along Y axis
-										cylMassDesc-&gt;radius,
-										cylMassDesc-&gt;length );
+						cylMassDesc-&gt;quantity,
+						2,							// along Y axis
+						cylMassDesc-&gt;radius,
+						cylMassDesc-&gt;length );
 			}
+			else if ( const IBody::MassDesc* massDesc = 
+				checked_cast&lt;const IBody::MassDesc*&gt;( &amp;desc ) )
+			{
+			    // creating unit sphere
+			    dMassSetSphereTotal( mass, massDesc-&gt;quantity, 1 );
+			}
 			else
 			{
 				YAKE_ASSERT( 0 ).error( &quot;Unsupported/unknown mass description type!&quot; );
@@ -151,16 +163,16 @@
 		{
 			const IShape::Desc* pShapeDesc = &amp;( rShapeDesc );
 			
-			if ( const IShape::SphereDesc* pSphereDesc = dynamic_cast&lt;const IShape::SphereDesc*&gt;( pShapeDesc ) )
+			if ( const IShape::SphereDesc* pSphereDesc = checked_cast&lt;const IShape::SphereDesc*&gt;( pShapeDesc ) )
 			{
 				this-&gt;addMass( IBody::SphereMassDesc( pSphereDesc-&gt;radius, massOrDensity, pSphereDesc-&gt;position, qType ) );
 			}
-			else if ( const IShape::BoxDesc* pBoxDesc = dynamic_cast&lt;const IShape::BoxDesc*&gt;( pShapeDesc ) )
+			else if ( const IShape::BoxDesc* pBoxDesc = checked_cast&lt;const IShape::BoxDesc*&gt;( pShapeDesc ) )
 			{
 				this-&gt;addMass( IBody::BoxMassDesc( pBoxDesc-&gt;dimensions.x, pBoxDesc-&gt;dimensions.y, pBoxDesc-&gt;dimensions.z, massOrDensity,
 					pBoxDesc-&gt;position, qType ) );
 			}
-			else if ( const IShape::CapsuleDesc* pCapsuleDesc = dynamic_cast&lt;const IShape::CapsuleDesc*&gt;( pShapeDesc ) )
+			else if ( const IShape::CapsuleDesc* pCapsuleDesc = checked_cast&lt;const IShape::CapsuleDesc*&gt;( pShapeDesc ) )
 			{
 				this-&gt;addMass( IBody::CapsuleMassDesc( pCapsuleDesc-&gt;radius, pCapsuleDesc-&gt;height, massOrDensity, pCapsuleDesc-&gt;position, qType ) );
 			}
@@ -174,7 +186,6 @@
 		void OdeBody::setMass( const MassDesc&amp; rDesc )
 		{
 			parseMassDesc( rDesc, &amp;mMass );
-			
 			mOdeBody-&gt;setMass( &amp;mMass );
 		}
 		
@@ -195,7 +206,7 @@
 		void OdeBody::addForce( const Force&amp; force )
 		{
 			//@todo apply force over several time steps according to duration.
-			const Vector3 totalForce = force.force * force.duration;
+			const math::Vector3 totalForce = force.force * force.duration;
 			if (force.frameType == RF_GLOBAL)
 				mOdeBody-&gt;addForce( totalForce.x, totalForce.y, totalForce.z );
 			else
@@ -203,162 +214,113 @@
 		}
 
 		//---------------------------------------------------
-		void OdeBody::addForce( Vector3 const&amp; rForce )
+		void OdeBody::addForce( math::Vector3 const&amp; rForce )
 		{
 			mOdeBody-&gt;addForce( rForce.x, rForce.y, rForce.z );
 		}
 		
 		//---------------------------------------------------
-		void OdeBody::addForceAtPos( Vector3 const&amp; rForce, Vector3 const&amp; rPos )
+		void OdeBody::addForceAtPos( math::Vector3 const&amp; rForce, math::Vector3 const&amp; rPos )
 		{
 			mOdeBody-&gt;addForceAtPos( rForce.x, rForce.y, rForce.z, rPos.x, rPos.y, rPos.z );
 		}
 		
 		//---------------------------------------------------
-		void OdeBody::addForceAtLocalPos( Vector3 const&amp; rForce, Vector3 const&amp; rPos )
+		void OdeBody::addForceAtLocalPos( math::Vector3 const&amp; rForce, math::Vector3 const&amp; rPos )
 		{
 			mOdeBody-&gt;addForceAtRelPos( rForce.x, rForce.y, rForce.z, rPos.x, rPos.y, rPos.z );
 		}
 
 		//---------------------------------------------------
-		void OdeBody::addLocalForce( Vector3 const&amp; rForce )
+		void OdeBody::addLocalForce( math::Vector3 const&amp; rForce )
 		{
 			mOdeBody-&gt;addRelForce( rForce.x, rForce.y, rForce.z );
 		}
 		
 		//---------------------------------------------------
-		void OdeBody::addLocalForceAtLocalPos( Vector3 const&amp; rForce, Vector3 const&amp; rPos )
+		void OdeBody::addLocalForceAtLocalPos( math::Vector3 const&amp; rForce, math::Vector3 const&amp; rPos )
 		{
 			mOdeBody-&gt;addRelForceAtRelPos( rForce.x, rForce.y, rForce.z, rPos.x, rPos.y, rPos.z );
 		}
 		
 		//---------------------------------------------------
-		void OdeBody::addLocalForceAtPos( Vector3 const&amp; rForce, Vector3 const&amp; rPos )
+		void OdeBody::addLocalForceAtPos( math::Vector3 const&amp; rForce, math::Vector3 const&amp; rPos )
 		{
 			mOdeBody-&gt;addRelForceAtPos( rForce.x, rForce.y, rForce.z, rPos.x, rPos.y, rPos.z );
 		}
 		
 		//---------------------------------------------------
-		void OdeBody::addTorque( Vector3 const&amp; rTorque )
+		void OdeBody::addTorque( math::Vector3 const&amp; rTorque )
 		{
 			mOdeBody-&gt;addTorque( rTorque.x, rTorque.y, rTorque.z );
 		}
 		
 		//---------------------------------------------------
-		void OdeBody::addLocalTorque( Vector3 const&amp; rTorque )
+		void OdeBody::addLocalTorque( math::Vector3 const&amp; rTorque )
 		{
 			mOdeBody-&gt;addRelTorque( rTorque.x, rTorque.y, rTorque.z );
 		}
 		
 		//---------------------------------------------------
-		void OdeBody::setLinearVelocity( Vector3 const&amp; rVelocity )
+		void OdeBody::setLinearVelocity( math::Vector3 const&amp; rVelocity )
 		{
 			mOdeBody-&gt;setLinearVel( rVelocity.x, rVelocity.y, rVelocity.z );
 		}
 		
 		//---------------------------------------------------
-		Vector3 OdeBody::getLinearVelocity() const
+		math::Vector3 OdeBody::getLinearVelocity() const
 		{
 			const dReal* v = mOdeBody-&gt;getLinearVel();
-			return Vector3( real(v[0]), real(v[1]), real(v[2]) );
+			return math::Vector3( static_cast&lt;real&gt;(v[0]), static_cast&lt;real&gt;(v[1]), static_cast&lt;real&gt;(v[2]) );
 		}
 		
 		//---------------------------------------------------
-		void OdeBody::setAngularVelocity( Vector3 const&amp; rVelocity)
+		void OdeBody::setAngularVelocity( math::Vector3 const&amp; rVelocity)
 		{
 			mOdeBody-&gt;setAngularVel( rVelocity.x, rVelocity.y, rVelocity.z );
 		}
 		
 		//---------------------------------------------------
-		Vector3 OdeBody::getAngularVelocity() const
+		math::Vector3 OdeBody::getAngularVelocity() const
 		{
 			const dReal* v = mOdeBody-&gt;getAngularVel();
-			return Vector3( real(v[0]), real(v[1]), real(v[2]) );
+			return math::Vector3( static_cast&lt;real&gt;(v[0]), static_cast&lt;real&gt;(v[1]), static_cast&lt;real&gt;(v[2]) );
 		}
 
 		//---------------------------------------------------
-		void OdeBody::setPosition(  Vector3 const&amp; rPosition )
+		void OdeBody::setPosition( const math::Vector3&amp; rPosition )
 		{
 			mOdeBody-&gt;setPosition( rPosition.x, rPosition.y, rPosition.z );
 		}
 		
 		//---------------------------------------------------
-		Vector3 OdeBody::getPosition() const
+		math::Vector3 OdeBody::getPosition() const
 		{
 			const dReal* pos = mOdeBody-&gt;getPosition();
-			return Vector3( real(pos[0]), real(pos[1]), real(pos[2]) );
+
+			return math::Vector3( static_cast&lt;real&gt;(pos[0]), 
+				static_cast&lt;real&gt;(pos[1]), 
+				static_cast&lt;real&gt;(pos[2]) );
 		}
 		
 		//---------------------------------------------------
-		void OdeBody::setOrientation( Quaternion const&amp; rOrientation )
+		void OdeBody::setOrientation( const math::Quaternion&amp; rOrientation )
 		{
 			dQuaternion q = { rOrientation.w, rOrientation.x, rOrientation.y, rOrientation.z };
 			mOdeBody-&gt;setQuaternion( q );
 		}
 		
 		//---------------------------------------------------
-		Quaternion OdeBody::getOrientation() const
+		math::Quaternion OdeBody::getOrientation() const
 		{
 			const dReal* q = mOdeBody-&gt;getQuaternion();
-			return Quaternion( real(q[0]), real(q[1]), real(q[2]), real(q[3]) );
+
+			return math::Quaternion( static_cast&lt;real&gt;(q[0]), 
+				static_cast&lt;real&gt;(q[1]), 
+				static_cast&lt;real&gt;(q[2]), 
+				static_cast&lt;real&gt;(q[3]) );
 		}
 		
-		
-// 		//---------------------------------------------------
-// 		void OdeBody::translateMass( const Vector3 &amp; d )
-// 		{
-// 			dMassTranslate(&amp;mMass, d.x, d.y, d.z);
-// 		}
-// 
-// 		//-----------------------------------------------------
-// 		IBody::MassType OdeBody::getType() const
-// 		{
-// 			return mMassType;
-// 		}
-// 
-// 		//-----------------------------------------------------
-// 		void OdeBody::setMassBox(real lx, real ly, real lz, real density)
-// 		{
-// 			mMassType = MT_BOX;
-// 			dMassSetBox( &amp;mMass, density, lx, ly, lz );
-// 			YAKE_ASSERT( mOdeBody ).error(&quot;Need a body!&quot;);
-// 			mOdeBody-&gt;setMass( &amp;mMass );
-// 		}
-// 
-// 		//-----------------------------------------------------
-// 		void OdeBody::setMassSphere(real r, real density)
-// 		{
-// 			mMassType = MT_SPHERE;
-// 			dMassSetSphere( &amp;mMass, density, r );
-// 			YAKE_ASSERT( mOdeBody ).error(&quot;Need a body!&quot;);
-// 			mOdeBody-&gt;setMass( &amp;mMass );
-// 		}
-// 
-// 		//-----------------------------------------------------
-// 		Vector3 OdeBody::getTorque() const
-// 		{
-// 			YAKE_ASSERT( mOdeBody ).error(&quot;Need a body!&quot;);
-// 			const dReal * torque = mOdeBody-&gt;getTorque();
-// 			return Vector3(torque[0], torque[1], torque[2]);
-// 		}
-// 
-// 		//-----------------------------------------------------
-// 		void OdeBody::setEnabled( bool enabled )
-// 		{
-// 			YAKE_ASSERT( mOdeBody ).error(&quot;Need a body!&quot;);
-// 			if (enabled)
-// 				mOdeBody-&gt;enable();
-// 			else
-// 				mOdeBody-&gt;disable();
-// 		}
-// 
-// 		//-----------------------------------------------------
-// 		OdeWorld* OdeBody::_getWorld() const
-// 		{
-// 			YAKE_ASSERT( mWorld ).error(&quot;Need a world!&quot;);
-// 			return mWorld;
-// 		}
-// 
 		//-----------------------------------------------------
 		dBody* OdeBody::_getOdeBody() const
 		{
@@ -367,3 +329,4 @@
 
 } // physics
 } // yake
+

Modified: trunk/yake/src/yake/plugins/physicsODE/OdeFixedJoint.cpp
===================================================================
--- trunk/yake/src/yake/plugins/physicsODE/OdeFixedJoint.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/physicsODE/OdeFixedJoint.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -44,9 +44,9 @@
 	}
 
 	//-----------------------------------------------------
-	void OdeFixedJoint::attach( IBody&amp; rBody1, IBody&amp; rBody2 )
+	void OdeFixedJoint::attach( IBody* pBody1, IBody* pBody2 )
 	{
-		OdeJoint::attach( rBody1, rBody2 );
+		OdeJoint::attach( pBody1, pBody2 );
 		
 		dJointSetFixed( mOdeJoint-&gt;id() );
 	}
@@ -64,7 +64,7 @@
 	}
 	
 	//-----------------------------------------------------
-	void OdeFixedJoint::setAxis( size_t axisIndex, Vector3 const&amp; rAxis )
+	void OdeFixedJoint::setAxis( size_t axisIndex, const math::Vector3&amp; rAxis )
 	{
 		YAKE_ASSERT( false ).error( &quot;Fixed joint doesn't have any axes!&quot; );
 	}
@@ -76,7 +76,7 @@
 	}
 	
 	//-----------------------------------------------------
-	void OdeFixedJoint::setAnchor( size_t anchorIndex, Vector3 const&amp; rAnchor )
+	void OdeFixedJoint::setAnchor( size_t anchorIndex, const math::Vector3&amp; rAnchor )
 	{
 		YAKE_ASSERT( false ).error( &quot;Fixed joint doesn't have any anchors!&quot; );
 	}

Modified: trunk/yake/src/yake/plugins/physicsODE/OdeHinge2Joint.cpp
===================================================================
--- trunk/yake/src/yake/plugins/physicsODE/OdeHinge2Joint.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/physicsODE/OdeHinge2Joint.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -55,7 +55,7 @@
 	}
 	
 	//-----------------------------------------------------
-	void OdeHinge2Joint::setAxis( size_t axisIndex, Vector3 const&amp; rAxis )
+	void OdeHinge2Joint::setAxis( size_t axisIndex, const math::Vector3&amp; rAxis )
 	{
 		YAKE_ASSERT( axisIndex &lt; 2 ).error( &quot;Hinge2 joint has only two axes! You are trying to set more...&quot; );
 		
@@ -72,7 +72,7 @@
 	}
 	
 	//-----------------------------------------------------
-	void OdeHinge2Joint::setAnchor( size_t anchorIndex, Vector3 const&amp; rAnchor )
+	void OdeHinge2Joint::setAnchor( size_t anchorIndex, const math::Vector3&amp; rAnchor )
 	{
 		YAKE_ASSERT( anchorIndex &lt; 1 ).error( &quot;Hinge2 joint has only one anchor! You are trying to set more...&quot; );
 		

Modified: trunk/yake/src/yake/plugins/physicsODE/OdeHingeJoint.cpp
===================================================================
--- trunk/yake/src/yake/plugins/physicsODE/OdeHingeJoint.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/physicsODE/OdeHingeJoint.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -55,7 +55,7 @@
 	}
 	
 	//-----------------------------------------------------
-	void OdeHingeJoint::setAxis( size_t axisIndex, Vector3 const&amp; rAxis )
+	void OdeHingeJoint::setAxis( size_t axisIndex, const math::Vector3&amp; rAxis )
 	{
 		YAKE_ASSERT( axisIndex &lt; 1 ).error( &quot;Hinge joint has only one axis! You are trying to set more...&quot; );
 		
@@ -69,7 +69,7 @@
 	}
 	
 	//-----------------------------------------------------
-	void OdeHingeJoint::setAnchor( size_t anchorIndex, Vector3 const&amp; rAnchor )
+	void OdeHingeJoint::setAnchor( size_t anchorIndex, const math::Vector3&amp; rAnchor )
 	{
 		YAKE_ASSERT( anchorIndex &lt; 1 ).error( &quot;Hinge joint has only one anchor! You are trying to set more...&quot; );
 		

Modified: trunk/yake/src/yake/plugins/physicsODE/OdeJoint.cpp
===================================================================
--- trunk/yake/src/yake/plugins/physicsODE/OdeJoint.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/physicsODE/OdeJoint.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -51,11 +51,14 @@
 	}
 	
 	//-----------------------------------------------------
-	void OdeJoint::attach( IBody&amp; rBody1, IBody&amp; rBody2 )
+	void OdeJoint::attach( IBody* pBody1, IBody* pBody2 )
 	{
-		mOdeJoint-&gt;attach( 
-					( static_cast&lt;OdeBody&amp;&gt;( rBody1 ) )._getOdeBody()-&gt;id(),
-					( static_cast&lt;OdeBody&amp;&gt;( rBody2 ) )._getOdeBody()-&gt;id() );
+		YAKE_ASSERT( pBody1 != 0 || pBody2 != 0 ).error( &quot;both bodies are ZERO in joint attach function!&quot; );
+
+		dBodyID id0 = pBody1 != 0 ? static_cast&lt;OdeBody*&gt;( pBody1 )-&gt;_getOdeBody()-&gt;id() : 0; 
+		dBodyID id1 = pBody2 != 0 ? static_cast&lt;OdeBody*&gt;( pBody2 )-&gt;_getOdeBody()-&gt;id() : 0; 
+
+		mOdeJoint-&gt;attach( id0, id1 );
 	}
 
 	//-----------------------------------------------------
@@ -78,32 +81,6 @@
 	{
 	}
 	
-// 		//-----------------------------------------------------
-// 		void OdeJoint::setSpring(real spring)
-// 		{
-// 			mSpringConstant = spring;
-// 			_applySpring();
-// 		}
-// 
-// 		//-----------------------------------------------------
-// 		void OdeJoint::setDamping(real damping)
-// 		{
-// 			mDampingConstant = damping;
-// 			_applySpring();
-// 		}
-// 
-// 		//-----------------------------------------------------
-// 		real OdeJoint::getSpring() const
-// 		{
-// 			return mSpringConstant;
-// 		}
-// 
-// 		//-----------------------------------------------------
-// 		real OdeJoint::getDamping() const
-// 		{
-// 			return mDampingConstant;
-// 		}
-// 
 	//-----------------------------------------------------
 	real OdeJoint::_getCFMFromSpring() const
 	{
@@ -145,20 +122,28 @@
 			break;
 		}
 	}
+
+	//-----------------------------------------------------
 	void OdeJoint::setSpring(real spring)
 	{
 		mSpringConstant = spring;
 		_applySpring();
 	}
+
+	//-----------------------------------------------------
 	real OdeJoint::getSpring() const
 	{
 		return mSpringConstant;
 	}
+
+	//-----------------------------------------------------
 	void OdeJoint::setDamping(real damping)
 	{
 		mDampingConstant = damping;
 		_applySpring();
 	}
+
+	//-----------------------------------------------------
 	real OdeJoint::getDamping() const
 	{
 		return mDampingConstant;
@@ -166,3 +151,4 @@
 
 } // physics
 } // yake
+

Modified: trunk/yake/src/yake/plugins/physicsODE/OdeMaterial.cpp
===================================================================
--- trunk/yake/src/yake/plugins/physicsODE/OdeMaterial.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/physicsODE/OdeMaterial.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -36,7 +36,7 @@
 		mFriction(10),
 		mFriction2(5),
 		mLateralSlip(false),
-		mSlipNormal(Vector3::kZero),
+		mSlipNormal(math::Vector3::kZero),
 		mSlipLinearCoeff(0),
 		mSlipAngularCoeff(0),
 		mRestitution(0), // better value?
@@ -50,7 +50,7 @@
 		mFriction(desc.mFriction),
 		mFriction2(desc.mFriction),
 		mLateralSlip(false),
-		mSlipNormal(Vector3::kZero),
+		mSlipNormal(math::Vector3::kZero),
 		mSlipLinearCoeff(0),
 		mSlipAngularCoeff(0),
 		mRestitution( desc.mRestitution ),
@@ -96,3 +96,4 @@
 
 } // physics
 } // yake
+

Modified: trunk/yake/src/yake/plugins/physicsODE/OdeRay.cpp
===================================================================
--- trunk/yake/src/yake/plugins/physicsODE/OdeRay.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/physicsODE/OdeRay.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -30,6 +30,7 @@
 
 namespace yake {
 namespace physics {
+	using namespace yake::math;
 
 	//-----------------------------------------------------
 	OdeRay::OdeRay(OdeWorld* world, const real length) :
@@ -66,10 +67,10 @@
 		{
 			mIntersects = true;
 			mIntersectionDepth = real(contact.geom.depth);
-			mIntersectionPoint = Vector3( contact.geom.pos[0], contact.geom.pos[1], contact.geom.pos[2] );
+			mIntersectionPoint = Vector3( real(contact.geom.pos[0]), real(contact.geom.pos[1]), real(contact.geom.pos[2]) );
 			// As we have passed dCollide the ray as the first parameter, the normal
 			// is oriented correctly for ray deflection from the surface.
-			mIntersectionNormal = Vector3( contact.geom.normal[0], contact.geom.normal[1], contact.geom.normal[2] );
+			mIntersectionNormal = Vector3( real(contact.geom.normal[0]), real(contact.geom.normal[1]), real(contact.geom.normal[2]) );
 		}
 	}
 	real OdeRay::length() const
@@ -117,7 +118,7 @@
 		if (mRay)
 		{
 			const dReal* pos = mRay-&gt;getPosition();
-			mPosition = Vector3(pos[0],pos[1],pos[2]);
+			mPosition = Vector3(real(pos[0]),real(pos[1]),real(pos[2]));
 		}
 		return mPosition;
     }

Modified: trunk/yake/src/yake/plugins/physicsODE/OdeShapes.cpp
===================================================================
--- trunk/yake/src/yake/plugins/physicsODE/OdeShapes.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/physicsODE/OdeShapes.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -98,11 +98,12 @@
 	//-----------------------------------------------------
 	void OdeGeom::setMaterial( IMaterial* pMaterial )
 	{
-		mMaterial = static_cast&lt;OdeMaterial*&gt;( pMaterial );
+		mMaterial = checked_cast&lt;OdeMaterial*&gt;( pMaterial );
+		YAKE_ASSERT( mMaterial != NULL ).warning( &quot;assigned empty material&quot; );
 	}
 
 	//-----------------------------------------------------
-	void OdeGeom::setPosition( Vector3 const&amp; rPosition )
+	void OdeGeom::setPosition( math::Vector3 const&amp; rPosition )
 	{
 		if (getType() == ST_PLANE)
 			return;
@@ -111,49 +112,51 @@
 	}
 
 	//-----------------------------------------------------
-	Vector3 OdeGeom::getPosition() const
+	math::Vector3 OdeGeom::getPosition() const
 	{
 		if (getType() == ST_PLANE)
-			return Vector3::kZero;
+			return math::Vector3::kZero;
+
 		const dReal* pos = dGeomGetPosition( mOdeGeomID );
-		return Vector3( real(pos[0]), real(pos[1]), real(pos[2]) );
+		return math::Vector3( real(pos[0]), real(pos[1]), real(pos[2]) );
 	}
 
 	//-----------------------------------------------------
-	void OdeGeom::setOrientation( Quaternion const&amp; rOrientation )
+	void OdeGeom::setOrientation( math::Quaternion const&amp; rOrientation )
 	{
 		if (getType() == ST_PLANE)
 			return;
+
 		const dQuaternion q = { rOrientation.w, rOrientation.x, rOrientation.y, rOrientation.z };
 		dGeomSetQuaternion( mOdeGeomID, q );
 	}
 
 	//-----------------------------------------------------
-	Quaternion OdeGeom::getOrientation() const
+	math::Quaternion OdeGeom::getOrientation() const
 	{
 		if (getType() == ST_PLANE)
-			return Quaternion::kIdentity;
+			return math::Quaternion::kIdentity;
 
 		dQuaternion q;
 		dGeomGetQuaternion( mOdeGeomID, q );
 
-		return Quaternion( real(q[0]), real(q[1]), real(q[2]), real(q[3]) );
+		return math::Quaternion( real(q[0]), real(q[1]), real(q[2]), real(q[3]) );
 	}
 
 	//-----------------------------------------------------
-	Vector3 OdeGeom::getDerivedPosition() const
+	math::Vector3 OdeGeom::getDerivedPosition() const
 	{
-		dBodyID bodyId = dGeomGetBody( mOdeGeomID );
-		const dReal* pos = dBodyGetPosition( bodyId );
-		return Vector3( real(pos[0]), real(pos[1]), real(pos[2]) );
+		// return just usual geom position. 
+		// It is equal to body position if geom was attached to one
+		return getPosition();
 	}
 
 	//-----------------------------------------------------
-	Quaternion OdeGeom::getDerivedOrientation() const
+	math::Quaternion OdeGeom::getDerivedOrientation() const
 	{
-		dBodyID bodyId = dGeomGetBody( mOdeGeomID );
-		const dReal* q = dBodyGetQuaternion( bodyId );
-		return Quaternion( real(q[0]), real(q[1]), real(q[2]), real(q[3]) );
+		// return just usual geom orientation. 
+		// It is equal to body orientation if geom was attached to one
+		return getOrientation();
 	}
 
 	//-----------------------------------------------------
@@ -163,13 +166,13 @@
 	}
 
 	//-----------------------------------------------------
-	Vector3 OdeGeom::getPropertyVector3(const String&amp; id) const
+	math::Vector3 OdeGeom::getPropertyVector3(const String&amp; id) const
 	{
 		PropMap::const_iterator itFind = mProps.find( id );
 		YAKE_ASSERT(itFind != mProps.end());
 		if (itFind == mProps.end())
-			return Vector3();
-		return boost::any_cast&lt;Vector3&gt;(itFind-&gt;second);
+			return math::Vector3();
+		return boost::any_cast&lt;math::Vector3&gt;(itFind-&gt;second);
 	}
 
 	//-----------------------------------------------------
@@ -238,7 +241,7 @@
 		dReal* pCurrOrd = pVertices;
 		while (itV.hasMoreElements())
 		{
-			const Vector3&amp; v = *itV.peekNextPtr();
+			const math::Vector3&amp; v = *itV.peekNextPtr();
 			*pCurrOrd++ = v.x;
 			*pCurrOrd++ = v.y;
 			*pCurrOrd++ = v.z;
@@ -257,7 +260,7 @@
 			pCurrOrd = pNormals;
 			while (itN.hasMoreElements())
 			{
-				const Vector3&amp; n = *itN.peekNextPtr();
+				const math::Vector3&amp; n = *itN.peekNextPtr();
 				*pCurrOrd++ = n.x;
 				*pCurrOrd++ = n.y;
 				*pCurrOrd++ = n.z;
@@ -268,13 +271,35 @@
 		// serving up
 		dTriMeshDataID dataId = dGeomTriMeshDataCreate();
 
-		YAKE_ASSERT( sizeof(dReal) == sizeof(double) );
-
+#ifdef dDOUBLE
 		if ( !rNormals.empty() )
 		{
 			dGeomTriMeshDataBuildDouble1( dataId,
 				                            pVertices,
 				                            sizeof( dReal )*3,
+				                            int(rVertices.size()),
+				                            pIndices,
+				                            int(rIndices.size()),
+				                            sizeof( uint32 )*3,
+				                            pNormals );
+		}
+		else
+		{
+			dGeomTriMeshDataBuildDouble(  dataId,
+				                            pVertices,
+				                            sizeof( dReal )*3,
+				                            int(rVertices.size()),
+				                            pIndices,
+				                            int(rIndices.size()),
+				                            sizeof( uint32 )*3 );
+		}
+#endif
+#ifdef dSINGLE
+		if ( !rNormals.empty() )
+		{
+			dGeomTriMeshDataBuildSingle1( dataId,
+				                            pVertices,
+				                            sizeof( dReal )*3,
 				                            rVertices.size(),
 				                            pIndices,
 				                            rIndices.size(),
@@ -283,7 +308,7 @@
 		}
 		else
 		{
-			dGeomTriMeshDataBuildDouble(  dataId,
+			dGeomTriMeshDataBuildSingle(  dataId,
 				                            pVertices,
 				                            sizeof( dReal )*3,
 				                            rVertices.size(),
@@ -291,6 +316,7 @@
 				                            rIndices.size(),
 				                            sizeof( uint32 )*3 );
 		}
+#endif
 
 		dataToFill.normals = pNormals;
 		dataToFill.vertices = pVertices;
@@ -375,7 +401,7 @@
 
 		_setData( this );
 
-		mProps[&quot;dimensions&quot;] = Vector3(sizex,sizey,sizez);
+		mProps[&quot;dimensions&quot;] = math::Vector3(sizex,sizey,sizez);
 	}
 
 	//-----------------------------------------------------
@@ -398,10 +424,10 @@
 
 		YAKE_ASSERT( a != 0. || b != 0. || c != 0. ).error( &quot;Invalid plane equation!&quot; );
 
-		Vector3 normal = Vector3( a, b, c );
+		math::Vector3 normal = math::Vector3( a, b, c );
 
 		if ( normal.squaredLength() &lt; 0.02 )
-			normal = Vector3( 0, 1, 0 );
+			normal = math::Vector3( 0, 1, 0 );
 		else
 			normal.normalise();
 
@@ -411,7 +437,7 @@
 
 		_setData( this );
 
-		mProps[&quot;normal&quot;] = Vector3(a,b,c);
+		mProps[&quot;normal&quot;] = math::Vector3(a,b,c);
 		mProps[&quot;d&quot;] = d;
 	}
 
@@ -475,136 +501,75 @@
 	}
 
 	//-----------------------------------------------------
-	Vector3 OdeTransformGeom::getDerivedPosition() const
+	math::Vector3 OdeTransformGeom::getPosition() const
 	{
-		return (mAttachedGeom ?
-			(getPosition() + getDerivedOrientation() * mAttachedGeom-&gt;getPosition()) :
-			getPosition() );
+		return	mAttachedGeom ?	mAttachedGeom-&gt;getPosition() : OdeGeom::getPosition();
 	}
 
 	//-----------------------------------------------------
-	Quaternion OdeTransformGeom::getDerivedOrientation() const
+	math::Quaternion OdeTransformGeom::getOrientation() const
 	{
-		return (mAttachedGeom ?
-			mAttachedGeom-&gt;getDerivedOrientation() :
-			getOrientation() );
+		return mAttachedGeom ? mAttachedGeom-&gt;getOrientation() : OdeGeom::getOrientation();
 	}
 
 	//-----------------------------------------------------
-	void OdeTransformGeom::setPosition( Vector3 const&amp; rPosition )
+	void OdeTransformGeom::setPosition( const math::Vector3&amp; rPosition )
 	{
 		if (getType() == ST_PLANE)
+		{
+			YAKE_ASSERT( false ).warning( &quot;You are trying to set position for non-placeable geom!!&quot; );
 			return;
+		}
+		
 		YAKE_ASSERT( mAttachedGeom );
-		const dReal* pos = dGeomGetPosition( mOdeGeomID );
-		mAttachedGeom-&gt;setPosition( rPosition - Vector3(real(pos[0]), real(pos[1]), real(pos[2])) );
-		//dGeomSetPosition( mOdeGeomID, rPosition.x, rPosition.y, rPosition.z );
+		
+		mAttachedGeom-&gt;setPosition( rPosition );
 	}
 
 	//-----------------------------------------------------
-	Vector3 OdeTransformGeom::getPosition() const
+	math::Vector3 OdeTransformGeom::getDerivedPosition() const
 	{
 		if (getType() == ST_PLANE)
-			return Vector3::kZero;
+			return math::Vector3::kZero;
+
 		YAKE_ASSERT( mAttachedGeom );
 
-		const dReal* pos = dGeomGetPosition( mOdeGeomID );
-		dQuaternion q;
-		dGeomGetQuaternion( mOdeGeomID, q );
-		return Vector3( real(pos[0]), real(pos[1]), real(pos[2]) ) + 
-			Quaternion( real(q[0]), real(q[1]), real(q[2]), real(q[3]) ) * mAttachedGeom-&gt;getPosition();
+		math::Vector3 this_pos = OdeGeom::getPosition();
+		math::Quaternion this_orientation = OdeGeom::getOrientation();
+
+		return this_pos + this_orientation * mAttachedGeom-&gt;getPosition();
 	}
 
 	//-----------------------------------------------------
-	void OdeTransformGeom::setOrientation( Quaternion const&amp; rOrientation )
+	void OdeTransformGeom::setOrientation( const math::Quaternion&amp; rOrientation )
 	{
 		if (getType() == ST_PLANE)
+		{
+			YAKE_ASSERT( false ).warning( &quot;You are trying to set orientation for non-placeable geom!!&quot; );
 			return;
-		YAKE_ASSERT( mAttachedGeom );
-		const dQuaternion q = { rOrientation.w, rOrientation.x, rOrientation.y, rOrientation.z };
-		dGeomSetQuaternion( mOdeGeomID, q );
+		}
+
+		if ( mAttachedGeom != NULL )
+		    mAttachedGeom-&gt;setOrientation( rOrientation );
+		else
+		    OdeGeom::setOrientation( rOrientation );
 	}
 
 	//-----------------------------------------------------
-	Quaternion OdeTransformGeom::getOrientation() const
+	Quaternion OdeTransformGeom::getDerivedOrientation() const
 	{
 		if (getType() == ST_PLANE)
 			return Quaternion::kIdentity;
-		YAKE_ASSERT( mAttachedGeom );
-		dQuaternion q;
-		dGeomGetQuaternion( mOdeGeomID, q );
 
 		YAKE_ASSERT( mAttachedGeom );
 
-		return mAttachedGeom-&gt;getOrientation() * Quaternion( real(q[0]), real(q[1]), real(q[2]), real(q[3]) );
+		math::Quaternion this_orientation = OdeGeom::getOrientation();
+
+		Quaternion childOrientation = mAttachedGeom-&gt;getOrientation();
+		Quaternion result = this_orientation * childOrientation;
+		return  result;
 	}
 
-	// /*		//-----------------------------------------------------
-	// 		void OdeCollisionGeomBase::tfAttachGeom( ICollisionGeometry* pGeom )
-	// 		{ YAKE_ASSERT(1==0).error(&quot;not implemented&quot;); }
-	// 		//-----------------------------------------------------
-	// 		ICollisionGeometry* OdeCollisionGeomBase::tfGetAttachedGeom() const
-	// 		{ return 0; }
-	// 		//-----------------------------------------------------
-	// 		Vector3 OdeCollisionGeomBase::planeGetNormal() const
-	// 		{ return Vector3::kZero; }
-	// 		//-----------------------------------------------------
-	// 		String OdeCollisionGeomBase::meshGetName() const
-	// 		{ return &quot;&quot;; }
-	// 		//-----------------------------------------------------
-	// 		real OdeCollisionGeomBase::planeGetDistance() const
-	// 		{ return 0; }
-	// 		//-----------------------------------------------------
-	// 		real OdeCollisionGeomBase::sphereGetRadius() const
-	// 		{ return 0; }
-	// 		//-----------------------------------------------------
-	// 		void OdeCollisionGeomBase::sphereSetRadius(const real radius)
-	// 		{}
-	// 		//-----------------------------------------------------
-	// 		Vector3 OdeCollisionGeomBase::boxGetDimensions() const
-	// 		{ return Vector3::kZero; }
-	// 		//-----------------------------------------------------
-	// 		Vector3 OdeCollisionGeomBase::rayGetOrigin() const
-	// 		{ return Vector3::kZero; }
-	// 		//-----------------------------------------------------
-	// 		Quaternion OdeCollisionGeomBase::rayGetOrientation() const
-	// 		{ return Quaternion::kIdentity; }
-	//
-	// 		//-----------------------------------------------------
-	// 		real OdeCollisionGeomSphere::sphereGetRadius() const
-	// 		{
-	// 			return static_cast&lt;dSphere*&gt;(mOdeGeom)-&gt;getRadius();
-	// 		}
-	//
-	// 		//-----------------------------------------------------
-	// 		void OdeCollisionGeomSphere::sphereSetRadius(const real radius)
-	// 		{
-	// 			static_cast&lt;dSphere*&gt;(mOdeGeom)-&gt;setRadius(radius);
-	// 		}
-	//
-	// 		//-----------------------------------------------------
-	// 		Vector3 OdeCollisionGeomBox::boxGetDimensions() const
-	// 		{
-	// 			dVector3 lengths;
-	// 			static_cast&lt;dBox*&gt;(mOdeGeom)-&gt;getLengths(lengths);
-	// 			return Vector3( lengths[0], lengths[1], lengths[2] );
-	// 		}
-	//
-	//
-	// 		//-----------------------------------------------------
-	// 		Vector3 OdeCollisionGeomPlane::planeGetNormal() const
-	// 		{
-	// 			dVector4 params;
-	// 			static_cast&lt;dPlane*&gt;(mOdeGeom)-&gt;getParams(params);
-	// 			return Vector3( params[0], params[1], params[2] );
-	// 		}
-	// 		//-----------------------------------------------------
-	// 		real OdeCollisionGeomPlane::planeGetDistance() const
-	// 		{
-	// 			dVector4 params;
-	// 			static_cast&lt;dPlane*&gt;(mOdeGeom)-&gt;getParams(params);
-	// 			return params[3];
-	// 		}
-
 } // physics
 } // yake
+

Modified: trunk/yake/src/yake/plugins/physicsODE/OdeSliderJoint.cpp
===================================================================
--- trunk/yake/src/yake/plugins/physicsODE/OdeSliderJoint.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/physicsODE/OdeSliderJoint.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -55,7 +55,7 @@
 	}
 	
 	//-----------------------------------------------------
-	void OdeSliderJoint::setAxis( size_t axisIndex, Vector3 const&amp; rAxis )
+	void OdeSliderJoint::setAxis( size_t axisIndex, const math::Vector3&amp; rAxis )
 	{
 		YAKE_ASSERT( axisIndex &lt; 1 ).error( &quot;Slider joint has only one axis! You are trying to set more...&quot; );
 		
@@ -69,7 +69,7 @@
 	}
 	
 	//-----------------------------------------------------
-	void OdeSliderJoint::setAnchor( size_t anchorIndex, Vector3 const&amp; rAnchor )
+	void OdeSliderJoint::setAnchor( size_t anchorIndex, const math::Vector3&amp; rAnchor )
 	{
 		YAKE_ASSERT( false ).error( &quot;Slider joint doesn't have any anchors!&quot; );
 	}

Modified: trunk/yake/src/yake/plugins/physicsODE/OdeUniversalJoint.cpp
===================================================================
--- trunk/yake/src/yake/plugins/physicsODE/OdeUniversalJoint.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/physicsODE/OdeUniversalJoint.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -55,7 +55,7 @@
 	}
 	
 	//-----------------------------------------------------
-	void OdeUniversalJoint::setAxis( size_t axisIndex, Vector3 const&amp; rAxis )
+	void OdeUniversalJoint::setAxis( size_t axisIndex, math::Vector3 const&amp; rAxis )
 	{
 		YAKE_ASSERT( axisIndex &lt; 2 ).error( &quot;Universal joint has only two axes! You are trying to set more...&quot; );
 		
@@ -72,7 +72,7 @@
 	}
 	
 	//-----------------------------------------------------
-	void OdeUniversalJoint::setAnchor( size_t anchorIndex, Vector3 const&amp; rAnchor )
+	void OdeUniversalJoint::setAnchor( size_t anchorIndex, math::Vector3 const&amp; rAnchor )
 	{
 		YAKE_ASSERT( anchorIndex &lt; 1 ).error( &quot;Universal joint has only one anchor! You are trying to set more...&quot; );
 		
@@ -141,3 +141,4 @@
 
 } // physics
 } // yake
+

Modified: trunk/yake/src/yake/plugins/physicsODE/OdeWorld.cpp
===================================================================
--- trunk/yake/src/yake/plugins/physicsODE/OdeWorld.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/plugins/physicsODE/OdeWorld.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -57,7 +57,9 @@
 		mOdeWorld-&gt;setAutoDisableSteps( 30 ); // ODE default: 10
 		mOdeWorld-&gt;setAutoDisableTime( 0 ); // ODE default: 0. (= ignore time)
 
-		mOdeWorld-&gt;setGravity( 0., -9.81, 0. );
+		// We do not set any default gravity setting
+		// as we don't want to enforce a specific coordinate system.
+		//	mOdeWorld-&gt;setGravity( 0., -9.81, 0. );
 		mOdeWorld-&gt;setCFM( 0.0005 );
 		mOdeWorld-&gt;setERP( 0.99 );
 
@@ -97,19 +99,19 @@
  	}
 		
 	//-----------------------------------------------------
-	void OdeWorld::setGlobalGravity( const Vector3&amp; g )
+	void OdeWorld::setGlobalGravity( const math::Vector3&amp; g )
 	{
 		YAKE_ASSERT( mOdeWorld );
 		mOdeWorld-&gt;setGravity( g.x, g.y, g.z );
 	}
 
 	//-----------------------------------------------------
-	Vector3 OdeWorld::getGlobalGravity() const
+	math::Vector3 OdeWorld::getGlobalGravity() const
 	{
 		YAKE_ASSERT( mOdeWorld );
 		dVector3 g;
 		mOdeWorld-&gt;getGravity( g );
-		return Vector3(real(g[0]), real(g[1]), real(g[2]));
+		return math::Vector3(real(g[0]), real(g[1]), real(g[2]));
 	}
 
 	//-----------------------------------------------------
@@ -126,7 +128,7 @@
 	void OdeWorld::destroyMaterial( IMaterialPtr pMaterial )
 	{
 		YAKE_ASSERT( pMaterial );
-		mMaterials.erase( mMaterials.find( dynamic_cast&lt;OdeMaterial*&gt;(pMaterial)-&gt;mName ) );
+		mMaterials.erase( mMaterials.find( checked_cast&lt;OdeMaterial*&gt;(pMaterial)-&gt;mName ) );
 	}
 
 	//-----------------------------------------------------
@@ -196,16 +198,14 @@
 	}
 
 	//-----------------------------------------------------
-	IJointPtr OdeWorld::createJoint( IJoint::DescBase const&amp; rJointDesc )
+	IJointPtr OdeWorld::createJoint( const IJoint::DescBase&amp; rJointDesc )
 	{
-		//@todo add joints &quot;actor vs static env&quot;
-		YAKE_ASSERT( rJointDesc.actor0 &amp;&amp; rJointDesc.actor1 );
-		if (!rJointDesc.actor0 || !rJointDesc.actor1)
-			return 0;
+		YAKE_ASSERT( rJointDesc.actor0 != NULL || rJointDesc.actor1 != NULL ).error( &quot;both actors are 0!&quot; );
 
 		/// Bodies to attach
-		IBody&amp; rBody1 = rJointDesc.actor0-&gt;getBody();
-		IBody&amp; rBody2 = rJointDesc.actor1-&gt;getBody();
+		// if 0, then it is attachment to static environment
+		IBody* pBody1 = rJointDesc.actor0 ? rJointDesc.actor0-&gt;getBodyPtr() : 0;
+		IBody* pBody2 = rJointDesc.actor1 ? rJointDesc.actor1-&gt;getBodyPtr() : 0;
 		
 		/// Joint to return
 		OdeJoint* pJoint = 0;
@@ -215,14 +215,14 @@
 		case JT_FIXED:
 			{
 			pJoint = new OdeFixedJoint( this );
-			pJoint-&gt;attach( rBody1, rBody2 );
+			pJoint-&gt;attach( pBody1, pBody2 );
 			}
 			break;
 		case JT_HINGE:
 			{
 			pJoint = new OdeHingeJoint( this );
 			const IJoint::DescHinge&amp; desc = static_cast&lt;const IJoint::DescHinge&amp;&gt;( rJointDesc );
-			pJoint-&gt;attach( rBody1, rBody2 );
+			pJoint-&gt;attach( pBody1, pBody2 );
 			pJoint-&gt;setAnchor( 0, desc.anchor );
 			pJoint-&gt;setAxis( 0, desc.axis );
 			}
@@ -231,7 +231,7 @@
 			{
 			pJoint = new OdeHinge2Joint( this );
 			const IJoint::DescHinge2&amp; desc = static_cast&lt;const IJoint::DescHinge2&amp;&gt;( rJointDesc );
-			pJoint-&gt;attach( rBody1, rBody2 );
+			pJoint-&gt;attach( pBody1, pBody2 );
 			pJoint-&gt;setAnchor( 0, desc.anchor );
 			pJoint-&gt;setAxis( 0, desc.axis0 );
 			pJoint-&gt;setAxis( 1, desc.axis1 );
@@ -241,7 +241,7 @@
 			{
 			pJoint = new OdeUniversalJoint( this );
 			const IJoint::DescUniversal&amp; desc = static_cast&lt;const IJoint::DescUniversal&amp;&gt;( rJointDesc );
-			pJoint-&gt;attach( rBody1, rBody2 );
+			pJoint-&gt;attach( pBody1, pBody2 );
 			pJoint-&gt;setAnchor( 0, desc.anchor );
 			pJoint-&gt;setAxis( 0, desc.axis0 );
 			pJoint-&gt;setAxis( 1, desc.axis1 );
@@ -251,7 +251,7 @@
 			{
 			pJoint = new OdeBallJoint( this );
 			const IJoint::DescBall&amp; desc = static_cast&lt;const IJoint::DescBall&amp;&gt;( rJointDesc );
-			pJoint-&gt;attach( rBody1, rBody2 );
+			pJoint-&gt;attach( pBody1, pBody2 );
 			pJoint-&gt;setAnchor( 0, desc.anchor );
 			}
 			break;
@@ -259,7 +259,7 @@
 			{
 			pJoint = new OdeSliderJoint( this );
 			const IJoint::DescSlider&amp; desc = static_cast&lt;const IJoint::DescSlider&amp;&gt;( rJointDesc );
-			pJoint-&gt;attach( rBody1, rBody2 );
+			pJoint-&gt;attach( pBody1, pBody2 );
 			pJoint-&gt;setAxis( 0, desc.axis );
 			}
 			break;
@@ -305,7 +305,7 @@
 		mActors.push_back( SharedPtr&lt;OdeActor&gt;( pActor ) );
 		return pActor;
 	}
-	//-----------------------------------------------------
+	//----------------------------------------------------
 	bool operator==(const SharedPtr&lt;OdeJoint&gt;&amp; lhs, const OdeJoint* rhs)
 	{
 		return (lhs.get() == rhs);
@@ -314,7 +314,7 @@
 	void OdeWorld::destroyJoint( IJointPtr pJoint )
 	{
 		YAKE_ASSERT( pJoint );
-		mJoints.erase( std::find(mJoints.begin(), mJoints.end(), dynamic_cast&lt;OdeJoint*&gt;(pJoint) ) );
+		mJoints.erase( std::find(mJoints.begin(), mJoints.end(), checked_cast&lt;OdeJoint*&gt;(pJoint) ) );
 	}
 	//-----------------------------------------------------
 	bool operator==(const SharedPtr&lt;OdeActor&gt;&amp; lhs, const OdeActor* rhs)
@@ -325,14 +325,12 @@
 	void OdeWorld::destroyActor( IActorPtr pActor )
 	{
 		YAKE_ASSERT( pActor );
-		mActors.erase( std::find(mActors.begin(), mActors.end(), dynamic_cast&lt;OdeActor*&gt;(pActor) ) );
+		mActors.erase( std::find(mActors.begin(), mActors.end(), checked_cast&lt;OdeActor*&gt;(pActor) ) );
 	}
 	//-----------------------------------------------------
 	void OdeWorld::destroyAvatar( IAvatarPtr pAvatar )
 	{
 		YAKE_ASSERT( 0 &amp;&amp; &quot;NOT IMPLEMENTED&quot; );
-		//YAKE_ASSERT( !pAvatar.expired() );
-		//mAvatars.erase( std::find(mAvatars.begin(), mAvatars.end(), dynamic_cast&lt;OdeAvatar*&gt;(pAvatar .lock().get()) ) );
 	}
 
 	//-----------------------------------------------------

Modified: trunk/yake/src/yake/samples/base/debug/yakeUnitTest.cpp
===================================================================
--- trunk/yake/src/yake/samples/base/debug/yakeUnitTest.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/samples/base/debug/yakeUnitTest.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -80,4 +80,5 @@
 #endif
 
 	return 0;
-}
\ No newline at end of file
+}
+

Modified: trunk/yake/src/yake/thread/yakeThread.cpp
===================================================================
--- trunk/yake/src/yake/thread/yakeThread.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yake/thread/yakeThread.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -49,4 +49,5 @@
 #endif
 
 }
-}
\ No newline at end of file
+}
+

Modified: trunk/yake/src/yapp/Makefile.am
===================================================================
--- trunk/yake/src/yapp/Makefile.am	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/Makefile.am	2006-03-19 17:54:00 UTC (rev 1302)
@@ -1,4 +1,3 @@
 INCLUDES = $(all_includes)
 METASOURCES = AUTO
-SUBDIRS = base loader model statemachine gui msg ent vehicle raf plugins \
-	samples
+SUBDIRS = base loader model gui msg vehicle raf plugins samples

Modified: trunk/yake/src/yapp/base/event/Makefile.am
===================================================================
--- trunk/yake/src/yapp/base/event/Makefile.am	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/base/event/Makefile.am	2006-03-19 17:54:00 UTC (rev 1302)
@@ -1,7 +1,7 @@
 INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/dependencies/ttl $(all_includes)
 METASOURCES = AUTO
 lib_LTLIBRARIES = libyappEvents.la
-libyappEvents_la_SOURCES = yakeMessageId.cpp yakeMessageInstance.cpp\
-	yakeMessageManager.cpp yakeMessageQ.cpp yakeParamHolder.cpp
+libyappEvents_la_SOURCES = yakeMessageId.cpp yakeMessageInstance.cpp \
+	yakeMessageManager.cpp yakeMessageQ.cpp
 
 AM_CXXFLAGS = -rdynamic

Modified: trunk/yake/src/yapp/loader/yakeDotLinkLoader.cpp
===================================================================
--- trunk/yake/src/yapp/loader/yakeDotLinkLoader.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/loader/yakeDotLinkLoader.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -85,7 +85,7 @@
 			return;
 
 		using namespace data::dom;
-		using namespace base::templates;
+		using namespace yake::templates;
 
 		const String linkType = StringUtil::toLowerCase( rLinkNode.getAttributeValueAs&lt;String&gt;(&quot;type&quot;) );
 		//const String linkName = varGet&lt;String&gt;( rLinkNode.getId(&quot;id&quot;) );

Modified: trunk/yake/src/yapp/loader/yakeDotScene.cpp
===================================================================
--- trunk/yake/src/yapp/loader/yakeDotScene.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/loader/yakeDotScene.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -200,7 +200,7 @@
 	}
 	
 	//------------------------------------------------------
-	void DotSceneParser::readVector( const SharedPtr&lt;dom::INode&gt;&amp; pNode, Vector3&amp; rVec )
+	void DotSceneParser::readVector( const SharedPtr&lt;dom::INode&gt;&amp; pNode, math::Vector3&amp; rVec )
 	{
 		YAKE_ASSERT( pNode );
 		rVec.x = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;(&quot;x&quot;) );
@@ -209,19 +209,19 @@
 	}
 
 	//------------------------------------------------------
-	void DotSceneParser::readPosition( const SharedPtr&lt;dom::INode&gt; &amp; pNode, Vector3 &amp; position )
+	void DotSceneParser::readPosition( const SharedPtr&lt;dom::INode&gt; &amp; pNode, math::Vector3 &amp; position )
 	{
 		readVector( pNode, position );
 	}
 
 	//------------------------------------------------------
-	void DotSceneParser::readScale( const SharedPtr&lt;dom::INode&gt;&amp; pNode, Vector3&amp; rScale )
+	void DotSceneParser::readScale( const SharedPtr&lt;dom::INode&gt;&amp; pNode, math::Vector3&amp; rScale )
 	{
 		readVector( pNode, rScale );
 	}
 	
 	//------------------------------------------------------
-	void DotSceneParser::readRotation( const SharedPtr&lt;dom::INode&gt;&amp; pNode, Quaternion&amp; rotation )
+	void DotSceneParser::readRotation( const SharedPtr&lt;dom::INode&gt;&amp; pNode, math::Quaternion&amp; rotation )
 	{
 		YAKE_ASSERT( pNode );
 		if ( pNode-&gt;getAttributeValueAs&lt;String&gt;(&quot;qx&quot;) != &quot;&quot; )
@@ -233,7 +233,7 @@
 		}
 		else if ( pNode-&gt;getAttributeValueAs&lt;String&gt;(&quot;axisX&quot;) != &quot;&quot; )
 		{
-			Vector3 axis;
+			math::Vector3 axis;
 			axis.x = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;(&quot;axisX&quot;) );
 			axis.y = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;(&quot;axisY&quot;) );
 			axis.z = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;(&quot;axisZ&quot;) );
@@ -241,7 +241,7 @@
 		}
 		else if ( pNode-&gt;getAttributeValueAs&lt;String&gt;(&quot;angleX&quot;) != &quot;&quot; )
 		{
-			Vector3 axis;
+			math::Vector3 axis;
 			axis.x = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;(&quot;angleX&quot;) );
 			axis.y = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;(&quot;angleY&quot;) );
 			axis.z = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;(&quot;angleZ&quot;) );
@@ -250,7 +250,7 @@
 		}
 	}
 	//------------------------------------------------------
-	void DotSceneParser::readColour( const SharedPtr&lt;dom::INode&gt;&amp; pNode, Color&amp; colour )
+	void DotSceneParser::readColour( const SharedPtr&lt;dom::INode&gt;&amp; pNode, math::Color&amp; colour )
 	{
 		YAKE_ASSERT( pNode );
 		

Modified: trunk/yake/src/yapp/loader/yakeModelMovableLinkCreator.cpp
===================================================================
--- trunk/yake/src/yapp/loader/yakeModelMovableLinkCreator.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/loader/yakeModelMovableLinkCreator.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -34,7 +34,7 @@
 
 	YAKE_REGISTER_CONCRETE( ModelMovableLinkCreator );
 
-	Movable* getMovableFromModel(	complex::Model &amp; rModel, const data::dom::INode&amp; rNode )
+	Movable* getMovableFromModel( complex::Model&amp; rModel, const data::dom::INode&amp; rNode )
 	{
 		// parse
 		String sourceType = StringUtil::toLowerCase(rNode.getAttributeValueAs&lt;String&gt;(&quot;type&quot;));
@@ -42,45 +42,49 @@
 		String sourceMovableType = StringUtil::toLowerCase(rNode.getAttributeValueAs&lt;String&gt;(&quot;elementtype&quot;));
 		String sourceMovableName = (rNode.getAttributeValueAs&lt;String&gt;(&quot;element&quot;));
 		
-		std::cout &lt;&lt; &quot;Searching movable: &quot; &lt;&lt; std::endl; 
-		std::cout &lt;&lt; &quot;    type: &quot; &lt;&lt; sourceType &lt;&lt; std::endl; 
-		std::cout &lt;&lt; &quot;    submodel: &quot; &lt;&lt; sourceModelName &lt;&lt; std::endl; 
-		std::cout &lt;&lt; &quot;    movable type: &quot; &lt;&lt; sourceMovableType &lt;&lt; std::endl; 
-		std::cout &lt;&lt; &quot;    movable name: &quot; &lt;&lt; sourceMovableName &lt;&lt; std::endl; 
+		YAKE_LOG( &quot;Searching movable: &quot; ); 
+		YAKE_LOG( &quot;    type: &quot; + sourceType );
+		YAKE_LOG( &quot;    submodel: &quot; + sourceModelName );
+		YAKE_LOG( &quot;    movable type: &quot; + sourceMovableType );
+		YAKE_LOG( &quot;    movable name: &quot; + sourceMovableName );
 		
 		// retrieve source movable
 		Movable* pMovable = 0;
-		if (sourceType == &quot;graphical&quot;)
+		if ( sourceType == &quot;graphical&quot; )
 		{
 			YAKE_ASSERT( sourceMovableType == &quot;graphics.scenenode&quot; );
-			std::cout &lt;&lt; &quot;Searching for graphical named '&quot; &lt;&lt; sourceModelName &lt;&lt; &quot;'&quot; &lt;&lt; std::endl;
+			YAKE_LOG( &quot;Searching for graphical named '&quot; + sourceModelName + &quot;'&quot; );
+
 			Graphical* pG = rModel.getGraphicalByName( sourceModelName );
 			YAKE_ASSERT( pG );
+
 			pMovable = pG-&gt;getSceneNode( sourceMovableName, true );
 		}
-		else if (sourceType == &quot;physical&quot;)
+		else if ( sourceType == &quot;physical&quot; )
 		{
-			std::cout &lt;&lt; &quot;Searching for physical named '&quot; &lt;&lt; sourceModelName &lt;&lt; &quot;'&quot; &lt;&lt; std::endl;
+			YAKE_LOG( &quot;Searching for physical named '&quot; + sourceModelName + &quot;'&quot; );
+
 			Physical* pP = rModel.getPhysicalByName( sourceModelName );
 			YAKE_ASSERT( pP );
+
 			if (sourceMovableType == &quot;physics.actor&quot; || sourceMovableType == &quot;physics.complex&quot;)
 				pMovable = pP-&gt;getActorByName( sourceMovableName );
-			//else if (sourceMovableType == &quot;physics.complex&quot;)
-			//	pMovable = pP-&gt;getActorByName( sourceMovableName ).get();
 		}
-		YAKE_ASSERT( pMovable );
+
+		YAKE_ASSERT( pMovable != NULL ).error( &quot;Couldn't find movable '&quot; + sourceMovableName + &quot;'. Bailing out.&quot; );
 		return pMovable;
 	}
 
-	ModelLink* ModelMovableLinkCreator::createLink(	complex::Model &amp; rModel, 
+	ModelLink* ModelMovableLinkCreator::createLink(	complex::Model&amp; rModel, 
 							const data::dom::INode&amp; rSourceNode,
 							const data::dom::INode&amp; rTargetNode )
 	{
-		using namespace ::yake::data::dom;
+		using namespace yake::data::dom;
 
 		// retrieve source movable
 		Movable* pSourceMovable = getMovableFromModel( rModel, rSourceNode );
 		YAKE_ASSERT( pSourceMovable );
+
 		if (!pSourceMovable)
 			return 0;
 
@@ -93,10 +97,13 @@
 		// link them up
 		ModelMovableLink* pLink = new ModelMovableLink();
 		YAKE_ASSERT( pLink );
+
 		pLink-&gt;setSource( pSourceMovable );
 		pLink-&gt;subscribeToPositionChanged( pTargetMovable );
 		pLink-&gt;subscribeToOrientationChanged( pTargetMovable );
+
 		return pLink;
 	}
 }
 }
+

Modified: trunk/yake/src/yapp/loader/yakeXODEParser.cpp
===================================================================
--- trunk/yake/src/yapp/loader/yakeXODEParser.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/loader/yakeXODEParser.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -24,7 +24,6 @@
 	 source code distribution.
 	 ------------------------------------------------------------------------------------
 */
-
 #include &lt;yapp/base/yappPCH.h&gt;
 #include &lt;yapp/base/yapp.h&gt;
 #include &lt;yapp/loader/yakeXODEParser.h&gt;
@@ -79,1046 +78,1095 @@
 
 		// parse completed. Firing signal!
 		sigParseEnded_();
-	}
+    }
 
-	//------------------------------------------------------
-	void XODEParser::readWorld( const NodeSharedPtr pWorldNode )
-	{
-		// Assuming single space in &lt;world&gt;
-		NodeSharedPtr pSpaceNode = pWorldNode-&gt;getNodeByName( &quot;space&quot; );
-		YAKE_ASSERT( pSpaceNode );
+    //------------------------------------------------------
+    void XODEParser::readWorld( const NodeSharedPtr pWorldNode )
+    {
+	// Assuming single space in &lt;world&gt;
+	NodeSharedPtr pSpaceNode = pWorldNode-&gt;getNodeByName( &quot;space&quot; );
+	YAKE_ASSERT( pSpaceNode );
 
-		YAKE_LOG( &quot;XODE: finding space... &quot; + String( pSpaceNode.get() ? &quot;Yes!&quot; : &quot;No :(&quot; ) );
+	YAKE_LOG( &quot;XODE: finding space... &quot; + String( pSpaceNode.get() ? &quot;Yes!&quot; : &quot;No :(&quot; ) );
 
-		readSpace( pSpaceNode, &quot;world&quot; );
-	}
+	readSpace( pSpaceNode, &quot;world&quot; );
+    }
 
-	//------------------------------------------------------
-	void XODEParser::reset()
-	{
-		//TODO is this really needed?
-		mDocNode.reset();
-	}
+    //------------------------------------------------------
+    void XODEParser::reset()
+    {
+	//TODO is this really needed?
+	mDocNode.reset();
+    }
 
-	//------------------------------------------------------
-	void XODEParser::readSpace( const NodeSharedPtr pSpaceNode, const String&amp; parent )
+    //------------------------------------------------------
+    void XODEParser::readSpace( const NodeSharedPtr pSpaceNode, const String&amp; parent )
+    {
+	YAKE_LOG( &quot;XODE: reading space ...&quot; );
+
+	const dom::NodeList&amp; nodes = pSpaceNode-&gt;getNodes();
+	for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
 	{
-		YAKE_LOG( &quot;XODE: reading space ...&quot; );
+	    String nodeName =
+		yake::StringUtil::toLowerCase( (*it)-&gt;getName() );
 
-		const dom::NodeList&amp; nodes = pSpaceNode-&gt;getNodes();
-		for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
-		{
-			String nodeName =
-				yake::StringUtil::toLowerCase( (*it)-&gt;getName() );
-
-			if ( nodeName == &quot;body&quot; )
-			{
-				readBody( *it, parent );
-			}
-			else if ( nodeName == &quot;geom&quot; )
-			{
-				readGeom( *it, parent );
-			}
-			else if ( nodeName == &quot;bodygroup&quot; )
-			{
-				//TODO bodygroup reading here
-				YAKE_LOG( &quot;XODE: Bodygroup is not yet implemented in parser&quot; ); 
-			}
-		}
+	    if ( nodeName == &quot;body&quot; )
+	    {
+		readBody( *it, parent );
+	    }
+	    else if ( nodeName == &quot;geom&quot; )
+	    {
+		readGeom( *it, parent );
+	    }
+	    else if ( nodeName == &quot;bodygroup&quot; )
+	    {
+		//TODO bodygroup reading here
+		YAKE_LOG( &quot;XODE: Bodygroup is not yet implemented in parser&quot; ); 
+	    }
+	    else if ( nodeName == &quot;joint&quot; )
+	    {
+		readJoint( *it, parent );
+	    }
 	}
+    }
 
-	/// Utility functor for use with std::find_if
-	//------------------------------------------------------
-	class NodeHunter : public std::unary_function&lt;XODEParser::NodeSharedPtr&amp;,bool&gt;
-	{
+    /// Utility functor for use with std::find_if
+    //------------------------------------------------------
+    class NodeHunter : public std::unary_function&lt;XODEParser::NodeSharedPtr&amp;,bool&gt;
+    {
 	public:
-		NodeHunter( const String&amp; rNodeName ) : nodeName_( rNodeName )
-		{}
+	    NodeHunter( const String&amp; rNodeName ) : nodeName_( rNodeName )
+	    {}
 
-		bool operator()( const XODEParser::NodeSharedPtr&amp; pNode )
-		{
-			return pNode-&gt;getName() == nodeName_;
-		}
+	    bool operator()( const XODEParser::NodeSharedPtr&amp; pNode )
+	    {
+		return pNode-&gt;getName() == nodeName_;
+	    }
 
 	private:
-		String nodeName_;
-	};
+	    String nodeName_;
+    };
 
-	//------------------------------------------------------
-	void XODEParser::readVector3( const NodeSharedPtr pVecNode, Vector3&amp; rVec )
-	{
-		real x = StringUtil::parseReal( pVecNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;x&quot; ) );
-		real y = StringUtil::parseReal( pVecNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;y&quot; ) );
-		real z = StringUtil::parseReal( pVecNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;z&quot; ) );
+    //------------------------------------------------------
+    void XODEParser::readVector3( const NodeSharedPtr pVecNode, math::Vector3&amp; rVec )
+    {
+	real x = StringUtil::parseReal( pVecNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;x&quot; ) );
+	real y = StringUtil::parseReal( pVecNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;y&quot; ) );
+	real z = StringUtil::parseReal( pVecNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;z&quot; ) );
 
-		rVec = Vector3( x, y, z );
-	}
+	rVec = math::Vector3( x, y, z );
+    }
 
-	//------------------------------------------------------
-	void XODEParser::readScale( const NodeSharedPtr pScaleNode, Vector3&amp; rScale )
+    //------------------------------------------------------
+    void XODEParser::readScale( const NodeSharedPtr pScaleNode, math::Vector3&amp; rScale )
+    {
+	readVector3( pScaleNode, rScale );
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readPosition( const NodeSharedPtr pPosNode, math::Vector3&amp; rPos )
+    {
+	readVector3( pPosNode, rPos );
+    }
+
+    //------------------------------------------------------
+    /**
+     * Reads quaternion from pQuatNode to rQuat
+     * Ignores aformat attribute
+     * @param pQuatNode
+     * @param rQuat
+     */
+    void XODEParser::readQuaternion( const NodeSharedPtr pQuatNode, math::Quaternion&amp; rQuat )
+    {
+	real x = StringUtil::parseReal( pQuatNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;x&quot; ) );
+	real y = StringUtil::parseReal( pQuatNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;y&quot; ) );
+	real z = StringUtil::parseReal( pQuatNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;z&quot; ) );
+	real w = StringUtil::parseReal( pQuatNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;w&quot; ) );
+
+	rQuat = math::Quaternion( w, x, y, z );
+    }
+
+    //------------------------------------------------------
+    /**
+     *	Reads angle and axis x, y, z attributes and spawns quaternion with them in rRot
+     * @param pRotNode
+     * @param rRot
+     */
+    void XODEParser::readAxisAngleRot( const NodeSharedPtr pRotNode, math::Quaternion&amp; rRot )
+    {
+	real x = StringUtil::parseReal( pRotNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;x&quot; ) );
+	real y = StringUtil::parseReal( pRotNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;y&quot; ) );
+	real z = StringUtil::parseReal( pRotNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;z&quot; ) );
+	real angle = StringUtil::parseReal( pRotNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;angle&quot; ) );
+
+	rRot.FromAngleAxis( angle, math::Vector3( x, y, z ) );
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readRotation( const NodeSharedPtr pRotNode, math::Quaternion&amp; rRot )
+    {
+	const dom::NodeList&amp; nodes = pRotNode-&gt;getNodes();
+
+	for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
 	{
-		readVector3( pScaleNode, rScale );
-	}
+	    String nodeName = StringUtil::toLowerCase( (*it)-&gt;getName() );
 
-	//------------------------------------------------------
-	void XODEParser::readPosition( const NodeSharedPtr pPosNode, Vector3&amp; rPos )
-	{
-		readVector3( pPosNode, rPos );
+	    if ( nodeName == &quot;quaternion&quot; )
+	    {
+		readQuaternion( *it, rRot );
+	    }
+	    else if ( nodeName == &quot;euler&quot; )
+	    {
+		YAKE_ASSERT( false ).error( &quot;euler is NYI&quot; );
+	    }
+	    else if ( nodeName == &quot;axisangle&quot; )
+	    {
+		readAxisAngleRot( *it, rRot );
+	    }
 	}
+    }
 
-	//------------------------------------------------------
-	/**
-	* Reads quaternion from pQuatNode to rQuat
-	* Ignores aformat attribute
-	* @param pQuatNode
-	* @param rQuat
-	*/
-	void XODEParser::readQuaternion( const NodeSharedPtr pQuatNode, Quaternion&amp; rQuat )
+    //------------------------------------------------------
+    void XODEParser::readTransform( const NodeSharedPtr pTransformNode, Transform&amp; rTrans )
+    {
+	const dom::NodeList&amp; nodes = pTransformNode-&gt;getNodes();
+
+	for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
 	{
-		real x = StringUtil::parseReal( pQuatNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;x&quot; ) );
-		real y = StringUtil::parseReal( pQuatNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;y&quot; ) );
-		real z = StringUtil::parseReal( pQuatNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;z&quot; ) );
-		real w = StringUtil::parseReal( pQuatNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;w&quot; ) );
+	    String nodeName =
+		StringUtil::toLowerCase( (*it)-&gt;getName() );
 
-		rQuat = Quaternion( w, x, y, z );
+	    if ( nodeName == &quot;position&quot; )
+	    {
+		readPosition( *it, rTrans.position_ );
+	    }
+	    else if ( nodeName == &quot;rotation&quot; )
+	    {
+		readRotation( *it, rTrans.rotation_ );
+	    }
+	    else if ( nodeName == &quot;scale&quot; )
+	    {
+		readScale( *it, rTrans.scale_ );
+	    }
+	    else if ( nodeName == &quot;matrix4f&quot; )
+	    {
+		YAKE_ASSERT( false ).error( &quot;matrix4f is NYI&quot; );
+	    }
 	}
+    }
 
-	//------------------------------------------------------
-	/**
-	*	Reads angle and axis x, y, z attributes and spawns quaternion with them in rRot
-	* @param pRotNode
-	* @param rRot
-	*/
-	void XODEParser::readAxisAngleRot( const NodeSharedPtr pRotNode, Quaternion&amp; rRot )
+    //------------------------------------------------------
+    void XODEParser::readMassShape( const NodeSharedPtr pMShapeNode, const String&amp; parent,
+	    const Transform&amp; rParentTransform )
+    {
+	real density = 0; //default ...
+
+	// if density is provided...
+	String strDensity = pMShapeNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;density&quot; );
+	if ( !strDensity.empty() ) 
 	{
-		real x = StringUtil::parseReal( pRotNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;x&quot; ) );
-		real y = StringUtil::parseReal( pRotNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;y&quot; ) );
-		real z = StringUtil::parseReal( pRotNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;z&quot; ) );
-		real angle = StringUtil::parseReal( pRotNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;angle&quot; ) );
-
-		rRot.FromAngleAxis( angle, Vector3( x, y, z ) );
+	    density = StringUtil::parseReal( strDensity );
+	    YAKE_LOG( &quot;XODE: reading mass_shape with density = &quot; + strDensity + &quot; &quot; );
 	}
 
-	//------------------------------------------------------
-	void XODEParser::readRotation( const NodeSharedPtr pRotNode, Quaternion&amp; rRot )
+	const dom::NodeList&amp; nodes = pMShapeNode-&gt;getNodes();
+	for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it)
 	{
-		const dom::NodeList&amp; nodes = pRotNode-&gt;getNodes();
+	    String nodeName = StringUtil::toLowerCase( (*it)-&gt;getName() );
 
-		for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
-		{
-			String nodeName =
-				StringUtil::toLowerCase( (*it)-&gt;getName() );
+	    YAKE_LOG( &quot;XODE: reading mass_shape that is &quot; + nodeName + &quot; &quot; );
 
-			if ( nodeName == &quot;quaternion&quot; )
-			{
-				readQuaternion( *it, rRot );
-			}
-			else if ( nodeName == &quot;euler&quot; )
-			{
-				YAKE_ASSERT( false ).error( &quot;euler is NYI&quot; );
-			}
-			else if ( nodeName == &quot;axisangle&quot; )
-			{
-				readAxisAngleRot( *it, rRot );
-			}
-		}
-	}
+	    IBody::MassDesc* physicsMassDesc = NULL;
 
-	//------------------------------------------------------
-	void XODEParser::readTransform( const NodeSharedPtr pTransformNode, Transform&amp; rTrans )
-	{
-		const dom::NodeList&amp; nodes = pTransformNode-&gt;getNodes();
+	    if ( nodeName == &quot;cylinder&quot; )
+	    {
+		real radius, length;
+		readCylinder( *it, radius, length );
 
-		for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
-		{
-			String nodeName =
-				StringUtil::toLowerCase( (*it)-&gt;getName() );
+		physicsMassDesc = new IBody::CylinderMassDesc( radius, length, density,
+			rParentTransform.position_,
+			IBody::QT_DENSITY );
+	    }
+	    else if ( nodeName == &quot;sphere&quot; )
+	    {
+		real radius; readSphere( *it, radius );
 
-			if ( nodeName == &quot;position&quot; )
-			{
-				readPosition( *it, rTrans.position_ );
-			}
-			else if ( nodeName == &quot;rotation&quot; )
-			{
-				readRotation( *it, rTrans.rotation_ );
-			}
-			else if ( nodeName == &quot;scale&quot; )
-			{
-				readScale( *it, rTrans.scale_ );
-			}
-			else if ( nodeName == &quot;matrix4f&quot; )
-			{
-				YAKE_ASSERT( false ).error( &quot;matrix4f is NYI&quot; );
-			}
-		}
-	}
+		physicsMassDesc = new IBody::SphereMassDesc(radius, density,
+			rParentTransform.position_,
+			IBody::QT_DENSITY );
+	    }
+	    else if ( nodeName == &quot;box&quot; )
+	    {
+		real sX, sY, sZ;
+		readBox( *it, sX, sY, sZ );
 
-	//------------------------------------------------------
-	void XODEParser::readMassShape( const NodeSharedPtr pMShapeNode, const String&amp; parent,
-		const Transform&amp; rParentTransform )
-	{
-		real density = 0; //default ...
+		physicsMassDesc = new IBody::BoxMassDesc( sX, sY, sZ, density,
+			rParentTransform.position_,
+			IBody::QT_DENSITY );
+	    }
+	    else if ( nodeName == &quot;cappedCylinder&quot; )
+	    {
+		real radius, length;
+		readCappedCylinder( *it, radius, length );
 
-		// if density is provided...
-		String strDensity = pMShapeNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;density&quot; );
-		if ( !strDensity.empty() ) 
-		{
-			density = StringUtil::parseReal( strDensity );
-			YAKE_LOG( &quot;XODE: reading mass_shape with density = &quot; + strDensity + &quot; &quot; );
-		}
+		physicsMassDesc = new IBody::CapsuleMassDesc( radius, length, density,
+			rParentTransform.position_,
+			IBody::QT_DENSITY );
+	    }
 
-		const dom::NodeList&amp; nodes = pMShapeNode-&gt;getNodes();
-		for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it)
-		{
-			String nodeName = StringUtil::toLowerCase( (*it)-&gt;getName() );
+	    if ( physicsMassDesc != NULL )
+	    {
 
-			YAKE_LOG( &quot;XODE: reading mass_shape that is &quot; + nodeName + &quot; &quot; );
+		MassDesc desc;
+		desc.mass_.reset( physicsMassDesc );
+		desc.parentName_ = parent;
 
-			IBody::MassDesc* physicsMassDesc = NULL;
+		// TODO set the other mass params!
+		// parent name, etc.
+		sigMass_( desc );
+		// TODO needed?? massDescriptions_[ name ] = desc;
+	    }
+	}
+    }
 
-			if ( nodeName == &quot;cylinder&quot; )
-			{
-				real radius, length;
-				readCylinder( *it, radius, length );
+    //------------------------------------------------------
+    void XODEParser::readMassAdjust( const NodeSharedPtr pMAdjustNode, const String&amp; parent )
+    {
+	real total = StringUtil::parseReal( pMAdjustNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;total&quot; ) );
 
-				physicsMassDesc = new IBody::CylinderMassDesc( radius, length, density,
-					rParentTransform.position_,
-					IBody::QT_DENSITY );
-			}
-			else if ( nodeName == &quot;sphere&quot; )
-			{
-				real radius; readSphere( *it, radius );
+	YAKE_LOG_INFORMATION( &quot;XODE: read mass adjust - &quot; + pMAdjustNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;total&quot; ) );
 
-				physicsMassDesc = new IBody::SphereMassDesc(radius, density,
-					rParentTransform.position_,
-					IBody::QT_DENSITY );
-			}
-			else if ( nodeName == &quot;box&quot; )
-			{
-				real sX, sY, sZ;
-				readBox( *it, sX, sY, sZ );
+	MassDesc desc;
+	desc.parentName_ = parent;
+	desc.mass_.reset( new IBody::MassDesc( total, math::Vector3::kZero, IBody::QT_MASS ) );
 
-				physicsMassDesc = new IBody::BoxMassDesc( sX, sY, sZ, density,
-					rParentTransform.position_,
-					IBody::QT_DENSITY );
-			}
-			else if ( nodeName == &quot;cappedCylinder&quot; )
-			{
-				real radius, length;
-				readCappedCylinder( *it, radius, length );
+	sigMass_( desc );
+    }
 
-				physicsMassDesc = new IBody::CapsuleMassDesc( radius, length, density,
-					rParentTransform.position_,
-					IBody::QT_DENSITY );
-			}
+    //------------------------------------------------------
+    void XODEParser::readMass( const NodeSharedPtr pMassNode, const String&amp; parent, const Transform&amp; rParentTransform )
+    {
+	const dom::NodeList&amp; nodes = pMassNode-&gt;getNodes();
 
-			if ( physicsMassDesc != NULL )
-			{
+	// Seek transform
+	Transform massTransform;
 
-				MassDesc desc;
-				desc.mass_.reset( physicsMassDesc );
-				desc.parentName_ = parent;
+	NodeHunter hunter( &quot;transform&quot; );
+	NodeListIter iTrans =
+	    std::find_if&lt;NodeListIter,NodeHunter&gt;( nodes.begin(), nodes.end(), hunter );
 
-				// TODO set the other mass params!
-				// parent name, etc.
-				sigMass_( desc );
-				// TODO needed?? massDescriptions_[ name ] = desc;
-			}
-		}
+	if ( iTrans != nodes.end() )
+	{
+	    readTransform( *iTrans, massTransform );
 	}
 
-	//------------------------------------------------------
-	void XODEParser::readMassAdjust( const NodeSharedPtr pMAdjustNode, const String&amp; parent )
+	if ( !rParentTransform.isIdentity() )
 	{
-		real total = StringUtil::parseReal( pMAdjustNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;total&quot; ) );
-
-		MassDesc desc;
-		desc.parentName_ = parent;
-		desc.mass_.reset( new IBody::MassDesc( total, Vector3::kZero, IBody::QT_MASS ) );
-
-		sigMass_( desc );
+	    massTransform = massTransform.getDerivedTransform( rParentTransform );
 	}
 
-	//------------------------------------------------------
-	void XODEParser::readMass( const NodeSharedPtr pMassNode, const String&amp; parent, const Transform&amp; rParentTransform )
+	for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it)
 	{
-		const dom::NodeList&amp; nodes = pMassNode-&gt;getNodes();
+	    String nodeName =
+		StringUtil::toLowerCase( (*it)-&gt;getName() );
 
-		// Seek transform
-		Transform massTransform;
+	    if ( nodeName == &quot;mass_shape&quot; )
+	    {
+		readMassShape( *it, parent, massTransform );
+	    }
+	    else if ( nodeName == &quot;adjust&quot; )
+	    {
+		readMassAdjust( *it, parent );
+	    }
+	    else if ( nodeName == &quot;mass&quot; )
+	    {
+		readMass( *it, parent, massTransform );
+	    }
+	}
 
-		NodeHunter hunter( &quot;transform&quot; );
-		NodeListIter iTrans =
-			std::find_if&lt;NodeListIter,NodeHunter&gt;( nodes.begin(), nodes.end(), hunter );
+    }
 
-		if ( iTrans != nodes.end() )
-		{
-			readTransform( *iTrans, massTransform );
-		}
+    //------------------------------------------------------
+    // This method is called on any unknown extension
+    void XODEParser::readExtension( const NodeSharedPtr, 
+	    const String&amp; parent, 
+	    const Transform&amp; parentTransformIfAny )
+    {
+	// this virtual method should be overriden by any parser that wants to parse xode extensions
+    }
 
-		if ( !rParentTransform.isIdentity() )
-		{
-			massTransform = massTransform.getDerivedTransform( rParentTransform );
-		}
+    //------------------------------------------------------
+    void XODEParser::readBody( const NodeSharedPtr pBodyNode, const String&amp; parent )
+    {
+	const String name = pBodyNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;name&quot; );
+	YAKE_LOG( &quot;XODE: reading body &quot; + name );
 
-		for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it)
-		{
-			String nodeName =
-				StringUtil::toLowerCase( (*it)-&gt;getName() );
+	// Setting up body description...
+	BodyDesc desc;
+	desc.name_ = name;
+	desc.parentName_ = parent;
 
-			if ( nodeName == &quot;mass_shape&quot; )
-			{
-				readMassShape( *it, parent, massTransform );
-			}
-			else if ( nodeName == &quot;adjust&quot; )
-			{
-				readMassAdjust( *it, parent );
-			}
-			else if ( nodeName == &quot;mass&quot; )
-			{
-				readMass( *it, parent, massTransform );
-			}
-		}
+	const dom::NodeList&amp; nodes = pBodyNode-&gt;getNodes();
 
-	}
+	// Seek transform
+	NodeHunter hunter( &quot;transform&quot; );
+	NodeListIter iTrans =
+	    std::find_if&lt;NodeListIter,NodeHunter&gt;( nodes.begin(), nodes.end(), hunter );
 
-	//------------------------------------------------------
-	void XODEParser::readBody( const NodeSharedPtr pBodyNode, const String&amp; parent )
+	Transform bodyTransform;
+	if ( iTrans != nodes.end() )
 	{
-		const String name = pBodyNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;name&quot; );
-		YAKE_LOG( &quot;XODE: reading body &quot; + name );
+	    YAKE_LOG( &quot;XODE: body &quot; + name + &quot; has transform &quot; );
 
-		// Setting up body description...
-		BodyDesc desc;
-		desc.name_ = name;
-		desc.parentName_ = parent;
+	    readTransform( *iTrans, bodyTransform );
 
-		const dom::NodeList&amp; nodes = pBodyNode-&gt;getNodes();
+	    if ( !bodyTransform.isIdentity() )
+	    {
+		desc.transform_ = bodyTransform;
+	    }
+	}
 
-		// Seek transform
-		NodeHunter hunter( &quot;transform&quot; );
-		NodeListIter iTrans =
-			std::find_if&lt;NodeListIter,NodeHunter&gt;( nodes.begin(), nodes.end(), hunter );
+	// fire signal!
+	sigBody_( desc );
+	// TODO add to collection?
 
-		Transform bodyTransform;
-		if ( iTrans != nodes.end() )
-		{
-			YAKE_LOG( &quot;XODE: body &quot; + name + &quot; has transform &quot; );
+	for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
+	{
+	    String nodeName = StringUtil::toLowerCase( (*it)-&gt;getName() );
 
-			readTransform( *iTrans, bodyTransform );
+	    YAKE_LOG( &quot;XODE: body &quot; + name + &quot; has node #&quot; + nodeName );
 
-			if ( !bodyTransform.isIdentity() )
-			{
-				desc.transform_ = bodyTransform;
-			}
-		}
+	    if ( nodeName == &quot;geom&quot; )
+	    {
+		readGeom( *it, name, bodyTransform );
+	    }
+	    else if ( nodeName == &quot;mass&quot; )
+	    {
+		readMass( *it, name, bodyTransform );
+	    }
+	    else if ( nodeName == &quot;joint&quot; )
+	    {
+		readJoint( *it, name, bodyTransform );
+	    }
+	    else if ( nodeName == &quot;ext&quot; )
+	    {
+		readExtension( *it, name, bodyTransform );
+	    }
+	}
+    }
 
-		// fire signal!
-		sigBody_( desc );
-		// TODO add to collection?
+    //------------------------------------------------------
+    /**
+     *	 Searches for &lt;ext name=&quot;material&quot;&gt; node, parses it, creates material and returns ptr to created material
+     * If no node, returns NULL
+     * @param pNode - node to search
+     */
+    void XODEParser::readMaterialExt( const NodeSharedPtr pNode, const String&amp; parent )
+    {
+	YAKE_LOG( &quot;XODE: entered readMaterialExt...&quot; );
 
-		for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
-		{
-			String nodeName = StringUtil::toLowerCase( (*it)-&gt;getName() );
+	const dom::NodeList&amp; nodes = pNode-&gt;getNodes();
 
-			YAKE_LOG( &quot;XODE: body &quot; + name + &quot; has node #&quot; + nodeName );
+	// Looking for ext
+	// TODO maybe we need some advanced searching here?
+	// like finding all ext nodes or finding &lt;ext name=&quot;material&quot;&gt;?
+	// For now finding ext would be enough
+	NodeHunter hunter( &quot;ext&quot; );
+	NodeListIter iExt =
+	    std::find_if&lt;NodeListIter,NodeHunter&gt;( nodes.begin(), nodes.end(), hunter );
 
-			if ( nodeName == &quot;geom&quot; )
-			{
-				readGeom( *it, name, bodyTransform );
-			}
-			else if ( nodeName == &quot;mass&quot; )
-			{
-				readMass( *it, name, bodyTransform );
-			}
-			else if ( nodeName == &quot;joint&quot; )
-			{
-				readJoint( *it, name, bodyTransform );
-			}
-		}
+	if ( iExt == nodes.end() )
+	{
+	    YAKE_LOG( &quot;XODE: didn't find extension... &quot; );
+	    return;
 	}
 
-	//------------------------------------------------------
-	/**
-	*	 Searches for &lt;ext name=&quot;material&quot;&gt; node, parses it, creates material and returns ptr to created material
-	* If no node, returns NULL
-	* @param pNode - node to search
-	*/
-	void XODEParser::readMaterialExt( const NodeSharedPtr pNode, const String&amp; parent )
+	YAKE_LOG( &quot;XODE: found extension... processing... :) &quot; );
+
+	if ( (*iExt)-&gt;getAttributeValueAs&lt;String&gt;( &quot;name&quot; ) != &quot;material&quot; )
 	{
-		YAKE_LOG( &quot;XODE: entered readMaterialExt...&quot; );
+	    YAKE_LOG( &quot;XODE: extension is not material&quot; );
+	}
 
-		const dom::NodeList&amp; nodes = pNode-&gt;getNodes();
+	YAKE_LOG( &quot;XODE: the extension IS material! Parsing...&quot; );
 
-		// Looking for ext
-		// TODO maybe we need some advanced searching here?
-		// like finding all ext nodes or finding &lt;ext name=&quot;material&quot;&gt;?
-		// For now finding ext would be enough
-		NodeHunter hunter( &quot;ext&quot; );
-		NodeListIter iExt =
-			std::find_if&lt;NodeListIter,NodeHunter&gt;( nodes.begin(), nodes.end(), hunter );
+	const dom::NodeList&amp; extNodes = (*iExt)-&gt;getNodes();
+	//HACK assuming first node is &quot;params&quot;
+	NodeSharedPtr pParamsNode = *extNodes.begin();
 
-		if ( iExt == nodes.end() )
-		{
-			YAKE_LOG( &quot;XODE: didn't find extension... &quot; );
-			return;
-		}
+	// parsing
+	IMaterial::Desc desc;
 
-		YAKE_LOG( &quot;XODE: found extension... processing... :) &quot; );
+	String strFriction = pParamsNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;friction&quot; );
+	String strRestitution = pParamsNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;bouncecoeff&quot; );
+	String strSoftness = pParamsNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;soften&quot; );
 
-		if ( (*iExt)-&gt;getAttributeValueAs&lt;String&gt;( &quot;name&quot; ) != &quot;material&quot; )
-		{
-			YAKE_LOG( &quot;XODE: extension is not material&quot; );
-		}
+	YAKE_LOG( &quot;XODE: read friction = &quot; + strFriction );
+	YAKE_LOG( &quot;XODE: read restitution = &quot; + strRestitution );
+	YAKE_LOG( &quot;XODE: read softness = &quot; + strSoftness );
 
-		YAKE_LOG( &quot;XODE: the extension IS material! Parsing...&quot; );
+	desc.mFriction = StringUtil::parseReal( strFriction );
+	desc.mRestitution = StringUtil::parseReal( strRestitution );
+	desc.mSoftness = StringUtil::parseReal( strSoftness );
 
-		const dom::NodeList&amp; extNodes = (*iExt)-&gt;getNodes();
-		//HACK assuming first node is &quot;params&quot;
-		NodeSharedPtr pParamsNode = *extNodes.begin();
+	//TODO fill in all other description params!
+	// parent name, etc
+	MaterialDesc matDesc;
+	matDesc.name_ = parent + &quot;material&quot;; // TODO make something totally yake::Unique here?
+	matDesc.material_ = desc;
+	matDesc.parentName_ = parent;
 
-		// parsing
-		IMaterial::Desc desc;
+	sigMaterial_( matDesc );
+    }
 
-		String strFriction = pParamsNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;friction&quot; );
-		String strRestitution = pParamsNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;bouncecoeff&quot; );
-		String strSoftness = pParamsNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;soften&quot; );
+    //------------------------------------------------------
+    /**
+     * Reads geom xode node
+     * No folded bodies, geoms, spaces processed.
+     * @param pGeomNode
+     * @param pParentObject
+     */
+    void XODEParser::readGeom(	const NodeSharedPtr pGeomNode, const String&amp; parent, 
+	    const Transform&amp; rParentTransform, bool absoluteTransform )
+    {
+	const String name = pGeomNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;name&quot; );
+	YAKE_LOG( &quot;XODE: reading geom &quot; + name );
 
-		YAKE_LOG( &quot;XODE: read friction = &quot; + strFriction );
-		YAKE_LOG( &quot;XODE: read restitution = &quot; + strRestitution );
-		YAKE_LOG( &quot;XODE: read softness = &quot; + strSoftness );
+	const dom::NodeList&amp; nodes = pGeomNode-&gt;getNodes();
 
-		desc.mFriction = StringUtil::parseReal( strFriction );
-		desc.mRestitution = StringUtil::parseReal( strRestitution );
-		desc.mSoftness = StringUtil::parseReal( strSoftness );
+	// Looking for transform
+	NodeHunter hunter( &quot;transform&quot; );
+	NodeListIter iTrans =
+	    std::find_if&lt;NodeListIter,NodeHunter&gt;( nodes.begin(), nodes.end(), hunter );
 
-		//TODO fill in all other description params!
-		// parent name, etc
-		MaterialDesc matDesc;
-		matDesc.name_ = parent + &quot;material&quot;; // TODO make something totally yake::Unique here?
-		matDesc.material_ = desc;
-		matDesc.parentName_ = parent;
+	Transform geomTransform;
 
-		sigMaterial_( matDesc );
+	if ( iTrans != nodes.end() )
+	{
+	    YAKE_LOG( &quot;XODE: readGeom() [&quot; + name + &quot;] : geom has transform &quot; );
+
+	    readTransform( *iTrans, geomTransform );
 	}
 
-	//------------------------------------------------------
-	/**
-	* Reads geom xode node
-	* No folded bodies, geoms, spaces processed.
-	* @param pGeomNode
-	* @param pParentObject
-	*/
-	void XODEParser::readGeom(	const NodeSharedPtr pGeomNode, const String&amp; parent, const Transform&amp; rParentTransform )
-	{
-		const String name = pGeomNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;name&quot; );
-		YAKE_LOG( &quot;XODE: reading geom &quot; + name );
+	// if transform is absolute, we need to provide derived transform
+	if ( absoluteTransform )
+	    geomTransform = geomTransform.getDerivedTransform( rParentTransform );
 
-		const dom::NodeList&amp; nodes = pGeomNode-&gt;getNodes();
+	YAKE_LOG( &quot;XODE: scanning other geom properties...&quot; );
 
-		// Looking for transform
-		NodeHunter hunter( &quot;transform&quot; );
-		NodeListIter iTrans =
-			std::find_if&lt;NodeListIter,NodeHunter&gt;( nodes.begin(), nodes.end(), hunter );
+	for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
+	{
+	    String nodeName = StringUtil::toLowerCase( (*it)-&gt;getName() );
 
-		Transform geomTransform;
+	    YAKE_LOG( &quot;XODE: geom [&quot; + name + &quot;] has node #&quot; + nodeName );
 
-		if ( iTrans != nodes.end() )
-		{
-			YAKE_LOG( &quot;XODE: readGeom() [&quot; + name + &quot;] : geom has transform &quot; );
+	    IShape::Desc* shapeDesc = NULL;
 
-			readTransform( *iTrans, geomTransform );
-		}
+	    if ( nodeName == &quot;geom&quot; )
+	    {
+		// reading folded geom -&gt; absolute transform is provided
+		// parent ( actor ) remains the same
+		readGeom( *it, parent, geomTransform, true );
+	    }
+	    if ( nodeName == &quot;box&quot; )
+	    {
+		real sizeX, sizeY, sizeZ;
+		readBox( *it, sizeX, sizeY, sizeZ );
 
-		YAKE_LOG( &quot;XODE: scanning other geom properties...&quot; );
+		sizeX *= rParentTransform.scale_.x;
+		sizeY *= rParentTransform.scale_.y;
+		sizeZ *= rParentTransform.scale_.z;
 
-		for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
-		{
-			String nodeName = StringUtil::toLowerCase( (*it)-&gt;getName() );
+		String strSizeX; strSizeX &lt;&lt; sizeX;
+		String strSizeY; strSizeY &lt;&lt; sizeY;
+		String strSizeZ; strSizeZ &lt;&lt; sizeZ;
 
-			YAKE_LOG( &quot;XODE: geom [&quot; + name + &quot;] has node #&quot; + nodeName );
+		YAKE_LOG( &quot;XODE: box with sizes: &quot; + strSizeX + &quot;, &quot; + strSizeY + &quot;, &quot; + strSizeZ );
 
-			IShape::Desc* shapeDesc = NULL;
+		shapeDesc = new IShape::BoxDesc( math::Vector3( sizeX, sizeY, sizeZ ), &quot;&quot;,
+			geomTransform.position_, geomTransform.rotation_ );
+	    }
+	    else if ( nodeName == &quot;cappedCylinder&quot; )
+	    {
+		real radius, length;
+		readCappedCylinder( *it, radius, length );
 
-			if ( nodeName == &quot;box&quot; )
-			{
-				real sizeX, sizeY, sizeZ;
-				readBox( *it, sizeX, sizeY, sizeZ );
+		real scale = ( rParentTransform.scale_.x
+			+ rParentTransform.scale_.y
+			+ rParentTransform.scale_.z ) /3;
 
-				sizeX *= rParentTransform.scale_.x;
-				sizeY *= rParentTransform.scale_.y;
-				sizeZ *= rParentTransform.scale_.z;
+		radius *= scale;
+		length *= scale;
 
-				String strSizeX; strSizeX &lt;&lt; sizeX;
-				String strSizeY; strSizeY &lt;&lt; sizeY;
-				String strSizeZ; strSizeZ &lt;&lt; sizeZ;
+		shapeDesc = new IShape::CapsuleDesc( length,
+			radius,
+			&quot;&quot;,
+			geomTransform.position_,
+			geomTransform.rotation_ );
+	    }
+	    else if ( nodeName == &quot;cone&quot; )
+	    {
+		real radius, length;
+		readCone( *it, radius, length );
 
-				YAKE_LOG( &quot;XODE: box with sizes: &quot; + strSizeX + &quot;, &quot; + strSizeY + &quot;, &quot; + strSizeZ );
+		real scale = ( rParentTransform.scale_.x
+			+ rParentTransform.scale_.y
+			+ rParentTransform.scale_.z ) /3;
 
-				shapeDesc = new IShape::BoxDesc( Vector3( sizeX, sizeY, sizeZ ), &quot;&quot;,
-					geomTransform.position_, geomTransform.rotation_ );
-			}
-			else if ( nodeName == &quot;cappedCylinder&quot; )
-			{
-				real radius, length;
-				readCappedCylinder( *it, radius, length );
+		radius *= scale;
+		length *= scale;
 
-				real scale = ( rParentTransform.scale_.x
-					+ rParentTransform.scale_.y
-					+ rParentTransform.scale_.z ) /3;
+		YAKE_ASSERT( false ).error( &quot;NOT implemented in Yake&quot; ); //TODO
+	    }
+	    else if ( nodeName == &quot;cylinder&quot; )
+	    {
+		real radius, length;
+		readCylinder( *it, radius, length );
 
-				radius *= scale;
-				length *= scale;
+		real scale = ( rParentTransform.scale_.x
+			+ rParentTransform.scale_.y
+			+ rParentTransform.scale_.z ) /3;
 
-				shapeDesc = new IShape::CapsuleDesc( length,
-					radius,
-					&quot;&quot;,
-					geomTransform.position_,
-					geomTransform.rotation_ );
-			}
-			else if ( nodeName == &quot;cone&quot; )
-			{
-				real radius, length;
-				readCone( *it, radius, length );
+		radius *= scale;
+		length *= scale;
 
-				real scale = ( rParentTransform.scale_.x
-					+ rParentTransform.scale_.y
-					+ rParentTransform.scale_.z ) /3;
+		shapeDesc = new IShape::CapsuleDesc( length,
+			radius,
+			&quot;&quot;,
+			geomTransform.position_,
+			geomTransform.rotation_ );
+	    }
+	    else if ( nodeName == &quot;plane&quot; )
+	    {
+		real a, b, c, d;
+		readPlane( *it, a, b, c, d );
+		shapeDesc = new IShape::PlaneDesc( math::Vector3( a, b, c ),
+			d,
+			&quot;&quot;,
+			geomTransform.position_,
+			geomTransform.rotation_ );
+	    }
+	    else if ( nodeName == &quot;ray&quot; )
+	    {
+		real length;
+		readRay( *it, length );
 
-				radius *= scale;
-				length *= scale;
+		real scale = ( rParentTransform.scale_.x
+			+ rParentTransform.scale_.y
+			+ rParentTransform.scale_.z ) /3;
 
-				YAKE_ASSERT( false ).error( &quot;NOT implemented in Yake&quot; ); //TODO
-			}
-			else if ( nodeName == &quot;cylinder&quot; )
-			{
-				real radius, length;
-				readCylinder( *it, radius, length );
+		length *= scale;
 
-				real scale = ( rParentTransform.scale_.x
-					+ rParentTransform.scale_.y
-					+ rParentTransform.scale_.z ) /3;
+		YAKE_ASSERT( false ).error( &quot;NOT implemented in Yake&quot; ); //TODO
+	    }
+	    else if ( nodeName == &quot;sphere&quot; )
+	    {
+		real radius;
+		readSphere( *it, radius );
 
-				radius *= scale;
-				length *= scale;
+		real scale = ( rParentTransform.scale_.x
+			+ rParentTransform.scale_.y
+			+ rParentTransform.scale_.z ) /3;
 
-				shapeDesc = new IShape::CapsuleDesc( length,
-					radius,
-					&quot;&quot;,
-					geomTransform.position_,
-					geomTransform.rotation_ );
-			}
-			else if ( nodeName == &quot;plane&quot; )
-			{
-				real a, b, c, d;
-				readPlane( *it, a, b, c, d );
-				shapeDesc = new IShape::PlaneDesc( Vector3( a, b, c ),
-					d,
-					&quot;&quot;,
-					geomTransform.position_,
-					geomTransform.rotation_ );
-			}
-			else if ( nodeName == &quot;ray&quot; )
-			{
-				real length;
-				readRay( *it, length );
+		radius *= scale;
 
-				real scale = ( rParentTransform.scale_.x
-					+ rParentTransform.scale_.y
-					+ rParentTransform.scale_.z ) /3;
+		shapeDesc = new IShape::SphereDesc(
+			radius,
+			&quot;&quot;,
+			geomTransform.position_,
+			geomTransform.rotation_ );
+	    }
+	    else if ( nodeName == &quot;trimesh&quot; )
+	    {
+		TriangleMeshDesc::VertexVector vertices;
+		TriangleMeshDesc::IndexVector indices;
 
-				length *= scale;
+		readTrimesh( *it, vertices, indices );
 
-				YAKE_ASSERT( false ).error( &quot;NOT implemented in Yake&quot; ); //TODO
-			}
-			else if ( nodeName == &quot;sphere&quot; )
-			{
-				real radius;
-				readSphere( *it, radius );
+		TriangleMeshDesc::VertexVector scaledVertices;
 
-				real scale = ( rParentTransform.scale_.x
-					+ rParentTransform.scale_.y
-					+ rParentTransform.scale_.z ) /3;
+		ConstVectorIterator&lt; TriangleMeshDesc::VertexVector &gt; iV( vertices.begin(), vertices.end() );
 
-				radius *= scale;
+		while ( iV.hasMoreElements() )
+		{
+		    const math::Vector3&amp; vertex = iV.getNext();
+		    scaledVertices.push_back( vertex * rParentTransform.scale_ );
+		}
 
-				shapeDesc = new IShape::SphereDesc(
-					radius,
-					&quot;&quot;,
-					geomTransform.position_,
-					geomTransform.rotation_ );
-			}
-			else if ( nodeName == &quot;trimesh&quot; )
-			{
-				TriangleMeshDesc::VertexVector vertices;
-				TriangleMeshDesc::IndexVector indices;
+		TriangleMeshDesc dataDesc( vertices, indices );
 
-				readTrimesh( *it, vertices, indices );
+		shapeDesc = new IShape::TriMeshDesc( dataDesc, &quot;&quot;,
+			geomTransform.position_, geomTransform.rotation_ );
+	    }
+	    else if ( nodeName == &quot;ext&quot; )
+	    {
+		readExtension( *it, name, rParentTransform );
+	    }
 
-				TriangleMeshDesc::VertexVector scaledVertices;
+	    if ( shapeDesc != NULL )
+	    {
+		//TODO fill in all other description params!
+		// parent name, etc
+		GeomDesc geomDesc;
+		geomDesc.name_ = name;
+		geomDesc.parentName_ = parent;
+		geomDesc.shape_.reset( shapeDesc );
 
-				ConstVectorIterator&lt; TriangleMeshDesc::VertexVector &gt; iV( vertices.begin(), vertices.end() );
+		sigGeom_( geomDesc );
 
-				while ( iV.hasMoreElements() )
-				{
-					const Vector3&amp; vertex = iV.getNext();
-					scaledVertices.push_back( vertex * rParentTransform.scale_ );
-				}
+		// read material after geom definition was found.
+		// TODO is this a right place to read material?
+		// 
+		readMaterialExt( *it, name );
+	    }
+	}
 
-				TriangleMeshDesc dataDesc( vertices, indices );
+	YAKE_LOG( &quot;XODE: Leaving readGeom()&quot; );
+    }
 
-				shapeDesc = new IShape::TriMeshDesc( dataDesc, &quot;&quot;,
-					geomTransform.position_, geomTransform.rotation_ );
-			}
+    //------------------------------------------------------
+    void XODEParser::readBox( const NodeSharedPtr pNode, real&amp; sizeX, real&amp; sizeY, real&amp; sizeZ )
+    {
+	sizeX = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;sizex&quot; ) );
+	sizeY = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;sizey&quot; ) );
+	sizeZ = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;sizez&quot; ) );
+    }
 
-			if ( shapeDesc != NULL )
-			{
-				//TODO fill in all other description params!
-				// parent name, etc
-				GeomDesc geomDesc;
-				geomDesc.name_ = name;
-				geomDesc.parentName_ = parent;
-				geomDesc.shape_.reset( shapeDesc );
+    //------------------------------------------------------
+    void XODEParser::readCappedCylinder( const NodeSharedPtr pNode, real&amp; radius, real&amp; length )
+    {
+	radius = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;radius&quot; ) );
+	length = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;length&quot; ) );
+    }
 
-				sigGeom_( geomDesc );
+    //------------------------------------------------------
+    void XODEParser::readCone( const NodeSharedPtr pNode, real&amp; radius, real&amp; length )
+    {
+	radius = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;radius&quot; ) );
+	length = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;length&quot; ) );
+    }
 
-				// read material after geom definition was found.
-				// TODO is this a right place to read material?
-				// 
-				readMaterialExt( *it, name );
-			}
-		}
+    //------------------------------------------------------
+    void XODEParser::readCylinder( const NodeSharedPtr pNode, real&amp; radius, real&amp; length )
+    {
+	radius = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;radius&quot; ) );
+	length = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;length&quot; ) );
+    }
 
-		YAKE_LOG( &quot;XODE: Leaving readGeom()&quot; );
-	}
+    //------------------------------------------------------
+    void XODEParser::readPlane( const NodeSharedPtr pNode, real&amp; a, real&amp; b, real&amp; c, real&amp; d )
+    {
+	a = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;a&quot; ) );
+	b = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;b&quot; ) );
+	c = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;c&quot; ) );
+	d = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;d&quot; ) );
+    }
 
-	//------------------------------------------------------
-	void XODEParser::readBox( const NodeSharedPtr pNode, real&amp; sizeX, real&amp; sizeY, real&amp; sizeZ )
-	{
-		sizeX = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;sizex&quot; ) );
-		sizeY = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;sizey&quot; ) );
-		sizeZ = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;sizez&quot; ) );
-	}
+    //------------------------------------------------------
+    void XODEParser::readRay( const NodeSharedPtr pNode, real&amp; length )
+    {
+	length = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;length&quot; ) );
+    }
 
-	//------------------------------------------------------
-	void XODEParser::readCappedCylinder( const NodeSharedPtr pNode, real&amp; radius, real&amp; length )
-	{
-		radius = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;radius&quot; ) );
-		length = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;length&quot; ) );
-	}
+    //------------------------------------------------------
+    void XODEParser::readSphere( const NodeSharedPtr pNode, real&amp; radius )
+    {
+	radius = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;radius&quot; ) );
+    }
 
-	//------------------------------------------------------
-	void XODEParser::readCone( const NodeSharedPtr pNode, real&amp; radius, real&amp; length )
-	{
-		radius = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;radius&quot; ) );
-		length = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;length&quot; ) );
-	}
+    //------------------------------------------------------
+    void XODEParser::readTrimesh( const NodeSharedPtr pMeshNode,
+	    TriangleMeshDesc::VertexVector&amp; rVertices,
+	    TriangleMeshDesc::IndexVector&amp; rIndices )
+    {
+	const dom::NodeList&amp; nodes = pMeshNode-&gt;getNodes();
 
-	//------------------------------------------------------
-	void XODEParser::readCylinder( const NodeSharedPtr pNode, real&amp; radius, real&amp; length )
+	for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it )
 	{
-		radius = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;radius&quot; ) );
-		length = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;length&quot; ) );
-	}
+	    String nodeName = StringUtil::toLowerCase( (*it)-&gt;getName() );
 
-	//------------------------------------------------------
-	void XODEParser::readPlane( const NodeSharedPtr pNode, real&amp; a, real&amp; b, real&amp; c, real&amp; d )
-	{
-		a = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;a&quot; ) );
-		b = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;b&quot; ) );
-		c = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;c&quot; ) );
-		d = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;d&quot; ) );
-	}
+	    YAKE_LOG( &quot;XODE: reading &quot; + nodeName + &quot; trimesh now...&quot; );
 
-	//------------------------------------------------------
-	void XODEParser::readRay( const NodeSharedPtr pNode, real&amp; length )
-	{
-		length = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;length&quot; ) );
+	    if ( nodeName == &quot;vertices&quot; )
+	    {
+		readVertices( *it, rVertices );
+	    }
+	    else if ( nodeName == &quot;triangles&quot; )
+	    {
+		readIndices( *it, rIndices );
+	    }
 	}
+    }
 
-	//------------------------------------------------------
-	void XODEParser::readSphere( const NodeSharedPtr pNode, real&amp; radius )
-	{
-		radius = StringUtil::parseReal( pNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;radius&quot; ) );
-	}
+    //------------------------------------------------------
+    void XODEParser::readVertices( const NodeSharedPtr pNode, TriangleMeshDesc::VertexVector&amp; rVertices )
+    {
+	const dom::NodeList&amp; nodes = pNode-&gt;getNodes();
 
-	//------------------------------------------------------
-	void XODEParser::readTrimesh( const NodeSharedPtr pMeshNode,
-		TriangleMeshDesc::VertexVector&amp; rVertices,
-		TriangleMeshDesc::IndexVector&amp; rIndices )
+	for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it )
 	{
-		const dom::NodeList&amp; nodes = pMeshNode-&gt;getNodes();
+	    String nodeName = StringUtil::toLowerCase( (*it)-&gt;getName() );
 
-		for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it )
-		{
-			String nodeName = StringUtil::toLowerCase( (*it)-&gt;getName() );
+	    if ( nodeName == &quot;v&quot; )
+	    {
+		real x = StringUtil::parseReal( (*it)-&gt;getAttributeValueAs&lt; String &gt;( &quot;x&quot; ) );
+		real y = StringUtil::parseReal( (*it)-&gt;getAttributeValueAs&lt; String &gt;( &quot;y&quot; ) );
+		real z = StringUtil::parseReal( (*it)-&gt;getAttributeValueAs&lt; String &gt;( &quot;z&quot; ) );
 
-			YAKE_LOG( &quot;XODE: reading &quot; + nodeName + &quot; trimesh now...&quot; );
-
-			if ( nodeName == &quot;vertices&quot; )
-			{
-				readVertices( *it, rVertices );
-			}
-			else if ( nodeName == &quot;triangles&quot; )
-			{
-				readIndices( *it, rIndices );
-			}
-		}
+		rVertices.push_back( math::Vector3( x, y, z ) );
+	    }
 	}
+    }
 
-	//------------------------------------------------------
-	void XODEParser::readVertices( const NodeSharedPtr pNode, TriangleMeshDesc::VertexVector&amp; rVertices )
-	{
-		const dom::NodeList&amp; nodes = pNode-&gt;getNodes();
+    //------------------------------------------------------
+    void XODEParser::readIndices( const NodeSharedPtr pNode, TriangleMeshDesc::IndexVector&amp; rIndices )
+    {
+	const dom::NodeList&amp; nodes = pNode-&gt;getNodes();
 
-		for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it )
-		{
-			String nodeName = StringUtil::toLowerCase( (*it)-&gt;getName() );
+	typedef int32 IndexT;
 
-			if ( nodeName == &quot;v&quot; )
-			{
-				real x = StringUtil::parseReal( (*it)-&gt;getAttributeValueAs&lt; String &gt;( &quot;x&quot; ) );
-				real y = StringUtil::parseReal( (*it)-&gt;getAttributeValueAs&lt; String &gt;( &quot;y&quot; ) );
-				real z = StringUtil::parseReal( (*it)-&gt;getAttributeValueAs&lt; String &gt;( &quot;z&quot; ) );
-
-				rVertices.push_back( Vector3( x, y, z ) );
-			}
-		}
-	}
-
-	//------------------------------------------------------
-	void XODEParser::readIndices( const NodeSharedPtr pNode, TriangleMeshDesc::IndexVector&amp; rIndices )
+	for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it )
 	{
-		const dom::NodeList&amp; nodes = pNode-&gt;getNodes();
+	    String nodeName =
+		StringUtil::toLowerCase( (*it)-&gt;getName() );
 
-		typedef int32 IndexT;
+	    if ( nodeName == &quot;t&quot; )
+	    {
+		IndexT ia = StringUtil::parseInt( (*it)-&gt;getAttributeValueAs&lt; String &gt;( &quot;ia&quot; ) );
+		IndexT ib = StringUtil::parseInt( (*it)-&gt;getAttributeValueAs&lt; String &gt;( &quot;ib&quot; ) );
+		IndexT ic = StringUtil::parseInt( (*it)-&gt;getAttributeValueAs&lt; String &gt;( &quot;ic&quot; ) );
 
-		for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it )
-		{
-			String nodeName =
-				StringUtil::toLowerCase( (*it)-&gt;getName() );
+		rIndices.push_back( ia );
+		rIndices.push_back( ib );
+		rIndices.push_back( ic );
+	    }
+	}
+    }
 
-			if ( nodeName == &quot;t&quot; )
-			{
-				IndexT ia = StringUtil::parseInt( (*it)-&gt;getAttributeValueAs&lt; String &gt;( &quot;ia&quot; ) );
-				IndexT ib = StringUtil::parseInt( (*it)-&gt;getAttributeValueAs&lt; String &gt;( &quot;ib&quot; ) );
-				IndexT ic = StringUtil::parseInt( (*it)-&gt;getAttributeValueAs&lt; String &gt;( &quot;ic&quot; ) );
+    //------------------------------------------------------
+    void XODEParser::readJoint( const NodeSharedPtr pJointNode,
+	    const String&amp; parent,
+	    const Transform&amp; rParentTransform )
+    {
+	JointDesc desc;
+	desc.parentName_ = parent;
+	desc.transform_ = rParentTransform;
 
-				rIndices.push_back( ia );
-				rIndices.push_back( ib );
-				rIndices.push_back( ic );
-			}
-		}
-	}
+	// reading joint... creating description.
 
-	//------------------------------------------------------
-	void XODEParser::readJoint( const NodeSharedPtr pJointNode,
-		const String&amp; parent,
-		Transform&amp; rParentTransform )
-	{
-		JointDesc desc;
-		desc.parentName_ = parent;
-		desc.transform_ = rParentTransform;
+	const dom::NodeList&amp; nodes = pJointNode-&gt;getNodes();
+	const String name = pJointNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;name&quot; );
 
-		// reading joint... creating description.
+	desc.name_ = name;
 
-		const dom::NodeList&amp; nodes = pJointNode-&gt;getNodes();
-		String name = pJointNode-&gt;getName();
+	YAKE_LOG( &quot;XODE: reading joint '&quot; + name + &quot;' ...&quot; );
 
-		desc.name_ = name;
+	// Looking for link1
+	NodeHunter link1Hunter( &quot;link1&quot; );
+	NodeListIter iLink1 =
+	    std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), link1Hunter );
 
-		YAKE_LOG( &quot;XODE: reading joint '&quot; + name + &quot;' ...&quot; );
+	String body1Name;
+	// &lt;link1 .. can be omitted. Parent is then considered 
+	// to be the first body.
+	// See .xode description for explanation.
+	if ( iLink1 == nodes.end() )
+	    body1Name = parent;
+	else
+	    body1Name = (*iLink1)-&gt;getAttributeValueAs&lt;String&gt;( &quot;body&quot; );
 
-		// Looking for link2
-		NodeHunter linkHunter( &quot;link2&quot; );
-		NodeListIter iLink =
-			std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), linkHunter );
+	desc.body1_ = body1Name;
 
-		YAKE_ASSERT( iLink != nodes.end() ).error( &quot;2nd body name is not present in joint definition!&quot; );
+	// Looking for link2
+	NodeHunter linkHunter( &quot;link2&quot; );
+	NodeListIter iLink =
+	    std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), linkHunter );
 
-		String body2Name = (*iLink)-&gt;getAttributeValueAs&lt;String&gt;( &quot;body&quot; );
+	YAKE_ASSERT( iLink != nodes.end() ).error( &quot;2nd body name is not present in joint definition!&quot; );
 
-		desc.otherBody_ = body2Name;
+	String body2Name = (*iLink)-&gt;getAttributeValueAs&lt;String&gt;( &quot;body&quot; );
 
-		YAKE_LOG( &quot;XODE: the joint connects two actors:&quot; );
-		YAKE_LOG( &quot;XODE: 1:&quot; + parent );
-		YAKE_LOG( &quot;XODE: 2:&quot; + body2Name );
+	desc.body2_ = body2Name;
 
-		// Looking for transform
-		NodeHunter hunter( &quot;transform&quot; );
-		NodeListIter iTrans =
-			std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), hunter );
+	YAKE_LOG( &quot;XODE: the joint connects two actors:&quot; );
+	YAKE_LOG( &quot;XODE: 1:&quot; + body1Name );
+	YAKE_LOG( &quot;XODE: 2:&quot; + body2Name );
 
-		Transform jointTransform;
-		if ( iTrans != nodes.end() )
-		{
-			YAKE_LOG( &quot;XODE: joint has transform &quot; );
+	// Looking for transform
+	NodeHunter hunter( &quot;transform&quot; );
+	NodeListIter iTrans =
+	    std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), hunter );
 
-			readTransform( *iTrans, jointTransform );
-		}
+	Transform jointTransform;
+	if ( iTrans != nodes.end() )
+	{
+	    YAKE_LOG( &quot;XODE: joint has transform &quot; );
 
-		if ( !rParentTransform.isIdentity() )
-		{
-			jointTransform = jointTransform.getDerivedTransform( rParentTransform );
-		}
+	    readTransform( *iTrans, jointTransform );
+	}
 
-		for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it )
-		{
-			String nodeName = StringUtil::toLowerCase( (*it)-&gt;getName() );
+	if ( !rParentTransform.isIdentity() )
+	{
+	    jointTransform = jointTransform.getDerivedTransform( rParentTransform );
+	}
 
-			IJoint::DescBase* jointDesc = NULL;
+	for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it )
+	{
+	    String nodeName = StringUtil::toLowerCase( (*it)-&gt;getName() );
 
-			YAKE_LOG( &quot;XODE: reading &quot; + nodeName + &quot; now...&quot; );
+	    IJoint::DescBase* jointDesc = NULL;
 
-			if ( nodeName == &quot;ball&quot; )
-			{
-				jointDesc = readBall( *it, jointTransform );
-			}
-			else if ( nodeName == &quot;fixed&quot; )
-			{
-				jointDesc = readFixed( *it, jointTransform );
-			}
-			else if ( nodeName == &quot;hinge&quot; )
-			{
-				jointDesc = readHinge( *it, jointTransform );
-			}
-			else if ( nodeName == &quot;hinge2&quot; )
-			{
-				jointDesc = readHinge2( *it, jointTransform );
-			}
-			else if ( nodeName == &quot;slider&quot; )
-			{
-				jointDesc = readSlider( *it, jointTransform );
-			}
-			else if ( nodeName == &quot;universal&quot; )
-			{
-				jointDesc = readUniversal( *it, jointTransform );
-			}
-			else if ( nodeName == &quot;amotor&quot; )
-			{
-				YAKE_ASSERT( false ).error( &quot;amotor joint type is not supported!&quot; );
-			}
+	    YAKE_LOG( &quot;XODE: reading &quot; + nodeName + &quot; now...&quot; );
 
-			if ( jointDesc != NULL )
-			{
-				desc.joint_.reset( jointDesc );
+	    if ( nodeName == &quot;ball&quot; )
+	    {
+		jointDesc = readBall( *it, jointTransform );
+	    }
+	    else if ( nodeName == &quot;fixed&quot; )
+	    {
+		jointDesc = readFixed( *it, jointTransform );
+	    }
+	    else if ( nodeName == &quot;hinge&quot; )
+	    {
+		jointDesc = readHinge( *it, jointTransform );
+	    }
+	    else if ( nodeName == &quot;hinge2&quot; )
+	    {
+		jointDesc = readHinge2( *it, jointTransform );
+	    }
+	    else if ( nodeName == &quot;slider&quot; )
+	    {
+		jointDesc = readSlider( *it, jointTransform );
+	    }
+	    else if ( nodeName == &quot;universal&quot; )
+	    {
+		jointDesc = readUniversal( *it, jointTransform );
+	    }
+	    else if ( nodeName == &quot;amotor&quot; )
+	    {
+		YAKE_ASSERT( false ).error( &quot;amotor joint type is not supported!&quot; );
+	    }
 
-				sigJoint_( desc );
-			}
-		}
+	    if ( jointDesc != NULL )
+	    {
+		desc.joint_.reset( jointDesc );
 
+		sigJoint_( desc );
+	    }
 	}
 
-	//------------------------------------------------------
-	IJoint::DescBase* XODEParser::readBall( const NodeSharedPtr pJointNode, Transform&amp; rJointTransform )
-	{
-		YAKE_LOG( &quot;XODE: reading ball joint description...&quot; );
+    }
 
-		const dom::NodeList&amp; nodes = pJointNode-&gt;getNodes();
+    //------------------------------------------------------
+    IJoint::DescBase* XODEParser::readBall( const NodeSharedPtr pJointNode, const Transform&amp; rJointTransform )
+    {
+	YAKE_LOG( &quot;XODE: reading ball joint description...&quot; );
 
-		typedef dom::NodeList::const_iterator NodeListIter;
+	const dom::NodeList&amp; nodes = pJointNode-&gt;getNodes();
 
-		// Looking for anchor
-		NodeHunter anchorHunter( &quot;anchor&quot; );
-		NodeListIter iAnchor =
-			std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), anchorHunter );
+	typedef dom::NodeList::const_iterator NodeListIter;
 
-		YAKE_ASSERT( iAnchor != nodes.end() ).error( &quot;Anchor was not defined for ball joint!&quot; );
+	// Looking for anchor
+	NodeHunter anchorHunter( &quot;anchor&quot; );
+	NodeListIter iAnchor =
+	    std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), anchorHunter );
 
-		Vector3 anchor;
+	YAKE_ASSERT( iAnchor != nodes.end() ).error( &quot;Anchor was not defined for ball joint!&quot; );
 
-		readAnchor( *iAnchor, anchor, rJointTransform );
+	math::Vector3 anchor;
 
-		IJoint::DescBase* desc = new IJoint::DescBall( NULL, NULL, anchor );
+	readAnchor( *iAnchor, anchor, rJointTransform );
 
-		YAKE_LOG( &quot;XODE: Finished processing ball joint description.&quot; );
+	IJoint::DescBase* desc = new IJoint::DescBall( NULL, NULL, anchor );
 
-		return desc;
-	}
+	YAKE_LOG( &quot;XODE: Finished processing ball joint description.&quot; );
 
-	//------------------------------------------------------
-	IJoint::DescBase* XODEParser::readFixed( const NodeSharedPtr pJointNode, Transform&amp; rJointTransform )
-	{
-		YAKE_LOG( &quot;Reading fixed joint description...&quot; );
+	return desc;
+    }
 
-		IJoint::DescBase* desc = new IJoint::DescFixed( NULL, NULL );
+    //------------------------------------------------------
+    IJoint::DescBase* XODEParser::readFixed( const NodeSharedPtr pJointNode, const Transform&amp; rJointTransform )
+    {
+	YAKE_LOG( &quot;Reading fixed joint description...&quot; );
 
-		YAKE_LOG( &quot;Finished processing fixed joint description.&quot; );
+	IJoint::DescBase* desc = new IJoint::DescFixed( NULL, NULL );
 
-		return desc;
-	}
+	YAKE_LOG( &quot;Finished processing fixed joint description.&quot; );
 
-	//------------------------------------------------------
-	IJoint::DescBase* XODEParser::readHinge( const NodeSharedPtr pJointNode, Transform&amp; rJointTransform )
-	{
-		YAKE_LOG( &quot;Reading hinge joint description...&quot; );
+	return desc;
+    }
 
-		const dom::NodeList&amp; nodes = pJointNode-&gt;getNodes();
+    //------------------------------------------------------
+    IJoint::DescBase* XODEParser::readHinge( const NodeSharedPtr pJointNode, const Transform&amp; rJointTransform )
+    {
+	YAKE_LOG( &quot;Reading hinge joint description...&quot; );
 
-		// Looking for anchor
-		NodeHunter anchorHunter( &quot;anchor&quot; );
-		NodeListIter iAnchor =
-			std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), anchorHunter );
+	const dom::NodeList&amp; nodes = pJointNode-&gt;getNodes();
 
-		YAKE_ASSERT( iAnchor != nodes.end() ).error( &quot;Anchor was not defined for hinge joint!&quot; );
+	// Looking for anchor
+	NodeHunter anchorHunter( &quot;anchor&quot; );
+	NodeListIter iAnchor =
+	    std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), anchorHunter );
 
-		// Looking for axis
-		NodeHunter axisHunter( &quot;axis&quot; );
-		NodeListIter iAxis =
-			std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), axisHunter );
+	YAKE_ASSERT( iAnchor != nodes.end() ).error( &quot;Anchor was not defined for hinge joint!&quot; );
 
-		YAKE_ASSERT( iAxis != nodes.end() ).error( &quot;Axis was not defined for hinge joint!&quot; );
+	// Looking for axis
+	NodeHunter axisHunter( &quot;axis&quot; );
+	NodeListIter iAxis =
+	    std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), axisHunter );
 
-		Vector3 anchor;
-		Vector3 axis;
+	YAKE_ASSERT( iAxis != nodes.end() ).error( &quot;Axis was not defined for hinge joint!&quot; );
 
-		readAnchor( *iAnchor, anchor, rJointTransform );
-		readAxis( *iAxis, axis, rJointTransform );
+	math::Vector3 anchor;
+	math::Vector3 axis;
 
-		IJoint::DescBase* desc = new IJoint::DescHinge( NULL, NULL, axis, anchor );
+	readAnchor( *iAnchor, anchor, rJointTransform );
+	readAxis( *iAxis, axis, rJointTransform );
 
-		YAKE_LOG( &quot;Finished processing hinge joint description.&quot; );
+	IJoint::DescBase* desc = new IJoint::DescHinge( NULL, NULL, axis, anchor );
 
-		return desc;
-	}
+	YAKE_LOG( &quot;Finished processing hinge joint description.&quot; );
 
-	//------------------------------------------------------
-	IJoint::DescBase* XODEParser::readHinge2( const NodeSharedPtr pJointNode, Transform&amp; rJointTransform )
-	{
-		YAKE_LOG( &quot;Reading hinge2 joint description...&quot; );
+	return desc;
+    }
 
-		const dom::NodeList&amp; nodes = pJointNode-&gt;getNodes();
+    //------------------------------------------------------
+    IJoint::DescBase* XODEParser::readHinge2( const NodeSharedPtr pJointNode, const Transform&amp; rJointTransform )
+    {
+	YAKE_LOG( &quot;Reading hinge2 joint description...&quot; );
 
-		// Looking for anchor
-		NodeHunter anchorHunter( &quot;anchor&quot; );
-		NodeListIter iAnchor =
-			std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), anchorHunter );
+	const dom::NodeList&amp; nodes = pJointNode-&gt;getNodes();
 
-		YAKE_ASSERT( iAnchor != nodes.end() ).error( &quot;Anchor was not defined for hinge2 joint!&quot; );
+	// Looking for anchor
+	NodeHunter anchorHunter( &quot;anchor&quot; );
+	NodeListIter iAnchor =
+	    std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), anchorHunter );
 
-		// Looking for axis
-		NodeHunter axisHunter( &quot;axis&quot; );
-		NodeListIter iAxis0 =
-			std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), axisHunter );
+	YAKE_ASSERT( iAnchor != nodes.end() ).error( &quot;Anchor was not defined for hinge2 joint!&quot; );
 
-		YAKE_ASSERT( iAxis0 != nodes.end() ).error( &quot;Axis0 was not defined for hinge2 joint!&quot; );
+	// Looking for axis
+	NodeHunter axisHunter( &quot;axis&quot; );
+	NodeListIter iAxis0 =
+	    std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), axisHunter );
 
-		NodeListIter iAxis1 =
-			std::find_if&lt;NodeListIter, NodeHunter&gt;( iAxis0 + 1, nodes.end(), axisHunter );
+	YAKE_ASSERT( iAxis0 != nodes.end() ).error( &quot;Axis0 was not defined for hinge2 joint!&quot; );
 
-		YAKE_ASSERT( iAxis1 != nodes.end() ).error( &quot;Axis1 was not defined for hinge2 joint!&quot; );
+	NodeListIter iAxis1 =
+	    std::find_if&lt;NodeListIter, NodeHunter&gt;( iAxis0 + 1, nodes.end(), axisHunter );
 
-		Vector3 anchor;
-		Vector3 axis0;
-		Vector3 axis1;
+	YAKE_ASSERT( iAxis1 != nodes.end() ).error( &quot;Axis1 was not defined for hinge2 joint!&quot; );
 
-		readAnchor( *iAnchor, anchor, rJointTransform );
-		readAxis( *iAxis0, axis0, rJointTransform );
-		readAxis( *iAxis1, axis1, rJointTransform );
+	math::Vector3 anchor;
+	math::Vector3 axis0;
+	math::Vector3 axis1;
 
-		IJoint::DescBase* desc = new IJoint::DescHinge2( NULL, NULL, axis0, axis1, anchor );
+	readAnchor( *iAnchor, anchor, rJointTransform );
+	readAxis( *iAxis0, axis0, rJointTransform );
+	readAxis( *iAxis1, axis1, rJointTransform );
 
-		YAKE_LOG( &quot;XODE: finished processing hinge2 joint description.&quot; );
+	IJoint::DescBase* desc = new IJoint::DescHinge2( NULL, NULL, axis0, axis1, anchor );
 
-		return desc;
-	}
+	YAKE_LOG( &quot;XODE: finished processing hinge2 joint description.&quot; );
 
-	//------------------------------------------------------
-	IJoint::DescBase* XODEParser::readSlider( const NodeSharedPtr pJointNode, Transform&amp; rJointTransform )
-	{
-		YAKE_LOG( &quot;XODE: reading slider joint description...&quot; );
+	return desc;
+    }
 
-		const dom::NodeList&amp; nodes = pJointNode-&gt;getNodes();
+    //------------------------------------------------------
+    IJoint::DescBase* XODEParser::readSlider( const NodeSharedPtr pJointNode, const Transform&amp; rJointTransform )
+    {
+	YAKE_LOG( &quot;XODE: reading slider joint description...&quot; );
 
-		// Looking for axis
-		NodeHunter axisHunter( &quot;axis&quot; );
-		NodeListIter iAxis =
-			std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), axisHunter );
+	const dom::NodeList&amp; nodes = pJointNode-&gt;getNodes();
 
-		YAKE_ASSERT( iAxis != nodes.end() ).error( &quot;Axis was not defined for slider joint!&quot; );
+	// Looking for axis
+	NodeHunter axisHunter( &quot;axis&quot; );
+	NodeListIter iAxis =
+	    std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), axisHunter );
 
-		Vector3 axis;
+	YAKE_ASSERT( iAxis != nodes.end() ).error( &quot;Axis was not defined for slider joint!&quot; );
 
-		readAxis( *iAxis, axis, rJointTransform );
+	math::Vector3 axis;
 
-		IJoint::DescBase* desc = new IJoint::DescSlider( NULL, NULL, axis );
+	readAxis( *iAxis, axis, rJointTransform );
 
-		YAKE_LOG( &quot;XODE: finished processing slider joint description.&quot; );
+	IJoint::DescBase* desc = new IJoint::DescSlider( NULL, NULL, axis );
 
-		return desc;
-	}
+	YAKE_LOG( &quot;XODE: finished processing slider joint description.&quot; );
 
-	//------------------------------------------------------
-	IJoint::DescBase* XODEParser::readUniversal( const NodeSharedPtr pJointNode, Transform&amp; rJointTransform )
-	{
-		YAKE_LOG( &quot;XODE: reading universal joint description...&quot; );
+	return desc;
+    }
 
-		const dom::NodeList&amp; nodes = pJointNode-&gt;getNodes();
+    //------------------------------------------------------
+    IJoint::DescBase* XODEParser::readUniversal( const NodeSharedPtr pJointNode, const Transform&amp; rJointTransform )
+    {
+	YAKE_LOG( &quot;XODE: reading universal joint description...&quot; );
 
-		// Looking for anchor
-		NodeHunter anchorHunter( &quot;anchor&quot; );
-		NodeListIter iAnchor =
-			std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), anchorHunter );
+	const dom::NodeList&amp; nodes = pJointNode-&gt;getNodes();
 
-		YAKE_ASSERT( iAnchor != nodes.end() ).error( &quot;Anchor was not defined for universal joint!&quot; );
+	// Looking for anchor
+	NodeHunter anchorHunter( &quot;anchor&quot; );
+	NodeListIter iAnchor =
+	    std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), anchorHunter );
 
-		// Looking for axis
-		NodeHunter axisHunter( &quot;axis&quot; );
-		NodeListIter iAxis0 =
-			std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), axisHunter );
+	YAKE_ASSERT( iAnchor != nodes.end() ).error( &quot;Anchor was not defined for universal joint!&quot; );
 
-		YAKE_ASSERT( iAxis0 != nodes.end() ).error( &quot;Axis0 was not defined for universal joint!&quot; );
+	// Looking for axis
+	NodeHunter axisHunter( &quot;axis&quot; );
+	NodeListIter iAxis0 =
+	    std::find_if&lt;NodeListIter, NodeHunter&gt;( nodes.begin(), nodes.end(), axisHunter );
 
-		NodeListIter iAxis1 =
-			std::find_if&lt;NodeListIter, NodeHunter&gt;( iAxis0 + 1, nodes.end(), axisHunter );
+	YAKE_ASSERT( iAxis0 != nodes.end() ).error( &quot;Axis0 was not defined for universal joint!&quot; );
 
-		YAKE_ASSERT( iAxis1 != nodes.end() ).error( &quot;Axis1 was not defined for universal joint!&quot; );
+	NodeListIter iAxis1 =
+	    std::find_if&lt;NodeListIter, NodeHunter&gt;( iAxis0 + 1, nodes.end(), axisHunter );
 
-		Vector3 anchor;
-		Vector3 axis0;
-		Vector3 axis1;
+	YAKE_ASSERT( iAxis1 != nodes.end() ).error( &quot;Axis1 was not defined for universal joint!&quot; );
 
-		readAnchor( *iAnchor, anchor, rJointTransform );
-		readAxis( *iAxis0, axis0, rJointTransform );
-		readAxis( *iAxis1, axis1, rJointTransform );
+	math::Vector3 anchor;
+	math::Vector3 axis0;
+	math::Vector3 axis1;
 
-		IJoint::DescBase* desc = new IJoint::DescUniversal( NULL, NULL, axis0, axis1, anchor );
+	readAnchor( *iAnchor, anchor, rJointTransform );
+	readAxis( *iAxis0, axis0, rJointTransform );
+	readAxis( *iAxis1, axis1, rJointTransform );
 
-		YAKE_LOG( &quot;XODE: finished processing universal joint description.&quot; );
+	IJoint::DescBase* desc = new IJoint::DescUniversal( NULL, NULL, axis0, axis1, anchor );
 
-		return desc;
-	}
+	YAKE_LOG( &quot;XODE: finished processing universal joint description.&quot; );
 
-	//------------------------------------------------------
-	void XODEParser::readAnchor( const NodeSharedPtr pAnchorNode,
-		Vector3&amp; rAnchor,
-		Transform&amp; rJointTransform )
-	{
-		YAKE_LOG( &quot;XODE: reading anchor...&quot; );
+	return desc;
+    }
 
-		rAnchor.x = StringUtil::parseReal( pAnchorNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;x&quot; ) );
-		rAnchor.y = StringUtil::parseReal( pAnchorNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;y&quot; ) );
-		rAnchor.z = StringUtil::parseReal( pAnchorNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;z&quot; ) );
+    //------------------------------------------------------
+    void XODEParser::readAnchor( const NodeSharedPtr pAnchorNode,
+	    math::Vector3&amp; rAnchor,
+	    const Transform&amp; rJointTransform )
+    {
+	YAKE_LOG( &quot;XODE: reading anchor...&quot; );
 
-		rAnchor = rJointTransform.position_ + rJointTransform.rotation_*( rJointTransform.scale_*rAnchor );
-	}
+	rAnchor.x = StringUtil::parseReal( pAnchorNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;x&quot; ) );
+	rAnchor.y = StringUtil::parseReal( pAnchorNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;y&quot; ) );
+	rAnchor.z = StringUtil::parseReal( pAnchorNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;z&quot; ) );
 
-	//------------------------------------------------------
-	void XODEParser::readAxis(	const NodeSharedPtr pAxisNode,
-		Vector3&amp; rAxis,
-		Transform&amp; rJointTransform )
-	{
-		YAKE_LOG( &quot;XODE: reading axis...&quot; );
+	rAnchor = rJointTransform.position_ + rJointTransform.rotation_*( rJointTransform.scale_*rAnchor );
+    }
 
-		rAxis.x = StringUtil::parseReal( pAxisNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;x&quot; ) );
-		rAxis.y = StringUtil::parseReal( pAxisNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;y&quot; ) );
-		rAxis.z = StringUtil::parseReal( pAxisNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;z&quot; ) );
+    //------------------------------------------------------
+    void XODEParser::readAxis(	const NodeSharedPtr pAxisNode,
+	    math::Vector3&amp; rAxis,
+	    const Transform&amp; rJointTransform )
+    {
+	YAKE_LOG( &quot;XODE: reading axis...&quot; );
 
-		/// TODO What about all other axis params?
+	rAxis.x = StringUtil::parseReal( pAxisNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;x&quot; ) );
+	rAxis.y = StringUtil::parseReal( pAxisNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;y&quot; ) );
+	rAxis.z = StringUtil::parseReal( pAxisNode-&gt;getAttributeValueAs&lt;String&gt;( &quot;z&quot; ) );
 
-		rAxis = rJointTransform.rotation_*rAxis;
-	}
+	/// TODO What about all other axis params?
 
+	rAxis = rJointTransform.rotation_*rAxis;
+    }
+
 } //xode
 } //parser
 } //data

Modified: trunk/yake/src/yapp/model/Makefile.am
===================================================================
--- trunk/yake/src/yapp/model/Makefile.am	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/model/Makefile.am	2006-03-19 17:54:00 UTC (rev 1302)
@@ -3,5 +3,6 @@
 
 lib_LTLIBRARIES = libyappModel.la
 libyappModel_la_SOURCES = yakeComplexModel.cpp yakeGraphical.cpp \
-	yakePhysical.cpp yakeActor.cpp yakeModelLink.cpp yakeModelMovableLink.cpp
+		yakePhysical.cpp yakeActor.cpp yakeModelLink.cpp yakeModelMovableLink.cpp \
+	yakeGraphicalDataImporter.cpp yakePhysicalDataImporter.cpp
 libyappModel_la_LIBADD = $(top_builddir)/src/yapp/loader/libyappLoader.la

Modified: trunk/yake/src/yapp/model/yakeComplexModel.cpp
===================================================================
--- trunk/yake/src/yapp/model/yakeComplexModel.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/model/yakeComplexModel.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -187,17 +187,23 @@
 		YAKE_ASSERT( pTarget );
 		if (!pSource || !pTarget)
 			return 0;
-		ModelMovableLink* pLink = 0;
+
+		ModelMovableLink* pLink = NULL;
 		MovableLinkMap::iterator itFind = mMovableLinkMap.find( pSource );
-		if (itFind == mMovableLinkMap.end())
+		
+		if (itFind != mMovableLinkMap.end())
 		{
+			YAKE_LOG_INFORMATION( &quot;It seems that link already exists. Trying to determine...&quot; );
+			pLink = dynamic_cast&lt;ModelMovableLink*&gt;( itFind-&gt;second );
+		}
+		
+		if ( pLink == NULL )
+		{
 			pLink = new ModelMovableLink();
 			pLink-&gt;setSource( pSource );
 			mMovableLinkMap.insert( std::make_pair(pSource,pLink) );
 			mControllers.push_back( SharedPtr&lt;IObjectController&gt;(pLink) );
 		}
-		else
-			pLink = itFind-&gt;second;
 		
 		pLink-&gt;subscribeToPositionChanged( pTarget );
 		pLink-&gt;subscribeToOrientationChanged( pTarget );
@@ -206,13 +212,61 @@
 	}
 
 	//-----------------------------------------------------
+	ModelMovableWorldLink* Model::addWorldLink( Movable* pSource, Movable* pTarget )
+	{
+		YAKE_ASSERT( pSource != NULL ).warning( &quot;Source movable doesn't exist&quot; );
+		YAKE_ASSERT( pTarget != NULL ).warning( &quot;Target movable doesn't exist&quot; );
+
+		if (!pSource || !pTarget)
+			return 0;
+
+		ModelMovableWorldLink* pLink = NULL;
+		MovableLinkMap::iterator itFind = mMovableLinkMap.find( pSource );
+		
+		if ( itFind != mMovableLinkMap.end() )
+		{
+			YAKE_LOG_INFORMATION( &quot;It seems that link already exists. Trying to determine...&quot; );
+			pLink = dynamic_cast&lt;ModelMovableWorldLink*&gt;( itFind-&gt;second );
+		}
+		
+		if ( pLink == NULL )
+		{
+			YAKE_LOG_INFORMATION( &quot;This is new link. Creating.&quot; );
+
+			pLink = new ModelMovableWorldLink();
+			pLink-&gt;setSource( pSource );
+			mMovableLinkMap.insert( std::make_pair(pSource,pLink) );
+			mControllers.push_back( SharedPtr&lt;IObjectController&gt;(pLink) );
+
+			YAKE_LOG_INFORMATION( &quot;Controller created.&quot; );
+		}
+		
+		YAKE_LOG_INFORMATION( &quot;Subscribing to controller signals...&quot; );
+
+		pLink-&gt;subscribeToPositionChanged( pTarget );
+		pLink-&gt;subscribeToOrientationChanged( pTarget );
+
+		YAKE_LOG_INFORMATION( &quot;Done. Link setup.&quot; );
+		return pLink;
+	}
+
+	//-----------------------------------------------------
 	void Model::updatePhysics( real timeElapsed )
 	{
+	    // updating all body affectors applied to all physicals...
+	    PhysicalMap::iterator ph_end = mPhysicals.end();
+	    for( PhysicalMap::iterator ph = mPhysicals.begin(); ph != ph_end; ++ph )
+	    {
+		ph-&gt;second-&gt;updateAffectors( timeElapsed );
+	    }
 	}
 	
 	//-----------------------------------------------------
 	void Model::updateGraphics( real timeElapsed )
 	{
+		// FIXME this assumes model does have only graphics controllers!
+		// So should there be some separate updateControllers method?
+		//
 		for (CtrlrList::const_iterator it = mControllers.begin(); it != mControllers.end(); ++it)
 		{
 			(*it)-&gt;update( timeElapsed );
@@ -222,3 +276,4 @@
 } // ns complex
 } // ns model
 } // ns yake
+

Modified: trunk/yake/src/yapp/model/yakeModelMovableLink.cpp
===================================================================
--- trunk/yake/src/yapp/model/yakeModelMovableLink.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/model/yakeModelMovableLink.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -37,16 +37,24 @@
 	{
 	}
 	SignalConnection ModelMovableLink::subscribeToPositionChanged( Movable* pMovable )
-	{
+	{	
+		const Vector3 srcPos = getSource()-&gt;getPosition();
+		pMovable-&gt;setPosition( srcPos );
+
 		return mPositionSignal.connect( Bind1( &amp;Movable::setPosition, pMovable ) );
 	}
+
 	SignalConnection ModelMovableLink::subscribeToOrientationChanged( Movable* pMovable )
 	{
+		const Quaternion srcOrientation = getSource()-&gt;getOrientation();
+		pMovable-&gt;setOrientation( srcOrientation );
+
 		return mOrientationSignal.connect( Bind1( &amp;Movable::setOrientation, pMovable ) );
 	}
+
 	void ModelMovableLink::update( real timeElapsed )
 	{
-		Movable * pSource = getSource();
+		const Movable* pSource = getSource();
 		YAKE_ASSERT( pSource ).debug(&quot;no update source -&gt; no updates&quot;);
 		if (!pSource)
 			return;
@@ -64,5 +72,48 @@
 		}
 	}
 
+	YAKE_REGISTER_CONCRETE( ModelMovableWorldLink );
+	ModelMovableWorldLink::ModelMovableWorldLink()
+	{
+	}
+	SignalConnection ModelMovableWorldLink::subscribeToPositionChanged( Movable* pMovable )
+	{	
+		const Vector3 srcPos = getSource()-&gt;getDerivedPosition();
+		pMovable-&gt;setPosition( srcPos );
+
+		return mPositionSignal.connect( Bind1( &amp;Movable::setPosition, pMovable ) );
+	}
+
+	SignalConnection ModelMovableWorldLink::subscribeToOrientationChanged( Movable* pMovable )
+	{
+		const Quaternion srcOrientation = getSource()-&gt;getDerivedOrientation();
+		pMovable-&gt;setOrientation( srcOrientation );
+
+		return mOrientationSignal.connect( Bind1( &amp;Movable::setOrientation, pMovable ) );
+	}
+
+	void ModelMovableWorldLink::update( real timeElapsed )
+	{
+		const Movable* pSource = getSource();
+
+		YAKE_ASSERT( pSource ).error(&quot;no update source -&gt; no updates&quot;);
+
+		if ( pSource == NULL )
+			return;
+
+		Vector3 position = pSource-&gt;getDerivedPosition();
+		if (mLastPosition != position)
+		{
+			mPositionSignal( position );
+			mLastPosition = position;
+		}
+		Quaternion orientation = pSource-&gt;getDerivedOrientation();
+		if (mLastOrientation != orientation)
+		{
+			mOrientationSignal( orientation );
+			mLastOrientation = orientation;
+		}
+	}
 }
 }
+

Modified: trunk/yake/src/yapp/model/yakePhysical.cpp
===================================================================
--- trunk/yake/src/yapp/model/yakePhysical.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/model/yakePhysical.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -93,5 +93,34 @@
 			return itFind-&gt;second;
 	}
 
+	//-----------------------------------------------------
+	void Physical::addAffector( SharedPtr&lt;physics::IBodyAffector&gt; pAffector, const String&amp; rName )
+	{
+	    mAffectors.push_back( std::make_pair( rName, pAffector ) );
+	}
+
+	//-----------------------------------------------------
+	void Physical::updateAffectors( real timeElapsed )
+	{
+		AffectorList::iterator aff_end = mAffectors.end();
+		for( AffectorList::iterator af = mAffectors.begin(); af != aff_end; ++af )
+		{
+			physics::IActorPtr actor = getActorByName( (*af).first );
+
+			YAKE_ASSERT( actor != NULL ).warning( &quot;affector refers to non-existent actor&quot; );
+			if ( actor == NULL )
+				continue;
+
+			physics::IBody* body = actor-&gt;getBodyPtr();
+
+			YAKE_ASSERT( body != NULL ).warning( &quot;trying to apply affector to actor without a body&quot; );
+			if ( body != NULL )
+			{
+				(*af).second-&gt;applyTo( *body, timeElapsed );
+			}
+		}
+	}
+
 }
 }
+

Modified: trunk/yake/src/yapp/model/yakePhysicalDataImporter.cpp
===================================================================
--- trunk/yake/src/yapp/model/yakePhysicalDataImporter.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/model/yakePhysicalDataImporter.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -39,6 +39,10 @@
 
 		// create actor
 		physics::IActorPtr pDynActor = physicalWorld_-&gt;createActor( physics::ACTOR_DYNAMIC );
+
+		// we need to zero out the mass..
+		pDynActor-&gt;getBodyPtr()-&gt;setMass( 0 );
+
 		YAKE_ASSERT( pDynActor != NULL ).error( &quot;Failed to create actor!&quot; );
 
 		// set transform. TODO what about scale?
@@ -75,6 +79,8 @@
 		}
 		else
 		{
+			YAKE_LOG( &quot;XODE listener: geom parent not found... creating static actor. &quot; );
+		    
 			// create static actor
 			parentActor = physicalWorld_-&gt;createActor( physics::ACTOR_STATIC );
 
@@ -175,10 +181,11 @@
 
 			// search for connected actors
 
-			YAKE_LOG( &quot;XODE listener: searching for actors [0]: &quot; + desc.parentName_ + &quot;, [1]: &quot; + desc.otherBody_ );
+			YAKE_LOG( &quot;XODE listener: processing &quot; + desc.name_ + &quot; ... &quot; );
+			YAKE_LOG( &quot;XODE listener: searching for actors [0]: &quot; + desc.body1_ + &quot;, [1]: &quot; + desc.body2_ );
 
-			ActorMap::iterator actor0 = actors_.find( desc.parentName_ );
-			ActorMap::iterator actor1 = actors_.find( desc.otherBody_ );
+			ActorMap::iterator actor0 = actors_.find( desc.body1_ );
+			ActorMap::iterator actor1 = actors_.find( desc.body2_ );
 
 			if ( actor0 == actors_.end() || actor1 == actors_.end() )
 			{
@@ -204,3 +211,4 @@
 
 } // model
 } // yake
+

Modified: trunk/yake/src/yapp/plugins/ceguiOgreRendererAdapter/plugin.cpp
===================================================================
--- trunk/yake/src/yapp/plugins/ceguiOgreRendererAdapter/plugin.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/plugins/ceguiOgreRendererAdapter/plugin.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -72,13 +72,24 @@
 		//HACK FIXME getAutoCreatedWindow assumes window was autocreated!
 		Ogre::RenderWindow* pWin = Ogre::Root::getSingleton().getAutoCreatedWindow();
 		YAKE_ASSERT( pWin ).error(&quot;Need a valid render window!&quot;);
+// for Ogre 1.1.0 &quot;Dagon&quot; compatibility
+#if OGRE_VERSION_MINOR &gt;= 1 
+
 		mGUIRenderer = new CEGUI::OgreCEGUIRenderer(
 			pWin, 
 			Ogre::RENDER_QUEUE_OVERLAY, 
 			true, 
 			3000,
+			Ogre::Root::getSingleton().getSceneManager( &quot;YakeSM&quot; ) );
+#else
+		mGUIRenderer = new CEGUI::OgreCEGUIRenderer(
+			pWin, 
+			Ogre::RENDER_QUEUE_OVERLAY, 
+			true, 
+			3000,
 			Ogre::ST_GENERIC );
-			//Ogre::Root::getSingleton()._getCurrentSceneManager());
+#endif
+		
 	} catch (Ogre::Exception&amp; e)
 	{
 		YAKE_EXCEPT(&quot;Failed to initialise CEGUI adapter!\n&quot; + yake::String(e.getFullDescription().c_str()));
@@ -99,3 +110,4 @@
 {
 	return mGUIRenderer;
 }
+

Added: trunk/yake/src/yapp/plugins/terrainPhysMgr/TerrainOdeActor.cpp
===================================================================
--- trunk/yake/src/yapp/plugins/terrainPhysMgr/TerrainOdeActor.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/plugins/terrainPhysMgr/TerrainOdeActor.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -0,0 +1,151 @@
+/*
+ ------------------------------------------------------------------------------------
+ This file is part of YAKE
+ Copyright  2004 The YAKE Team
+ For the latest information visit <A HREF="http://www.yake.org">http://www.yake.org</A> 
+ ------------------------------------------------------------------------------------
+ This program is free software; you can redistribute it and/or modify it under
+ the terms of the GNU Lesser General Public License as published by the Free Software
+ Foundation; either version 2 of the License, or (at your option) any later
+ version.
+
+ This program is distributed in the hope that it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+ You should have received a copy of the GNU Lesser General Public License along with
+ this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+ <A HREF="http://www.gnu.org/copyleft/lesser.txt.">http://www.gnu.org/copyleft/lesser.txt.</A>
+ ------------------------------------------------------------------------------------
+ If you are interested in another license model contact the Yake Team via
+ E-Mail: <A HREF="https://lists.berlios.de/mailman/listinfo/yake-svn">team at yake.org.</A>
+ For more information see the LICENSE file in the root directory of the
+ source code distribution.
+ ------------------------------------------------------------------------------------
+*/
+
+#include &lt;algorithm&gt;
+
+#include &lt;yake/base/yake.h&gt;
+#include &lt;yake/physics/yakePhysicsPrerequisites.h&gt;
+
+#include &lt;yapp/plugins/terrainPhysMgr/TerrainOdeActor.h&gt;
+#include &lt;yapp/plugins/terrainPhysMgr/TerrainOdeShape.h&gt;
+
+namespace yake
+{
+	namespace physics
+	{
+		TerrainCollisionDetectionActor::TerrainCollisionDetectionActor ( OdeWorld* pOdeWorld ) : OdeActor( pOdeWorld, false )
+		{
+			this-&gt;mEnterCollisionSignal.connect( Bind1( &amp;TerrainCollisionDetectionActor::onCollision, this ) );
+		}
+		//------------------------------------------------------------------------------------
+
+		TerrainCollisionDetectionActor::~TerrainCollisionDetectionActor ()
+		{}
+		//------------------------------------------------------------------------------------
+
+		void TerrainCollisionDetectionActor::createTerrainCollisionDetectionShape( const math::Vector3&amp; rDimensions,
+		        const math::Vector3&amp; rPosition, Ogre::PagingLandScapeTileInfo* tileInfo )
+		{
+			OdeTerrainCollisionBox * pBox = new OdeTerrainCollisionBox( mOdeWorld-&gt;_getOdeSpace(),
+			                                this,
+			                                rDimensions.x,
+			                                rDimensions.y,
+			                                rDimensions.z,
+			                                tileInfo );
+
+			pBox-&gt;setPosition( rPosition );
+			pBox-&gt;setOrientation( math::Quaternion::kIdentity );
+
+			//set material NULL for awoiding collisions with this helper shape
+			pBox-&gt;setMaterial( NULL );
+
+			mShapes.push_back( SharedPtr&lt;OdeTerrainCollisionBox&gt;( pBox ) );
+			
+  			std::cerr &lt;&lt; &quot;Tile Ode BOX derived pos = &quot; &lt;&lt; pBox-&gt;getDerivedPosition() &lt;&lt; std::endl;
+			std::cerr &lt;&lt; &quot;Tile Ode BOX pos = &quot; &lt;&lt; pBox-&gt;getPosition()&lt;&lt; std::endl;
+			std::cerr &lt;&lt; &quot;Tile Ode BOX dims = &quot; &lt;&lt; rDimensions &lt;&lt; std::endl;
+			std::cerr &lt;&lt; &quot;--------------------------------\n&quot;;
+		}
+		//------------------------------------------------------------------------------------
+
+		void TerrainCollisionDetectionActor::createTerrainCollisionShape( const math::Vector3&amp; rPosition, TriangleMeshDesc::VertexVector &amp; vertices,
+			TriangleMeshDesc::IndexVector &amp; indexes)
+		{
+			std::cerr&lt;&lt;&quot;Parent SN pos = &quot;&lt;&lt;rPosition&lt;&lt;std::endl;
+			std::cerr&lt;&lt;&quot;vertex number = &quot;&lt;&lt;vertices.size()&lt;&lt;std::endl;
+			std::cerr&lt;&lt;&quot;index number = &quot;&lt;&lt;indexes.size()&lt;&lt;std::endl;
+			
+			TriangleMeshDesc meshDescriptor( vertices, indexes );
+
+			IShape::TriMeshDesc * pTriMeshDesc = new IShape::TriMeshDesc( meshDescriptor );
+
+			TriangleMeshId id = pTriMeshDesc-&gt;trimeshId_;
+
+			// build Triangle mesh by TriMeshDesc
+			if ( id == kTriangleMeshIdNone )
+			{
+				YAKE_LOG(&quot;Creating triangle mesh id&quot;);
+				id = mOdeWorld-&gt;createTriangleMesh( pTriMeshDesc-&gt;trimesh_ );
+				YAKE_ASSERT( id != kTriangleMeshIdNone );
+			}
+			
+ 			OdeTriMesh::MeshData data = mOdeWorld-&gt;getMeshDataById( id );
+				
+			//finaly create ODE trimesh object
+ 			OdeTriMesh * pMesh = new OdeTriMesh( mOdeWorld-&gt;_getOdeSpace(), this, data.id );
+			YAKE_ASSERT( pMesh ).error( &quot;Mesh with such id wasn't found!&quot; );
+			
+			//setting material
+			IMaterial* pMaterial =  this-&gt;getCreator()-&gt;getMaterial( &quot;default&quot; );
+
+ 			OdeMaterial * tmpMaterial = dynamic_cast&lt; OdeMaterial*&gt;( pMaterial);
+			
+			YAKE_ASSERT( tmpMaterial).error( &quot;null material!&quot; );
+
+			pMesh-&gt;setMaterial( tmpMaterial);
+
+			pMesh-&gt;setPosition( rPosition);
+			pMesh-&gt;setOrientation( math::Quaternion::kIdentity );
+
+			mShapes.push_back( SharedPtr&lt;OdeGeom&gt;( pMesh) );
+		}
+		//------------------------------------------------------------------------------------
+
+		void TerrainCollisionDetectionActor::onCollision( const ActorCollisionInfo &amp; collisionInfo )
+		{	
+// 			OdeActor * pA = dynamic_cast&lt;OdeActor*&gt;( collisionInfo.pThis );
+//  			OdeActor * pB = dynamic_cast&lt;OdeActor*&gt;( collisionInfo.pOther );
+			
+// 			std::cerr&lt;&lt;&quot;Actor &quot;&lt;&lt;this-&gt;actorName&lt;&lt;&quot; collided with actor &quot;&lt;&lt;pB-&gt;actorName&lt;&lt;std::endl;
+			
+// 			TerrainCollisionDetectionActor * pA = dynamic_cast&lt;TerrainCollisionDetectionActor*&gt;( collisionInfo.pOther );
+// 			TerrainCollisionDetectionActor * pB = dynamic_cast&lt;TerrainCollisionDetectionActor*&gt;( collisionInfo.pOther );
+			
+// 			if( pA || pB)
+//  			{
+//    				YAKE_LOG(&quot;AutoCollision detected!&quot;);
+//  				return;
+//  			}
+  			
+			OdeTerrainCollisionBox * terrainCollisionBbox = dynamic_cast&lt; OdeTerrainCollisionBox *&gt;( collisionInfo.pThisShape_ );
+
+			if ( terrainCollisionBbox == NULL )
+				terrainCollisionBbox = dynamic_cast&lt; OdeTerrainCollisionBox *&gt;( collisionInfo.pOtherShape_ );
+			if( terrainCollisionBbox == NULL)
+			{
+//    				YAKE_LOG(&quot;Can't get proper collision bbox!&quot; );
+				return;
+			}
+			
+			Ogre::PagingLandScapeTileInfo * tileInfo = terrainCollisionBbox-&gt;getTileInfo();
+
+  			TerrainPhysicsManager::instance().processTile( tileInfo );
+		}
+		//------------------------------------------------------------------------------------
+		
+} // physics
+} // yake

Added: trunk/yake/src/yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.cpp
===================================================================
--- trunk/yake/src/yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -0,0 +1,364 @@
+#include &lt;vector&gt;
+
+#include &lt;yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.h&gt;
+
+#include &lt;yake/base/yake.h&gt;
+#include &lt;yake/plugins/physicsODE/OdeWorld.h&gt;
+#include &lt;yake/plugins/physicsODE/OdeBody.h&gt;
+#include &lt;yake/plugins/physicsODE/OdeActor.h&gt;
+#include &lt;yake/plugins/physicsODE/OdeShapes.h&gt;
+
+#include &lt;yapp/plugins/terrainPhysMgr/TerrainOdeActor.h&gt;
+#include &lt;yapp/plugins/terrainPhysMgr/TerrainOdeShape.h&gt;
+
+#include &lt;yake/plugins/graphicsOgre/yakePCH.h&gt;
+
+#include &quot;OgrePagingLandScapeOptions.h&quot;
+#include &quot;OgrePagingLandScapeListener.h&quot;
+#include &quot;OgrePagingLandScapeTile.h&quot;
+#include &quot;OgrePagingLandScapeTileInfo.h&quot;
+#include &quot;OgrePagingLandScapeIndexBuffer.h&quot;
+#include &quot;OgrePagingLandScapeRenderable.h&quot;
+#include &quot;OgrePagingLandScapeTileManager.h&quot;
+#include &quot;OgrePagingLandScapeRaySceneQuery.h&quot;
+
+using namespace std;
+using namespace Ogre;
+
+namespace yake
+{
+	namespace physics
+	{
+		PLSMTerrainPhysicsManager::PLSMTerrainPhysicsManager( ) :
+				sceneManager ( 0 ), pageLoadListener( 0 ), terrainCollisionDetectionActor( 0 ),  rayQuery(0),
+				graphicsWorld( 0)
+		{}
+		//---------------------------------------------------------------------------------------------
+
+		PLSMTerrainPhysicsManager::~PLSMTerrainPhysicsManager()
+		{
+			sceneManager-&gt;destroyQuery( rayQuery);
+			sceneManager-&gt;setOption( &quot;removeLoadPageListener&quot;, pageLoadListener );
+			odeWorld-&gt;destroyActor( terrainCollisionDetectionActor );
+		}
+		//---------------------------------------------------------------------------------------------
+		
+		void PLSMTerrainPhysicsManager::init( Ogre::PagingLandScapeSceneManager * _sceneManager,
+				IWorld *_odeWorld, graphics::IWorld* _graphicsWorld)
+		{
+			this-&gt;graphicsWorld = _graphicsWorld;
+			
+			YAKE_LOG(&quot;Inititalizing Terrain Physics Manager...&quot;);
+			
+			this-&gt;odeWorld = dynamic_cast&lt;OdeWorld *&gt;( _odeWorld );
+
+			//add to physical world our new terrain actor
+			terrainCollisionDetectionActor = new TerrainCollisionDetectionActor( odeWorld );
+
+			odeWorld-&gt;addActor( terrainCollisionDetectionActor );
+
+			sceneManager = _sceneManager;
+
+			//create PageLoading event listener
+			pageLoadListener = new Ogre::PagingLandscapeDelegate( &amp;( *this ),
+			                   &amp;PLSMTerrainPhysicsManager::pageLoaded );
+
+			tileLoadListener = new Ogre::PagingLandscapeDelegate( &amp;( *this ),
+			                   &amp;PLSMTerrainPhysicsManager::tileLoaded );
+
+			// sceneManager-&gt;setOption( &quot;addLoadPageListener&quot;, pageLoadListener );
+			sceneManager-&gt;setOption( &quot;addLoadTileListener&quot;, tileLoadListener );
+			
+			rayQuery = sceneManager-&gt;createRayQuery( Ogre::Ray(Ogre::Vector3::ZERO, Ogre::Vector3::NEGATIVE_UNIT_Y));
+			
+			YAKE_ASSERT( rayQuery);
+		}
+		//---------------------------------------------------------------------------------------------
+
+		void PLSMTerrainPhysicsManager::tileLoaded( Ogre::PagingLandscapeEvent* event )
+		{
+			YAKE_LOG(&quot;Tile loaded event handler entered...&quot;);
+			//recover PLSM2's tile object
+			int pageX = event-&gt;mPagex;
+			int pageZ = event-&gt;mPagez;
+
+			Ogre::PagingLandScapePage * page = sceneManager-&gt;getPageManager()-&gt;getPage( pageX, pageZ );
+
+			PagingLandScapeTile * tile = page-&gt;getTile( event-&gt;mTilex, event-&gt;mTilez );
+
+			createCollisionBoundingBox( tile );
+		}
+		//---------------------------------------------------------------------------------------------
+
+		void PLSMTerrainPhysicsManager::pageLoaded( Ogre::PagingLandscapeEvent* event )
+		{
+			YAKE_LOG(&quot;Page loaded event handler entered...&quot;);
+			//recover PLSM2's tile object
+			int pageX = event-&gt;mPagex;
+			int pageZ = event-&gt;mPagez;
+			Ogre::PagingLandScapePage * page = sceneManager-&gt;getPageManager()-&gt;getPage( pageX, pageZ );
+
+			processAllTilesInPage( page, pageX, pageZ );
+		}
+		//---------------------------------------------------------------------------------------------
+
+		void PLSMTerrainPhysicsManager::processAllTilesInPage( Ogre::PagingLandScapePage * page, int pageX, int pageZ )
+		{
+			int tileQuantity = sceneManager-&gt;getOptions()-&gt;NumTiles;
+
+			PagingLandScapeTile * tile = 0;
+
+			for ( int i = 0; i &lt; tileQuantity; ++i )
+			{
+				for ( int j = 0; j &lt; tileQuantity; ++j )
+				{
+					tile = page-&gt;getTile( i, j );
+
+					createCollisionBoundingBox( tile );
+				}
+			}
+		}
+		//---------------------------------------------------------------------------------------------
+
+		void PLSMTerrainPhysicsManager::createCollisionBoundingBox( Ogre::PagingLandScapeTile* tile )
+		{
+ 			if ( find( alreadyLoadedCollisionDetectionTiles.begin(), alreadyLoadedCollisionDetectionTiles.end(), tile ) !=
+						 alreadyLoadedCollisionDetectionTiles.end() )
+ 				return;
+ 			else
+ 				alreadyLoadedCollisionDetectionTiles.push_back( tile);
+
+			Ogre::AxisAlignedBox tileBbox = tile-&gt;getWorldBbox();
+
+			Ogre::Vector3 tmpVector = tileBbox.getMaximum() - tileBbox.getMinimum();
+			math::Vector3 bboxDims = VEC_OGRE2YAKE( tmpVector );
+			
+			tmpVector = tile-&gt;getCenter();
+ 			math::Vector3 bboxCenter = VEC_OGRE2YAKE( tmpVector );
+  			
+ 			terrainCollisionDetectionActor -&gt;createTerrainCollisionDetectionShape( bboxDims, bboxCenter, tile-&gt;getInfo() );
+			
+			 ///uncoment to create a tile visual BBox
+			if( graphicsWorld != 0)
+			{
+				graphics::ISceneNode* pTerrainSN = graphicsWorld-&gt;createSceneNode();
+	
+				graphics::IEntity* pTerrainE = graphicsWorld-&gt;createEntity( &quot;box_1x1x1.mesh&quot; );
+	
+				pTerrainE-&gt;setMaterial(&quot;box&quot;);
+	
+				pTerrainSN-&gt;attachEntity( pTerrainE );
+	
+				pTerrainSN-&gt;setScale( bboxDims );
+	
+				pTerrainSN-&gt;setPosition( bboxCenter );
+	
+				model::Graphical* pG = new model::Graphical();
+				
+				pG-&gt;addSceneNode( pTerrainSN );
+			}
+		}
+		//---------------------------------------------------------------------------------------------
+
+		void PLSMTerrainPhysicsManager::convertIndexDataForOde( Ogre::IndexData* indexData, TriangleMeshDesc::IndexVector &amp;
+			destBuffer) 
+		{
+			// code snipet from OgreOde project
+			Ogre::HardwareIndexBufferSharedPtr ibuf = indexData-&gt;indexBuffer;
+			
+			bool use32bitindexes = ( ibuf-&gt;getType() == Ogre::HardwareIndexBuffer::IT_32BIT);
+			
+			unsigned short* pShort = 0;
+			unsigned int* pInt = 0;
+
+			if (use32bitindexes) 
+				pInt = static_cast&lt;unsigned int*&gt;(ibuf-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY));
+			else 
+				pShort = static_cast&lt;unsigned short*&gt;(ibuf-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY));
+
+			size_t numTris = indexData-&gt;indexCount / 3;
+			size_t index_offset = 0;
+			
+			destBuffer.resize( indexData-&gt;indexCount);
+						
+			for( size_t k = 0; k &lt; numTris; ++k)
+			{
+				unsigned int vindex = use32bitindexes? *pInt++ : *pShort++;
+				destBuffer[index_offset + 0] = vindex;
+				
+				vindex = use32bitindexes? *pInt++ : *pShort++;
+				destBuffer[index_offset + 1] = vindex;
+				
+				vindex = use32bitindexes? *pInt++ : *pShort++;
+				destBuffer[index_offset + 2] = vindex;
+
+				index_offset += 3;
+			}
+			
+			ibuf-&gt;unlock();
+		}
+		//------------------------------------------------------------------------------------
+
+		class OdeVertexConverter
+		{
+			public:
+				OdeVertexConverter( Ogre::Vector3 &amp; parentSNPosition) : pSN( parentSNPosition) {};
+				
+				math::Vector3 operator()( const Ogre::Vector3 &amp; val)
+				{
+					Ogre::Vector3 result = val - pSN;
+					
+					return VEC_OGRE2YAKE( result);
+				}
+				//------------------------------------------------------------------------------------
+
+			protected:
+				Ogre::Vector3 pSN;
+		};
+		//------------------------------------------------------------------------------------
+
+		void PLSMTerrainPhysicsManager::processTile( Ogre::PagingLandScapeTileInfo * tileInfo )
+		{
+			Ogre::PagingLandScapePage * page = 
+					sceneManager-&gt;getPageManager()-&gt;getPage( tileInfo-&gt;pageX, tileInfo-&gt;pageZ );
+
+			YAKE_ASSERT( page ).error( &quot;Page pointer is invalid!&quot; );
+
+			Ogre::PagingLandScapeTile * tile = page-&gt;getTile( tileInfo-&gt;tileX, tileInfo-&gt;tileZ ) ;
+
+			YAKE_ASSERT( tile ).error( &quot;Tile pointer is invalid!&quot; );
+
+ 			if ( find( alreadyLoadedCollisionTiles.begin(), alreadyLoadedCollisionTiles.end(), tile ) !=
+				alreadyLoadedCollisionTiles.end() )
+ 				return; // nothing to be done because tile already processed 
+ 			else
+			{
+// 				YAKE_LOG( ( &quot;---&gt;&gt;&gt;&gt;Got new tile for creating ode trimesh&lt;&lt;&lt;&lt;---&quot; ) );
+// 				std::cerr &lt;&lt; &quot;Page ( &quot; &lt;&lt; tileInfo-&gt;pageX &lt;&lt; &quot;, &quot; &lt;&lt; tileInfo-&gt;pageZ &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+// 				std::cerr &lt;&lt; &quot;Tile ( &quot; &lt;&lt; tileInfo-&gt;tileX &lt;&lt; &quot;, &quot; &lt;&lt; tileInfo-&gt;tileZ &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+
+				alreadyLoadedCollisionTiles.push_back( tile );
+			}
+			
+			Ogre::PagingLandScapeRenderable* rend = tile-&gt;getRenderable();
+
+			YAKE_ASSERT( rend ).error( &quot;Renderable pointer is invalid!&quot; );
+
+			vector&lt; void*&gt; params;
+			int renderLevel = 0;
+
+			params.push_back( &amp;tileInfo-&gt;pageX );
+			params.push_back( &amp;tileInfo-&gt;pageZ );
+			params.push_back( &amp;tileInfo-&gt;tileX );
+			params.push_back( &amp;tileInfo-&gt;tileZ );
+			params.push_back( &amp;renderLevel );
+
+			sceneManager-&gt;getOption( &quot;PageGetTileVertexData_2&quot;, &amp;params );
+			
+			//get tile parenent SN position
+			Ogre::SceneNode * sceneNode = tile-&gt;getSceneNode();
+			Ogre::Vector3 parentSNPosition = sceneNode-&gt;getWorldPosition();
+		
+			// get vertices
+			int * numVtx = ( ( int* ) params[ 5 ] );
+			Ogre::Vector3 * ogreVertices = ( ( Ogre::Vector3* ) params[ 6 ] );
+			
+			TriangleMeshDesc::VertexVector vertices( *numVtx, math::Vector3( 0, 0, 0 ) );
+			
+			std::transform( ogreVertices, ogreVertices + *numVtx, vertices.begin(), OdeVertexConverter( parentSNPosition) );
+
+			// get  indexes
+			Ogre::IndexData* indexData = ( ( Ogre::IndexData* ) params[ 7 ] );
+			YAKE_ASSERT( indexData-&gt;indexCount).error( &quot;There is no indexes!&quot;);
+			
+			TriangleMeshDesc::IndexVector indexes;
+			convertIndexDataForOde( indexData, indexes);
+					
+			terrainCollisionDetectionActor-&gt;createTerrainCollisionShape( VEC_OGRE2YAKE( parentSNPosition), vertices, indexes);
+			
+			delete[] ogreVertices;
+		}
+		//------------------------------------------------------------------------------------
+		
+		real PLSMTerrainPhysicsManager::getHeightAt( const math::Vector3&amp; position)
+		{
+			return getHeightAt( VEC_YAKE2OGRE( position));
+		}
+		//------------------------------------------------------------------------------------
+		
+		real PLSMTerrainPhysicsManager::getHeightAt( const Ogre::Vector3&amp; position)
+		{
+			// register ray query for getHeightAt function
+			ray.setOrigin( position);
+			ray.setDirection( Ogre::Vector3::UNIT_Y);
+	
+			rayQuery-&gt;setRay( ray);
+			rayQuery-&gt;setQueryMask( Ogre::RSQ_Height);
+			
+			Ogre::RaySceneQueryResult &amp; result = rayQuery-&gt;execute(); 
+			Ogre::RaySceneQueryResult::iterator i = result.begin(); 
+ 			
+			Ogre::Real terrainHeight;
+			
+			if (i != result.end() &amp;&amp; i-&gt;worldFragment) 
+				terrainHeight = i-&gt;worldFragment-&gt;singleIntersection.y;
+			
+			std::cerr&lt;&lt;&quot;Terrain Height  =  &quot;&lt;&lt; terrainHeight;
+			
+			return position.y - terrainHeight;//helperQueryListener.heightAt;
+		}
+		//------------------------------------------------------------------------------------
+
+		Ogre::AxisAlignedBox PLSMTerrainPhysicsManager::calcActorAABB(  IActor * _actor)
+		{
+			OdeActor * actor = dynamic_cast&lt;OdeActor * &gt;( _actor);
+			YAKE_ASSERT( actor).error( &quot;Wrong actor type - expected OdeActor...&quot;);
+			
+			IShapePtrList shapesList = actor-&gt;getShapes();
+			
+			ConstDequeIterator&lt; IShapePtrList&gt; itShape( shapesList );
+
+			Ogre::AxisAlignedBox resultAABB;
+			
+			// iterate over all shapes and found their containing AABB
+			while (itShape.hasMoreElements())
+			{
+				const physics::IShapePtr pShape = itShape.getNext();
+			
+				OdeGeom * odeGeom = dynamic_cast&lt;OdeGeom*&gt;( pShape);
+				YAKE_ASSERT( odeGeom).error( &quot;Wrong shape type - expected OdeGeom...&quot;);
+				
+				dGeomID odeGeomID = odeGeom-&gt;_getOdeGeomID();
+				
+				dReal odeAABB[6];
+				dGeomGetAABB( odeGeomID, odeAABB); // catch ODE AABB
+				
+				Ogre::AxisAlignedBox  ogreAABB( odeAABB[0], odeAABB[2], odeAABB[4], //mx, my, mz 
+						odeAABB[1], odeAABB[3], odeAABB[5]); //Mx, My, Mz
+				
+				resultAABB.merge( ogreAABB);
+			}
+			return resultAABB;
+		}
+		//------------------------------------------------------------------------------------
+
+		void PLSMTerrainPhysicsManager::placeActorOnTerrain( const math::Vector3 &amp; position, IActor * _actor)
+		{
+			//Actualy, on the ground we will place actor AABB 
+			Ogre::AxisAlignedBox actorAABB = calcActorAABB( _actor) ; 
+			
+			Ogre::Vector3 actorPosition = actorAABB.getCenter();
+			
+			Ogre::Vector3 actorDims = actorAABB.getMaximum() - actorAABB.getMinimum();
+			
+			real terrainHeightAtActorPos = getHeightAt( actorPosition);
+			
+			actorPosition.y -= terrainHeightAtActorPos;
+			actorPosition.y += actorDims.y / 2.0;
+			
+			_actor-&gt;setPosition( VEC_OGRE2YAKE( actorPosition));
+		}
+		//------------------------------------------------------------------------------------
+
+	}
+}

Modified: trunk/yake/src/yapp/raf/yakeApplication.cpp
===================================================================
--- trunk/yake/src/yapp/raf/yakeApplication.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/raf/yakeApplication.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -25,6 +25,7 @@
    ------------------------------------------------------------------------------------
 */
 #include &lt;yapp/raf/pch.h&gt;
+#include &lt;yapp/raf/yakePrerequisites.h&gt;
 #include &lt;yapp/raf/yakeApplicationState.h&gt;
 #include &lt;yapp/raf/yakeApplication.h&gt;
 #if YAKE_RAF_USES_CEGUI == 1
@@ -42,7 +43,6 @@
 namespace yake {
 namespace raf {
 
-	//
 	template&lt;class SystemType&gt;
 		SystemType* findSystem(AssocVector&lt;String,SharedPtr&lt;SystemType&gt; &gt;&amp; systems, const String&amp; name)
 	{
@@ -68,9 +68,9 @@
 			SharedPtr&lt;SystemType&gt; pSys;
 			try {
 				if (sysName.empty())
-					pSys = create_default&lt;SystemType&gt;();
+					pSys = yake::templates::create_default&lt;SystemType&gt;();
 				else
-					pSys = create&lt;SystemType&gt;( sysName );
+					pSys = yake::templates::create&lt;SystemType&gt;( sysName );
 			}
 			catch (yake::Exception&amp; e)
 			{
@@ -172,7 +172,7 @@
 #if YAKE_RAF_USES_CEGUI == 1
 	void Application::initCEGUI()
 	{
-		const String file = &quot;ceguiOgreRendererAdapter&quot;;
+		const String file = &quot;CEGUIOgreAdapter&quot;;
 		yake::base::Library* pDynLib = new yake::base::Library( file ); //@FIXME. MEMORY LEAK.
 		YAKE_ASSERT( pDynLib ).debug( &quot;Out of memory&quot; );
 
@@ -486,3 +486,4 @@
 
 } // namespace raf
 } // namespace yake
+

Modified: trunk/yake/src/yapp/raf/yakeApplicationState.cpp
===================================================================
--- trunk/yake/src/yapp/raf/yakeApplicationState.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/raf/yakeApplicationState.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -110,3 +110,4 @@
 
 } // namespace raf
 } // namespace yake
+

Modified: trunk/yake/src/yapp/raf/yakeRtApplicationState.cpp
===================================================================
--- trunk/yake/src/yapp/raf/yakeRtApplicationState.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/raf/yakeRtApplicationState.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -204,3 +204,4 @@
 
 } // namespace raf
 } // namespace yake
+

Modified: trunk/yake/src/yapp/samples/Makefile.am
===================================================================
--- trunk/yake/src/yapp/samples/Makefile.am	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/samples/Makefile.am	2006-03-19 17:54:00 UTC (rev 1302)
@@ -1,3 +1,3 @@
 INCLUDES = $(all_includes)
 METASOURCES = AUTO
-SUBDIRS = base misc gui raf model graphics
+SUBDIRS = base misc gui raf model graphics ode_terrain_demo

Modified: trunk/yake/src/yapp/samples/base/vehicle/yakeDemo.cpp
===================================================================
--- trunk/yake/src/yapp/samples/base/vehicle/yakeDemo.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/samples/base/vehicle/yakeDemo.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -69,7 +69,7 @@
 		graphics::ISceneNode* pSN = getGraphicalWorld()-&gt;createSceneNode();
 		graphics::IEntity* pE = getGraphicalWorld()-&gt;createEntity(&quot;sphere_d1.mesh&quot;);
 		pSN-&gt;attachEntity( pE );
-		const Vector3 scale = Vector3::kUnitScale * mVehicle-&gt;getWheelInterface(wheelId)-&gt;getRadius();
+		const math::Vector3 scale = math::Vector3::kUnitScale * mVehicle-&gt;getWheelInterface(wheelId)-&gt;getRadius();
 		pSN-&gt;setScale( scale );
 		mComplex-&gt;addLink( mVehicle-&gt;getWheelInterface(wheelId), pSN );
 	}
@@ -82,13 +82,13 @@
 		// create a light
 		graphics::ILight* pLight = getGraphicalWorld()-&gt;createLight();
 		pLight-&gt;setType( graphics::ILight::LT_DIRECTIONAL );
-		pLight-&gt;setDirection( Vector3(0,-1,1) );
+		pLight-&gt;setDirection( math::Vector3(0,-1,1) );
 		getGraphicalWorld()-&gt;createSceneNode(&quot;lightnode0&quot;)-&gt;attachLight( pLight );
 
 		// position camera and look at the razor
 		getDefaultCamera()-&gt;setNearClipDistance( 1 );
-		getDefaultCamera()-&gt;setFixedYawAxis(Vector3::kUnitY);
-		getDefaultCamera()-&gt;setPosition(Vector3(0,0,-40));
+		getDefaultCamera()-&gt;setFixedYawAxis(math::Vector3::kUnitY);
+		getDefaultCamera()-&gt;setPosition(math::Vector3(0,0,-40));
 
 		// create ground
 		mGround = new model::complex::Model();
@@ -98,24 +98,33 @@
 			graphics::IEntity* pGroundE = getGraphicalWorld()-&gt;createEntity(&quot;plane_1x1.mesh&quot;);
 			pGroundE-&gt;setMaterial(&quot;box&quot;);
 			pGroundSN-&gt;attachEntity( pGroundE );
-			pGroundSN-&gt;setScale( Vector3(200,1,200) );
-			pGroundSN-&gt;setPosition( Vector3(0,-10,0) );
+			pGroundSN-&gt;setScale( math::Vector3(200,1,200) );
+			pGroundSN-&gt;setPosition( math::Vector3(0,-10,0) );
 
 			model::Graphical* pG = new model::Graphical();
 			pG-&gt;addSceneNode( pGroundSN );
 			mGround-&gt;addGraphical( pG );
 
-			getPhysicalWorld()-&gt;setGlobalGravity( Vector3( 0, -9.81, 0 ) ); 
+			getPhysicalWorld()-&gt;setGlobalGravity( math::Vector3( 0, -9.81, 0 ) ); 
 
 			// physical
 			physics::IActorPtr pGroundPlane = getPhysicalWorld()-&gt;createActor( physics::ACTOR_STATIC );
-			pGroundPlane-&gt;createShape( physics::IShape::PlaneDesc( Vector3(0,1,0), -10 ) );
+			pGroundPlane-&gt;createShape( physics::IShape::PlaneDesc( math::Vector3(0,1,0), -10 ) );
 
 			model::Physical* pP = new model::Physical();
 			pP-&gt;addActor( pGroundPlane, &quot;groundPlane&quot; );
 			mGround-&gt;addPhysical( pP );
 		}
 
+		// create container (e.g. for graphical objects and links)
+		mComplex = new model::complex::Model();
+
+		model::Graphical* pG = new model::Graphical();
+		model::Physical* pPh = new model::Physical;
+
+		mComplex-&gt;addGraphical( SharedPtr&lt;model::Graphical&gt;(pG) );
+		mComplex-&gt;addPhysical( SharedPtr&lt;model::Physical&gt;(pPh) );
+
 		// vehicle
 		SharedPtr&lt;vehicle::IVehicleSystem&gt; pVS = //create&lt;vehicle::IVehicleSystem&gt;(&quot;generic&quot;);
 			SharedPtr&lt;vehicle::IVehicleSystem&gt;(new vehicle::GenericVehicleSystem());
@@ -127,20 +136,20 @@
 
 		vehicle::VehicleTemplate tpl;
 		tpl.mChassis.mChassisShapes.push_back(
-			new physics::IShape::BoxDesc(Vector3(1,1,2)) );
+			new physics::IShape::BoxDesc(math::Vector3(1,1,2)) );
 		// mount points:
 		// mount point for left thruster
 		tpl.mMountPoints[&quot;left&quot;] = 
-			vehicle::VehicleTemplate::MountPointTpl( Vector3(7,0,0), Vector3(1,0,0) );
+			vehicle::VehicleTemplate::MountPointTpl( math::Vector3(7,0,0), math::Vector3(1,0,0) );
 		// mount point for right thruster
 		tpl.mMountPoints[&quot;right&quot;] = 
-			vehicle::VehicleTemplate::MountPointTpl( Vector3(-7,0,0), Vector3(-1,0,0) );
+			vehicle::VehicleTemplate::MountPointTpl( math::Vector3(-7,0,0), math::Vector3(-1,0,0) );
 		// mount point for rear thruster
 		tpl.mMountPoints[&quot;rear&quot;] = 
-			vehicle::VehicleTemplate::MountPointTpl( Vector3(0,0,-8), Vector3(0,0,-1) );
+			vehicle::VehicleTemplate::MountPointTpl( math::Vector3(0,0,-8), math::Vector3(0,0,-1) );
 		// mount point for front thruster
 		tpl.mMountPoints[&quot;front&quot;] = 
-			vehicle::VehicleTemplate::MountPointTpl( Vector3(0,0,7), Vector3(0,0,1) );
+			vehicle::VehicleTemplate::MountPointTpl( math::Vector3(0,0,7), math::Vector3(0,0,1) );
 		// thrusters:
 		tpl.mEngines[&quot;left&quot;] = new vehicle::VehicleTemplate::ThrusterTpl(0.,10.,&quot;left&quot;);
 		tpl.mEngines[&quot;right&quot;] = new vehicle::VehicleTemplate::ThrusterTpl(0.,10.,&quot;right&quot;);
@@ -153,19 +162,14 @@
 		// e.g.: vehicle::VehicleTemplate* tpl = pVS-&gt;getTemplate(&quot;jet&quot;);
 
 		// instantiate
-		mVehicle = pVS-&gt;create(&quot;jet&quot;, *getPhysicalWorld() );
+		mVehicle = pVS-&gt;create( &quot;jet&quot;, *getPhysicalWorld(), *pPh );
 #endif
 
-		// create container (e.g. for graphical objects and links)
-		mComplex = new model::complex::Model();
-		model::Graphical* pG = new model::Graphical();
-		mComplex-&gt;addGraphical( SharedPtr&lt;model::Graphical&gt;(pG) );
-
 		// create visuals
 		// - ship body
 		graphics::ISceneNode* pSN = getGraphicalWorld()-&gt;createSceneNode( &quot;root&quot; );
 		pSN-&gt;attachEntity( getGraphicalWorld()-&gt;createEntity(&quot;razor.mesh&quot;) );
-		pSN-&gt;setScale( Vector3::kUnitScale * razorMeshScale );
+		pSN-&gt;setScale( math::Vector3::kUnitScale * razorMeshScale );
 		pG-&gt;addSceneNode(pSN);
 
 		YAKE_LOG( &quot;Creating thruster visuals&quot; );
@@ -175,6 +179,7 @@
 		_createThrusterVisual( &quot;front&quot;, &quot;backward&quot;, *pSN );
 		_createThrusterVisual( &quot;rear&quot;, &quot;forward&quot;, *pSN );
 		_createThrusterVisual( &quot;bottom&quot;, &quot;upward&quot;, *pSN );
+		_createThrusterVisual( &quot;top&quot;, &quot;downward&quot;, *pSN );
 
 		// - wheel visuals
 		if (mVehicle-&gt;getWheelInterface(&quot;frontWheel&quot;))
@@ -235,6 +240,10 @@
 		mActionMap.reg( ACTIONID_UP,
 			new input::KeyboardActionCondition( getApp().getKeyboard(), KC_PGUP, KAM_CONTINUOUS ) );
 		mActionMap.subscribeToActionId( ACTIONID_UP, boost::bind(&amp;TheMainState::onUp,this) );
+
+		mActionMap.reg( ACTIONID_DOWN,
+			new input::KeyboardActionCondition( getApp().getKeyboard(), KC_PGDOWN, KAM_CONTINUOUS ) );
+		mActionMap.subscribeToActionId( ACTIONID_DOWN, boost::bind(&amp;TheMainState::onDown,this) );
 	}
 
 	virtual void onExit()
@@ -250,7 +259,7 @@
 		while (itEngine.hasMoreElements())
 		{
 			vehicle::IEngine* pEngine = itEngine.getNext();
-			pEngine-&gt;setThrottle( pEngine-&gt;getThrottle() - timeElapsed * 1.7 );
+			pEngine-&gt;setInputSignal( pEngine-&gt;getInputSignal() - timeElapsed * 1.7 );
 		}
 
 		real steering0 = 0;
@@ -260,15 +269,17 @@
 		{
 			const input::ActionId activeId = itAction.getNext();
 			if (activeId == input::ACTIONID_STRAFE_LEFT)
-				mVehicle-&gt;getEngineInterface(&quot;right&quot;)-&gt;setThrottle(1.);
+				mVehicle-&gt;getEngineInterface(&quot;right&quot;)-&gt;setInputSignal(1.);
 			else if (activeId == input::ACTIONID_STRAFE_RIGHT)
-				mVehicle-&gt;getEngineInterface(&quot;left&quot;)-&gt;setThrottle(1.);
+				mVehicle-&gt;getEngineInterface(&quot;left&quot;)-&gt;setInputSignal(1.);
 			else if (activeId == input::ACTIONID_FORWARD)
-				mVehicle-&gt;getEngineInterface(&quot;forward&quot;)-&gt;setThrottle(1.);
+				mVehicle-&gt;getEngineInterface(&quot;forward&quot;)-&gt;setInputSignal(1.);
 			else if (activeId == input::ACTIONID_REVERSE)
-				mVehicle-&gt;getEngineInterface(&quot;backward&quot;)-&gt;setThrottle(1.);
+				mVehicle-&gt;getEngineInterface(&quot;backward&quot;)-&gt;setInputSignal(1.);
 			else if (activeId == input::ACTIONID_UP)
-				mVehicle-&gt;getEngineInterface(&quot;upward&quot;)-&gt;setThrottle(1.);
+				mVehicle-&gt;getEngineInterface(&quot;upward&quot;)-&gt;setInputSignal(1.);
+			else if (activeId == input::ACTIONID_DOWN)
+				mVehicle-&gt;getEngineInterface(&quot;downward&quot;)-&gt;setInputSignal(1.);
 			else if (activeId == input::ACTIONID_LEFT)
 				steering0 -= 0.3;
 			else if (activeId == input::ACTIONID_RIGHT)
@@ -276,12 +287,13 @@
 		}
 		mVehicle-&gt;setSteering( 0, steering0 );
 
-		mVehicle-&gt;updateSimulation( timeElapsed );
+		//mVehicle-&gt;updateSimulation( timeElapsed );
 		mComplex-&gt;updatePhysics( timeElapsed );
 
 		_updateThrusterPs();
 		getDefaultCamera()-&gt;lookAt(mVehicle-&gt;getChassisPosition());
 		mComplex-&gt;updateGraphics( timeElapsed );
+		//YAKE_LOG_INFORMATION( String( &quot;pos: &quot; ) &lt;&lt; mVehicle-&gt;getChassisPosition() );
 
 		mActiveActions.clear();
 	}
@@ -299,6 +311,8 @@
 	{ mActiveActions.insert( input::ACTIONID_REVERSE ); }
 	void onUp()
 	{ mActiveActions.insert( input::ACTIONID_UP ); }
+	void onDown()
+	{ mActiveActions.insert( input::ACTIONID_DOWN ); }
 	void onFrontWheelLeft()
 	{ mActiveActions.insert( input::ACTIONID_LEFT ); }
 	void onFrontWheelRight()
@@ -320,7 +334,7 @@
 			std::pair&lt;String,graphics::IParticleSystem*&gt; p = itM.getNext();
 			const String mtPtId = p.first;
 			graphics::IParticleSystem* ps = p.second;
-			const real throttle = mVehicle-&gt;getEngineInterface(mtPtId)-&gt;getThrottle();
+			const real throttle = mVehicle-&gt;getEngineInterface(mtPtId)-&gt;getInputSignal();
 
 			real rate = throttle * mEmitterEmissionRate[ mtPtId ];
 			ps-&gt;setEmissionRate( 0, rate );

Modified: trunk/yake/src/yapp/samples/gui/console/yakeConsoleDemo.cpp
===================================================================
--- trunk/yake/src/yapp/samples/gui/console/yakeConsoleDemo.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/samples/gui/console/yakeConsoleDemo.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -349,8 +349,8 @@
 	 */
 	void initGui()
 	{
-		//mGuiRendererAdapter = loadPlugin( &quot;CEGUIOgreAdapter&quot; );
-		mGuiRendererAdapter = loadPlugin( &quot;ceguiOgreRendererAdapter&quot; );
+		mGuiRendererAdapter = loadPlugin( &quot;CEGUIOgreAdapter&quot; );
+		//mGuiRendererAdapter = loadPlugin( &quot;ceguiOgreRendererAdapter&quot; );
 		YAKE_ASSERT( mGuiRendererAdapter );
 
 		YAKE_LOG( &quot;Starting adapter version &quot; + mGuiRendererAdapter-&gt;getName() );

Modified: trunk/yake/src/yapp/samples/misc/cmdrmayhem/yakeDemo.cpp
===================================================================
--- trunk/yake/src/yapp/samples/misc/cmdrmayhem/yakeDemo.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/samples/misc/cmdrmayhem/yakeDemo.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -14,7 +14,7 @@
 struct TheConfiguration : public raf::ApplicationConfiguration
 {
 	virtual StringVector getLibraries()
-	{ return MakeStringVector() &lt;&lt; &quot;graphicsOgre&quot; &lt;&lt; &quot;inputOgre&quot; &lt;&lt; &quot;physicsOde&quot;; }
+	{ return MakeStringVector() &lt;&lt; &quot;graphicsOgre&quot; &lt;&lt; &quot;inputOgre&quot; &lt;&lt; &quot;physicsODE&quot;; }
 
 	//virtual StringVector getScriptingSystems()
 	//{ return MakeStringVector() &lt;&lt; &quot;lua&quot;; }
@@ -103,15 +103,15 @@
 		// create a light
 		graphics::ILight* pLight = getGraphicalWorld()-&gt;createLight();
 		pLight-&gt;setType( graphics::ILight::LT_DIRECTIONAL );
-		pLight-&gt;setDirection( Vector3(0,-1,1) );
+		pLight-&gt;setDirection( math::Vector3(0,-1,1) );
 		getGraphicalWorld()-&gt;createSceneNode(&quot;lightnode0&quot;)-&gt;attachLight( pLight );
 
 		getGraphicalWorld()-&gt;setShadowsEnabled( true );
 
 		// position camera and look at the ninja
 		getDefaultCamera()-&gt;setNearClipDistance( 1 );
-		getDefaultCamera()-&gt;setFixedYawAxis(Vector3::kUnitY);
-		getDefaultCamera()-&gt;setPosition(Vector3(7,4,-7));
+		getDefaultCamera()-&gt;setFixedYawAxis(math::Vector3::kUnitY);
+		getDefaultCamera()-&gt;setPosition(math::Vector3(7,4,-7));
 
 		// create ground
 		mGround = new model::complex::Model();
@@ -123,8 +123,8 @@
 			pGroundE-&gt;setMaterial(&quot;box&quot;);
 			pGroundE-&gt;setCastsShadow( false );
 			pGroundSN-&gt;attachEntity( pGroundE );
-			pGroundSN-&gt;setScale( Vector3(100,1,100) );
-			pGroundSN-&gt;setPosition( Vector3(0,groundHeight,0) );
+			pGroundSN-&gt;setScale( math::Vector3(100,1,100) );
+			pGroundSN-&gt;setPosition( math::Vector3(0,groundHeight,0) );
 
 			model::Graphical* pG = new model::Graphical();
 			pG-&gt;addSceneNode( pGroundSN );
@@ -132,7 +132,7 @@
 
 			// physical
 			physics::IActorPtr pGroundPlane = getPhysicalWorld()-&gt;createActor( physics::ACTOR_STATIC );
-			pGroundPlane-&gt;createShape( physics::IShape::PlaneDesc( Vector3(0,1,0), groundHeight ) );
+			pGroundPlane-&gt;createShape( physics::IShape::PlaneDesc( math::Vector3(0,1,0), groundHeight ) );
 
 			model::Physical* pP = new model::Physical();
 			pP-&gt;addActor( pGroundPlane, &quot;groundPlane&quot; );
@@ -152,8 +152,8 @@
 		// create player/avatar
 		mPlayerRep = getPhysicalWorld()-&gt;createAvatar(
 				physics::IAvatar::Desc(
-						Vector3(0.5,2,0), // dimensions
-						Vector3::kZero // initial position
+						math::Vector3(0.5,2,0), // dimensions
+						math::Vector3::kZero // initial position
 					) 
 			);
 		YAKE_ASSERT( mPlayerRep );
@@ -165,7 +165,7 @@
 			pG-&gt;addSceneNode( pSN );
 			graphics::IEntity* pE = getGraphicalWorld()-&gt;createEntity(&quot;sphere_d1.mesh&quot;);
 			pSN-&gt;attachEntity( pE );
-			pSN-&gt;setScale( 0.5 * Vector3::kUnitScale );
+			pSN-&gt;setScale( 0.5 * math::Vector3::kUnitScale );
 
 			model::ModelMovableLink* pLink = new model::ModelMovableLink();
 			mComplex-&gt;addGraphicsController( pLink );
@@ -175,7 +175,7 @@
 		}
 
 		// top-down camera controller
-		mTopDownCtrlr.setOffset( Vector3(10,10,-10) );
+		mTopDownCtrlr.setOffset( math::Vector3(10,10,-10) );
 		mTopDownCtrlr.setCamera( getDefaultCamera() );
 	}
 	virtual void onDestroyScene()
@@ -222,28 +222,28 @@
 	{
 		mActionMap.update();
 
-		Vector3 projViewDir = mTopDownCtrlr.getOffset();
+		math::Vector3 projViewDir = mTopDownCtrlr.getOffset();
 		projViewDir.y = 0.;
 		if (projViewDir.length() &lt;= 0.01)
-			projViewDir = Vector3::kUnitZ;
+			projViewDir = math::Vector3::kUnitZ;
 		projViewDir.normalise();
-		Quaternion projViewRot;
-		projViewRot.FromAxes( projViewDir.crossProduct( Vector3::kUnitY ), Vector3::kUnitY, -projViewDir );
+		math::Quaternion projViewRot;
+		projViewRot.FromAxes( projViewDir.crossProduct( math::Vector3::kUnitY ), math::Vector3::kUnitY, -projViewDir );
 
 		const real maxVel = real(3.0);
-		Vector3 playerTargetVel;
+		math::Vector3 playerTargetVel;
 		ConstDequeIterator&lt; ActionIdList &gt; itAction( mActiveActions );
 		while (itAction.hasMoreElements())
 		{
 			const input::ActionId activeId = itAction.getNext();
 			if (activeId == input::ACTIONID_FORWARD)
-				playerTargetVel += Vector3(0,0,+1);
+				playerTargetVel += math::Vector3(0,0,+1);
 			else if (activeId == input::ACTIONID_REVERSE)
-				playerTargetVel += Vector3(0,0,-1);
+				playerTargetVel += math::Vector3(0,0,-1);
 			else if (activeId == input::ACTIONID_LEFT)
-				playerTargetVel += Vector3(+1,0,0);
+				playerTargetVel += math::Vector3(+1,0,0);
 			else if (activeId == input::ACTIONID_RIGHT)
-				playerTargetVel += Vector3(-1,0,0);
+				playerTargetVel += math::Vector3(-1,0,0);
 			else if (activeId == input::ACTIONID_UP)
 				mPlayerRep-&gt;jump();
 			else if (activeId == input::ACTIONID_DOWN)
@@ -262,15 +262,15 @@
 
 		{ // top-down controller
 			const real dist = timeElapsed * 4.;
-			Vector3 offset = mTopDownCtrlr.getOffset();
+			math::Vector3 offset = mTopDownCtrlr.getOffset();
 			if (this-&gt;getApp().getKeyboard()-&gt;isKeyDown(input::KC_I))
-				offset += dist * Vector3::kUnitZ;
+				offset += dist * math::Vector3::kUnitZ;
 			if (this-&gt;getApp().getKeyboard()-&gt;isKeyDown(input::KC_K))
-				offset += - dist * Vector3::kUnitZ;
+				offset += - dist * math::Vector3::kUnitZ;
 			if (this-&gt;getApp().getKeyboard()-&gt;isKeyDown(input::KC_J))
-				offset += dist * Vector3::kUnitX;
+				offset += dist * math::Vector3::kUnitX;
 			if (this-&gt;getApp().getKeyboard()-&gt;isKeyDown(input::KC_L))
-				offset += - dist * Vector3::kUnitX;
+				offset += - dist * math::Vector3::kUnitX;
 			mTopDownCtrlr.setOffset( offset );
 		}
 

Modified: trunk/yake/src/yapp/samples/model/XODE/yakeXODELoaderDemo.cpp
===================================================================
--- trunk/yake/src/yapp/samples/model/XODE/yakeXODELoaderDemo.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/samples/model/XODE/yakeXODELoaderDemo.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -86,8 +86,8 @@
 		mPWorld = getPhysicsSystem().createWorld();
 		YAKE_ASSERT( mPWorld );
 
-		// objects
-		setupWorld();
+	    // objects
+	    setupWorld();
 
 		YAKE_LOG( &quot;World was all set up!&quot; );
 		YAKE_LOG( &quot;Running simulation...&quot; );
@@ -114,9 +114,9 @@
 
 		YAKE_LOG( &quot;Simulation complete. Cleaning up...&quot; );
 
-		YAKE_SAFE_DELETE( mPhysical );
+	    YAKE_SAFE_DELETE( mPhysical );
 
-		mPWorld.reset();
+	    mPWorld.reset();
 	}
 };
 
@@ -149,6 +149,6 @@
 	std::cin.get();
 #endif
 
-	return 0;
+    return 0;
 }
 

Modified: trunk/yake/src/yapp/samples/model/dotLink/yakeDotLinkDemo.cpp
===================================================================
--- trunk/yake/src/yapp/samples/model/dotLink/yakeDotLinkDemo.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/samples/model/dotLink/yakeDotLinkDemo.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -259,5 +259,5 @@
 	std::cin.get();
 #endif
 
-	return 0;
+    return 0;
 }

Modified: trunk/yake/src/yapp/vehicle/yakeDotVehicle.cpp
===================================================================
--- trunk/yake/src/yapp/vehicle/yakeDotVehicle.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/vehicle/yakeDotVehicle.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -125,28 +125,37 @@
 				}
 			}
 		}
+		pN = n.getNodeByName( &quot;ref&quot; ); // reference to xode
+		if ( pN.get() )
+		{
+		    // reading physical body name from &quot;xode&quot; attribute
+		    mpCurrVehTpl-&gt;mChassis.mPhysicsBody = pN-&gt;getAttributeValueAs&lt;String&gt;( &quot;xode&quot; );
+		}
 	}
+
 	void DotVehicleParser::parseShapeBox( const data::dom::INode&amp; n, const String&amp; matId )
 	{
-		Vector3 dim;
+		math::Vector3 dim;
 		dim.x = StringUtil::parseReal( n.getAttributeValueAs&lt;String&gt;(&quot;x&quot;) );
 		dim.y = StringUtil::parseReal( n.getAttributeValueAs&lt;String&gt;(&quot;y&quot;) );
 		dim.z = StringUtil::parseReal( n.getAttributeValueAs&lt;String&gt;(&quot;z&quot;) );
-		Vector3 pos;
+		math::Vector3 pos;
 		if (n.getNodeByName(&quot;position&quot;))
 			parsePosition( *n.getNodeByName(&quot;position&quot;), pos );
 		mpCurrVehTpl-&gt;mChassis.mChassisShapes.push_back(
 			new physics::IShape::BoxDesc( dim, matId, pos ) );
 	}
+
 	void DotVehicleParser::parseShapeSphere( const data::dom::INode&amp; n, const String&amp; matId )
 	{
 		real radius = StringUtil::parseReal( n.getAttributeValueAs&lt;String&gt;(&quot;radius&quot;) );
-		Vector3 pos;
+		math::Vector3 pos;
 		if (n.getNodeByName(&quot;position&quot;))
 			parsePosition( *n.getNodeByName(&quot;position&quot;), pos );
 		mpCurrVehTpl-&gt;mChassis.mChassisShapes.push_back(
 			new physics::IShape::SphereDesc( radius, matId, pos ) );
 	}
+
 	void DotVehicleParser::parseEngine( const data::dom::INode&amp; n )
 	{
 		String id = n.getAttributeValueAs&lt;String&gt;(&quot;name&quot;);
@@ -157,16 +166,44 @@
 
 		if (type == &quot;MountedThruster&quot;)
 		{
+			String thrusterType = n.getAttributeValueAs&lt;String&gt;(&quot;thrusterType&quot;);
+			if ( thrusterType.empty() )
+			    thrusterType = &quot;linear&quot;; // FIXME compatibility with old data files
+			
 			String mtPt = n.getAttributeValueAs&lt;String&gt;(&quot;mountPoint&quot;);
 			YAKE_ASSERT( !mtPt.empty() );
 
-			SharedPtr&lt;data::dom::INode&gt; pForcesN = n.getNodeByName(&quot;forces&quot;);
-			YAKE_ASSERT( pForcesN.get() );
+			// TODO basic implementation. Make it pretty :D
 
-			mpCurrVehTpl-&gt;mEngines[ id ] = new VehicleTemplate::ThrusterTpl(
-				StringUtil::parseReal( pForcesN-&gt;getAttributeValueAs&lt;String&gt;(&quot;min&quot;) ),
-				StringUtil::parseReal( pForcesN-&gt;getAttributeValueAs&lt;String&gt;(&quot;max&quot;) ),
-				mtPt );
+			if ( thrusterType == &quot;linear&quot; )
+			{
+			    SharedPtr&lt;data::dom::INode&gt; pForcesN = n.getNodeByName(&quot;forces&quot;);
+			    YAKE_ASSERT( pForcesN.get() );
+
+			    VehicleTemplate::ThrusterTpl* pTemplate = new VehicleTemplate::ThrusterTpl;
+
+			    pTemplate-&gt;minForce = StringUtil::parseReal( pForcesN-&gt;getAttributeValueAs&lt;String&gt;(&quot;min&quot;) );
+			    pTemplate-&gt;maxForce = StringUtil::parseReal( pForcesN-&gt;getAttributeValueAs&lt;String&gt;(&quot;max&quot;) );
+			    pTemplate-&gt;gain = 0; // not needed
+			    pTemplate-&gt;mountPt = mtPt;
+			    pTemplate-&gt;type = &quot;linear&quot;;
+
+			    mpCurrVehTpl-&gt;mEngines[ id ] = pTemplate;
+			}
+			else if ( thrusterType == &quot;gain&quot; )
+			{
+			    SharedPtr&lt;data::dom::INode&gt; pParams = n.getNodeByName(&quot;params&quot;);
+			    YAKE_ASSERT( pParams.get() );
+			    
+			    VehicleTemplate::ThrusterTpl* pTemplate = new VehicleTemplate::ThrusterTpl;
+			    pTemplate-&gt;minForce = 0; // not needed
+			    pTemplate-&gt;maxForce = 0; // not needed
+			    pTemplate-&gt;gain = StringUtil::parseReal( pParams-&gt;getAttributeValueAs&lt;String&gt;(&quot;gain&quot;) );
+			    pTemplate-&gt;mountPt = mtPt;
+			    pTemplate-&gt;type = &quot;gain&quot;;
+
+			    mpCurrVehTpl-&gt;mEngines[ id ] = pTemplate;
+			}
 		}
 		else if (type == &quot;CarEngine&quot;)
 		{
@@ -222,17 +259,17 @@
 		const String thisId = n.getAttributeValueAs&lt;String&gt;(&quot;name&quot;);
 		YAKE_ASSERT( !thisId.empty() );
 
-		Vector3 position;
+		math::Vector3 position;
 		SharedPtr&lt;INode&gt; pNode = n.getNodeByName(&quot;position&quot;);
 		if (pNode.get())
 			parsePosition( *pNode, position );
 
-		Quaternion orientation;
+		math::Quaternion orientation;
 		pNode = n.getNodeByName(&quot;orientation&quot;);
 		if (pNode.get())
 			parseOrientation( *pNode, orientation );
 
-		Vector3 direction;
+		math::Vector3 direction;
 		pNode = n.getNodeByName(&quot;direction&quot;);
 		if (pNode.get())
 			parseDirection( *pNode, direction );
@@ -283,12 +320,12 @@
 			return;
 		YAKE_ASSERT( mpCurrVehTpl-&gt;mWheels.find( name ) == mpCurrVehTpl-&gt;mWheels.end() )( name ).debug(&quot;duplicate wheel name. overriding values.&quot;);
 
-		Vector3 position;
+		math::Vector3 position;
 		SharedPtr&lt;data::dom::INode&gt; pN = n.getNodeByName(&quot;position&quot;);
 		if (pN.get())
 			parsePosition( *pN, position );
 
-		Quaternion rotation( Quaternion::kIdentity );
+		math::Quaternion rotation( math::Quaternion::kIdentity );
 		pN = n.getNodeByName(&quot;orientation&quot;);
 		if (pN.get())
 			parseOrientation( *pN, rotation );
@@ -318,19 +355,19 @@
 
 
 	}
-	void DotVehicleParser::parsePosition( const data::dom::INode&amp; n, Vector3&amp; ret )
+	void DotVehicleParser::parsePosition( const data::dom::INode&amp; n, math::Vector3&amp; ret )
 	{
 		ret.x = StringUtil::parseReal( n.getAttributeValueAs&lt;String&gt;(&quot;x&quot;) );
 		ret.y = StringUtil::parseReal( n.getAttributeValueAs&lt;String&gt;(&quot;y&quot;) );
 		ret.z = StringUtil::parseReal( n.getAttributeValueAs&lt;String&gt;(&quot;z&quot;) );
 	}
-	void DotVehicleParser::parseDirection( const data::dom::INode&amp; n, Vector3&amp; ret )
+	void DotVehicleParser::parseDirection( const data::dom::INode&amp; n, math::Vector3&amp; ret )
 	{
 		ret.x = StringUtil::parseReal( n.getAttributeValueAs&lt;String&gt;(&quot;x&quot;) );
 		ret.y = StringUtil::parseReal( n.getAttributeValueAs&lt;String&gt;(&quot;y&quot;) );
 		ret.z = StringUtil::parseReal( n.getAttributeValueAs&lt;String&gt;(&quot;z&quot;) );
 	}
-	void DotVehicleParser::parseOrientation( const data::dom::INode&amp; n, Quaternion&amp; ret )
+	void DotVehicleParser::parseOrientation( const data::dom::INode&amp; n, math::Quaternion&amp; ret )
 	{
 		if ( n.getAttributeValueAs&lt;String&gt;(&quot;qx&quot;) != &quot;&quot; )
 		{
@@ -341,7 +378,7 @@
 		}
 		else if ( n.getAttributeValueAs&lt;String&gt;(&quot;axisX&quot;) != &quot;&quot; )
 		{
-			Vector3 axis;
+			math::Vector3 axis;
 			axis.x = StringUtil::parseReal( n.getAttributeValueAs&lt;String&gt;(&quot;axisX&quot;) );
 			axis.y = StringUtil::parseReal( n.getAttributeValueAs&lt;String&gt;(&quot;axisY&quot;) );
 			axis.z = StringUtil::parseReal( n.getAttributeValueAs&lt;String&gt;(&quot;axisZ&quot;) );
@@ -349,7 +386,7 @@
 		}
 		else if ( n.getAttributeValueAs&lt;String&gt;(&quot;angleX&quot;) != &quot;&quot; )
 		{
-			Vector3 axis;
+			math::Vector3 axis;
 			axis.x = StringUtil::parseReal( n.getAttributeValueAs&lt;String&gt;(&quot;angleX&quot;) );
 			axis.y = StringUtil::parseReal( n.getAttributeValueAs&lt;String&gt;(&quot;angleY&quot;) );
 			axis.z = StringUtil::parseReal( n.getAttributeValueAs&lt;String&gt;(&quot;angleZ&quot;) );
@@ -360,3 +397,4 @@
 
 } // namespace vehicle
 } // namespace yake
+

Modified: trunk/yake/src/yapp/vehicle/yakeMountPoint.cpp
===================================================================
--- trunk/yake/src/yapp/vehicle/yakeMountPoint.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/vehicle/yakeMountPoint.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -35,8 +35,8 @@
 	// Class: MountPoint
 	//-----------------------------------------------------
 	MountPoint::MountPoint() :
-		mPosition(Vector3::kZero),
-		mOrientation(Quaternion::kIdentity),
+		mPosition(math::Vector3::kZero),
+		mOrientation(math::Quaternion::kIdentity),
 		mParent(0),
 		mOverrideParent(0)
 	{
@@ -90,44 +90,54 @@
 		mMountables.erase( itFind );
 		mountable-&gt;onDetached();
 	}
-	Vector3 MountPoint::getDirection() const
+	math::Vector3 MountPoint::getDirection() const
 	{ 
-		return getDerivedOrientation() * Vector3::kUnitZ; 
+		// direction in local coordinates
+		//
+		return mOrientation * math::Vector3::kUnitZ; 
 	}
-	void MountPoint::setDirection( const Vector3&amp; dir)
+	void MountPoint::setDirection( const math::Vector3&amp; dir)
 	{
-		const Vector3 currDir = getDirection();
-		const Vector3 newDir = dir.normalisedCopy();
-		//@fixme Use tolerance for equality tests!
-		if (newDir == currDir)
+		const real tolerance = real(0.001);
+		const math::Vector3 currDir = getDirection();
+		const math::Vector3 newDir = dir.normalisedCopy();
+
+		if ( newDir == currDir )
 			return;
-		if (newDir == -currDir)
+
+		if ( newDir.dotProduct( currDir ) + 1 &lt;= tolerance ) // tolerance check. TODO tolerance globally? for math
 		{
-			real angle = 0.;
-			Vector3 axis(Vector3::kUnitY);
-			mOrientation.ToAngleAxis(angle,axis);
-			mOrientation.FromAngleAxis(angle+Math::PI,axis);
+		    	real angle = 0.;
+		    	math::Vector3 axis;
+		    	mOrientation.ToAngleAxis( angle, axis );
+
+			// adding another 180 grads
+			angle += math::Math::PI;
+
+			// setting new orientation
+			mOrientation.FromAngleAxis( angle, axis );			
+			
 			return;
 		}
 		mOrientation = currDir.getRotationTo( newDir ) * mOrientation;
 	}
-	void MountPoint::setPosition(const Vector3&amp; rPosition)
+	void MountPoint::setPosition(const math::Vector3&amp; rPosition)
 	{
 		mPosition = rPosition;
 	}
-	Vector3 MountPoint::getPosition() const
+	math::Vector3 MountPoint::getPosition() const
 	{
 		return mPosition;
 	}
-	void MountPoint::setOrientation( const Quaternion&amp; q )
+	void MountPoint::setOrientation( const math::Quaternion&amp; q )
 	{
 		mOrientation = q;
 	}
-	Quaternion MountPoint::getOrientation() const
+	math::Quaternion MountPoint::getOrientation() const
 	{
 		return mOrientation;
 	}
-	Vector3 MountPoint::getDerivedPosition() const
+	math::Vector3 MountPoint::getDerivedPosition() const
 	{
 		if (mOverrideParent)
 			return mOverrideParent-&gt;getOrientation() * mPosition + mOverrideParent-&gt;getPosition();
@@ -135,7 +145,7 @@
 			return mParent-&gt;getDerivedOrientation() * mPosition + mParent-&gt;getDerivedPosition();
 		return mPosition;
 	}
-	Quaternion MountPoint::getDerivedOrientation() const
+	math::Quaternion MountPoint::getDerivedOrientation() const
 	{
 		if (mOverrideParent)
 			return mOverrideParent-&gt;getOrientation() * mOrientation;
@@ -154,3 +164,4 @@
 
 } // namespace vehicle
 } // namespace yake
+

Modified: trunk/yake/src/yapp/vehicle/yakeNativeOde.cpp
===================================================================
--- trunk/yake/src/yapp/vehicle/yakeNativeOde.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/vehicle/yakeNativeOde.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -59,10 +59,10 @@
 	{
 		mVehicleTemplates.clear();
 	}
-	IVehicle* GenericVehicleSystem::create(const VehicleTemplate&amp; tpl, physics::IWorld&amp; PWorld)
+	IVehicle* GenericVehicleSystem::create(const VehicleTemplate&amp; tpl, physics::IWorld&amp; PWorld, model::Physical&amp; physModel )
 	{
 		GenericVehicle* pV = new GenericVehicle();
-		pV-&gt;_create( tpl, PWorld );
+		pV-&gt;_create( tpl, PWorld, physModel );
 		return pV;
 	}
 	bool GenericVehicleSystem::loadTemplates(const String&amp; fn)
@@ -96,13 +96,13 @@
 	//		return 0;
 	//	return tpl-&gt;clone();
 	//}
-	IVehicle* GenericVehicleSystem::create(const String&amp; tplId, physics::IWorld&amp; PWorld)
+	IVehicle* GenericVehicleSystem::create(const String&amp; tplId, physics::IWorld&amp; PWorld, model::Physical&amp; physModel)
 	{
 		const VehicleTemplate* tpl = getTemplate( tplId );
 		YAKE_ASSERT( tpl );
 		if (!tpl)
 			return 0;
-		return create(*tpl,PWorld);
+		return create(*tpl,PWorld,physModel);
 	}
 	void GenericVehicleSystem::_onVehicleTpl(vehicle::DotVehicleParser&amp; parser, const String&amp; tplId)
 	{
@@ -221,12 +221,12 @@
 			return 0;
 		return itFind-&gt;second;
 	}
-	Vector3 GenericVehicle::getChassisPosition() const
+	math::Vector3 GenericVehicle::getChassisPosition() const
 	{
 		YAKE_ASSERT( mpChassis );
 		return mpChassis-&gt;getPosition();
 	}
-	Quaternion GenericVehicle::getChassisOrientation() const
+	math::Quaternion GenericVehicle::getChassisOrientation() const
 	{
 		YAKE_ASSERT( mpChassis );
 		return mpChassis-&gt;getOrientation();
@@ -236,6 +236,7 @@
 		YAKE_ASSERT( mpChassis );
 		return mpChassis;
 	}
+	
 	void GenericVehicle::_createMountPoint(const String&amp; id, const VehicleTemplate::MountPointTpl&amp; mtPtTpl,MountPoint* parentMtPt)
 	{
 		MountPoint* thisMtPt = new GenericMountPoint();
@@ -266,19 +267,44 @@
 			_createMountPoint( mptTplEntry.first, childMtPtTpl, thisMtPt );
 		}
 	}
-	void GenericVehicle::_create(const VehicleTemplate&amp; tpl, physics::IWorld&amp; PWorld )
+	void GenericVehicle::_create(const VehicleTemplate&amp; tpl, physics::IWorld&amp; PWorld, model::Physical&amp; physModel )
 	{
-		// chassis
-		mpChassis = PWorld.createActor( physics::ACTOR_DYNAMIC );
-		mpChassis-&gt;setPosition( tpl.mChassis.mPosition );
-		//mpChassis-&gt;setOrientation( tpl.mChassis.mOrientation );
-		ConstDequeIterator&lt; VehicleTemplate::ShapeTplList &gt; itShapeTpl( tpl.mChassis.mChassisShapes );
-		while (itShapeTpl.hasMoreElements())
+		YAKE_LOG( &quot;Creating vehicle from template...&quot; );
+		if ( tpl.mChassis.mPhysicsBody != &quot;&quot; ) // i.e. chassis is defined as reference to physical body
 		{
+		    YAKE_LOG( &quot;External physical body found. Searching provided model for it...&quot; );
+
+		    // searching for actor in provided model
+		    physics::IActorPtr actor = physModel.getActorByName( tpl.mChassis.mPhysicsBody );
+
+		    YAKE_ASSERT( actor != NULL ).error( &quot;Actor '&quot; + tpl.mChassis.mPhysicsBody 
+			    +  &quot;' was not found in physical model! Are you sure you provided the right model???&quot; );
+
+		    YAKE_LOG( &quot;Found. OK.&quot; );
+		    // initial position is determined by body position
+		    mpChassis = actor;
+		}
+		else // chassis is defined in .vehicle itself
+		{
+		    YAKE_LOG( &quot;External physical body not found. Looking for body definition in .vehicle file.&quot; );
+		    // chassis
+		    mpChassis = PWorld.createActor( physics::ACTOR_DYNAMIC );
+
+		    // adding chassis to physical model here...
+		    // TODO: naming convention for chassis. 
+		    // No more than one chassis per model now ;)
+		    physModel.addActor( mpChassis, &quot;vehicle_chassis&quot; );
+
+		    mpChassis-&gt;setPosition( tpl.mChassis.mPosition );
+		    //mpChassis-&gt;setOrientation( tpl.mChassis.mOrientation );
+		    ConstDequeIterator&lt; VehicleTemplate::ShapeTplList &gt; itShapeTpl( tpl.mChassis.mChassisShapes );
+		    while (itShapeTpl.hasMoreElements())
+		    {
 			mpChassis-&gt;createShape( *itShapeTpl.getNext() );
+		    }
+		    mpChassis-&gt;getBody().setMass( tpl.mChassis.mMass );
 		}
-		mpChassis-&gt;getBody().setMass( tpl.mChassis.mMass );
-
+		
 		// mount points
 		ConstDequeIterator&lt; VehicleTemplate::MountPointTplList &gt; itMP( tpl.mMountPoints );
 		while (itMP.hasMoreElements())
@@ -322,19 +348,33 @@
 				if (thrusterTpl)
 				{
 					// thruster itself
-					GenericThruster* pEngine = new GenericThruster();
-					mEngines[ engineTplEntry.first ] = pEngine;
-					pEngine-&gt;setMinimumForce( thrusterTpl-&gt;minForce );
-					pEngine-&gt;setMaximumForce( thrusterTpl-&gt;maxForce );
-					pEngine-&gt;setThrottle(0.);
-					subscribeToUpdateEngineSimulation(
-						boost::bind( &amp;GenericThruster::updateSimulation, pEngine, _1 ) );
+					IThruster* pThruster = NULL;
+					if ( thrusterTpl-&gt;type == &quot;linear&quot; )
+					{
+					    GenericLinearThruster* pEngine = new GenericLinearThruster();
+					    pThruster = pEngine; 
+					    mEngines[ engineTplEntry.first ] = pEngine;
+					    pEngine-&gt;setMinimumForce( thrusterTpl-&gt;minForce );
+					    pEngine-&gt;setMaximumForce( thrusterTpl-&gt;maxForce );
+					    pEngine-&gt;setInputSignal(0.);
+					    subscribeToUpdateEngineSimulation(
+						    boost::bind( &amp;GenericLinearThruster::updateSimulation, pEngine, _1 ) );
+					}
+					else if ( thrusterTpl-&gt;type == &quot;gain&quot; )
+					{
+					    GenericThruster* pEngine = new GenericThruster();
+					    pThruster = pEngine; 
+					    mEngines[ engineTplEntry.first ] = pEngine;
+					    pEngine-&gt;setGain( thrusterTpl-&gt;gain );
+					    subscribeToUpdateEngineSimulation(
+						    boost::bind( &amp;GenericThruster::updateSimulation, pEngine, _1 ) );
+					}
 
 					// the thruster is attached to a mount point, create wrapper:
 					if (thrusterTpl-&gt;mountPt != MPID_NO_PARENT)
 					{
 						GenericMountedThruster* pMounted = new GenericMountedThruster();
-						pMounted-&gt;setThruster( pEngine );
+						pMounted-&gt;setThruster( pThruster );
 
 						pMounted-&gt;addTarget( mpChassis-&gt;getBodyPtr() );
 
@@ -423,7 +463,7 @@
 				{
 					pE = GWorld.createEntity(&quot;sphere_1d.mesh&quot;);
 					pSN-&gt;attachEntity( pE );
-					pSN-&gt;setScale( Vector3::kUnitScale * pShape-&gt;getPropertyReal(&quot;radius&quot;) );
+					pSN-&gt;setScale( math::Vector3::kUnitScale * pShape-&gt;getPropertyReal(&quot;radius&quot;) );
 				}
 				break;
 			default:
@@ -500,8 +540,8 @@
 		{
 			mpJoint = PWorld.createJoint( physics::IJoint::DescHinge2( 
 				chassisObj, mpWheel, 
-				tpl.mOrientation * Vector3::kUnitY,
-				tpl.mOrientation * Vector3::kUnitX,
+				tpl.mOrientation * math::Vector3::kUnitY,
+				tpl.mOrientation * math::Vector3::kUnitX,
 				tpl.mPosition ) );
 
 			mpJoint-&gt;setSpring( tpl.mSuspensionSpring );
@@ -579,8 +619,8 @@
 	{
 		YAKE_ASSERT( mpChassis );
 		YAKE_ASSERT( mpWheel );
-		const Vector3 chassisDir = mpChassis-&gt;getOrientation() * Vector3::kUnitZ;
-		const Vector3 wheelMovementDir = mpWheel-&gt;getBody().getLinearVelocity().normalisedCopy();
+		const math::Vector3 chassisDir = mpChassis-&gt;getOrientation() * math::Vector3::kUnitZ;
+		const math::Vector3 wheelMovementDir = mpWheel-&gt;getBody().getLinearVelocity().normalisedCopy();
 		mSkid = 1. - chassisDir.dotProduct( wheelMovementDir );
 		if (mSkid &lt; 0)
 			mSkid = 0.;
@@ -589,35 +629,45 @@
 	{
 		return mRadius;
 	}
-	Vector3 OdeWheel::getPosition() const
+	math::Vector3 OdeWheel::getPosition() const
 	{
 		YAKE_ASSERT( mpWheel );
 		return mpWheel-&gt;getPosition();
 	}
-	Quaternion OdeWheel::getOrientation() const
+	math::Vector3 OdeWheel::getDerivedPosition() const
 	{
 		YAKE_ASSERT( mpWheel );
+		return mpWheel-&gt;getDerivedPosition();
+	}
+	math::Quaternion OdeWheel::getOrientation() const
+	{
+		YAKE_ASSERT( mpWheel );
 		return mpWheel-&gt;getOrientation();
 	}
+	math::Quaternion OdeWheel::getDerivedOrientation() const
+	{
+		YAKE_ASSERT( mpWheel );
+		return mpWheel-&gt;getDerivedOrientation();
+	}
 	void OdeWheel::_applyDriveTq( const real tq )
 	{
 		//std::cout &lt;&lt; &quot;DTQ=&quot; &lt;&lt; tq &lt;&lt; &quot;\n&quot;;
-		//_applyTq( Vector3::kUnitX * tq );
+		//_applyTq( math::Vector3::kUnitX * tq );
 
 		if (mBrakeRatio &gt; 0.01)
-			_applyBrakeTq( Vector3::kUnitX * mBrakeRatio * 1.5 );
+			_applyBrakeTq( math::Vector3::kUnitX * mBrakeRatio * 1.5 );
 
 		const real targetVel = tq &lt; 0. ? -40 : 40;
 		_applyMotor( targetVel, - tq * 0.0075 );
 	}
-	void OdeWheel::_applyTq( const Vector3&amp; torque )
+	void OdeWheel::_applyTq( const math::Vector3&amp; torque )
 	{
 		mpWheel-&gt;getBody().addTorque( mpWheel-&gt;getOrientation() * torque );
 	}
-	void OdeWheel::_applyBrakeTq( const Vector3 &amp; torque )
+	void OdeWheel::_applyBrakeTq( const math::Vector3 &amp; torque )
 	{
-		Vector3 linVel = mpWheel-&gt;getBody().getLinearVelocity();
-		Vector3 dir = mpWheel-&gt;getOrientation() * Vector3::kUnitX;
+		math::Vector3 linVel = mpWheel-&gt;getBody().getLinearVelocity();
+		math::Vector3 dir = mpWheel-&gt;getOrientation() * math::Vector3::kUnitX;
 		if (dir.dotProduct(linVel) &gt; 0)
 		{
 			std::cout &lt;&lt; &quot;BRK+\n&quot;;
@@ -650,21 +700,53 @@
 	//-----------------------------------------------------
 	// Class: GenericThruster
 	//-----------------------------------------------------
-	GenericThruster::GenericThruster() : mThrottle(0)
+	GenericThruster::GenericThruster() : mVoltage( 0 ), mGain( 1.0 )
 	{
 	}
-	void GenericThruster::setThrottle( real throttle )
+	void GenericThruster::setInputSignal( real voltage )
 	{
-		mThrottle = (throttle &lt; 0.) ? 0. : ((throttle &gt; 1.) ? 1. : throttle);
+	    mVoltage = voltage;
 	}
-	real GenericThruster::getThrottle() const
+	real GenericThruster::getInputSignal() const
 	{
-		return mThrottle;
+	    return mVoltage;
 	}
 	void GenericThruster::updateSimulation( real timeElapsed )
 	{
-		setForce( getMinimumForce() + mThrottle * ( getMaximumForce() - getMinimumForce() ) );
+	   setForce( mVoltage * mGain ); 
 	}
+	void GenericThruster::setGain( real gain )
+	{
+	    mGain = gain;
+	}
+	real GenericThruster::getGain() const
+	{
+	    return mGain;
+	}
+	
+	//-----------------------------------------------------
+	// Class: GenericLinearThruster
+	//-----------------------------------------------------
+	GenericLinearThruster::GenericLinearThruster() : mVoltage( 0 )
+	{
+	}
+	void GenericLinearThruster::setInputSignal( real voltage )
+	{
+		mVoltage = voltage;
+	}
+	real GenericLinearThruster::getInputSignal() const
+	{
+		return mVoltage;
+	}
+	void GenericLinearThruster::updateSimulation( real timeElapsed )
+	{
+	    real abs_force = getMinimumForce() + math::Math::Abs( mVoltage ) * ( getMaximumForce() - getMinimumForce() );
+	    
+	    if ( abs_force &gt; getMaximumForce() )
+		abs_force = getMaximumForce();
+	    
+	    setForce( math::Math::Sign( mVoltage )*abs_force );
+	}
 
 	//-----------------------------------------------------
 	// Class: GenericMountedThruster
@@ -675,19 +757,26 @@
 	void GenericMountedThruster::onApplyToTargets()
 	{
 		YAKE_ASSERT(mThruster);
+
 		if (!mThruster)
 			return;
+		
+		if ( mThruster-&gt;getForce() == 0 )
+		    return;
+
 		const MountPoint* mp = getMountPoint();
-		const Vector3 pos = mp ? mp-&gt;getDerivedPosition() : Vector3::kZero;
-		const Quaternion rot = mp ? mp-&gt;getDerivedOrientation() : Quaternion::kIdentity;
-		const Vector3 f = mThruster-&gt;getForce() * ( rot * -Vector3::kUnitZ );
-		
+		const math::Vector3 pos = mp ? mp-&gt;getDerivedPosition() : math::Vector3::kZero;
+		const math::Quaternion rot = mp ? mp-&gt;getDerivedOrientation() : math::Quaternion::kIdentity;
+		const math::Vector3 f = mThruster-&gt;getForce() * ( rot * -math::Vector3::kUnitZ );
+
 		ConstDequeIterator&lt; BodyPtrList &gt; itBody( mTargets );
 		while (itBody.hasMoreElements())
 		{
 			physics::IBody* pBody = itBody.getNext();
+			
 			pBody-&gt;addForceAtPos( f, pos );
 		}
 	}
 } // namespace vehicle
 } // namespace yake
+

Modified: trunk/yake/src/yapp/vehicle/yakeOdeEngine.cpp
===================================================================
--- trunk/yake/src/yapp/vehicle/yakeOdeEngine.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/vehicle/yakeOdeEngine.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -228,3 +228,4 @@
 	}
 } // namespace vehicle
 } // namespace yake
+

Modified: trunk/yake/src/yapp/vehicle/yakeVehicle.cpp
===================================================================
--- trunk/yake/src/yapp/vehicle/yakeVehicle.cpp	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/src/yapp/vehicle/yakeVehicle.cpp	2006-03-19 17:54:00 UTC (rev 1302)
@@ -64,38 +64,37 @@
 	}
 
 	//-----------------------------------------------------
-	// Class: IThruster
+	// Class: ILinearThruster
 	//-----------------------------------------------------
-	IThruster::IThruster() :
+	ILinearThruster::ILinearThruster() :
 		mMinForce(0.),
-		mMaxForce(1.),
-		mForce(0.)
+		mMaxForce(1.)
 	{
 	}
-	IThruster::~IThruster()
+	ILinearThruster::~ILinearThruster()
 	{
 	}
-	void IThruster::setForce( real force )
+	void ILinearThruster::setForce( real force )
 	{
 		mForce = force;
 	}
-	void IThruster::setMinimumForce( real force )
+	void ILinearThruster::setMinimumForce( real force )
 	{
 		mMinForce = force;
 	}
-	real IThruster::getMinimumForce() const
+	real ILinearThruster::getMinimumForce() const
 	{
 		return mMinForce;
 	}
-	void IThruster::setMaximumForce( real force )
+	void ILinearThruster::setMaximumForce( real force )
 	{
 		mMaxForce = force;
 	}
-	real IThruster::getMaximumForce() const
+	real ILinearThruster::getMaximumForce() const
 	{
 		return mMaxForce;
 	}
-	real IThruster::getForce() const
+	real ILinearThruster::getForce() const
 	{
 		return mForce;
 	}
@@ -133,3 +132,4 @@
 
 } // namespace vehicle
 } // namespace yake
+

Modified: trunk/yake/yake/audio/yakeAudio.h
===================================================================
--- trunk/yake/yake/audio/yakeAudio.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/audio/yakeAudio.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -32,3 +32,4 @@
 #include &lt;yake/audio/yakeAudible.h&gt;
 
 #endif
+

Modified: trunk/yake/yake/audio/yakeAudioSystem.h
===================================================================
--- trunk/yake/yake/audio/yakeAudioSystem.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/audio/yakeAudioSystem.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -75,14 +75,19 @@
 	{
 	public:
 		virtual ~ISource() {}
-		virtual void setVelocity( const Vector3 &amp; velocity ) = 0;
-		virtual Vector3 getVelocity() const = 0;
+		virtual void setVelocity( const math::Vector3 &amp; velocity ) = 0;
+		virtual math::Vector3 getVelocity() const = 0;
 
 		virtual void setSoundData( ISoundData* pSoundData ) = 0;
 		//virtual void setSoundData( const String &amp; resourceName ) = 0;
 		virtual void play() = 0;
 		virtual void stop() = 0;
 		virtual void pause() = 0;
+
+		virtual Vector3 getDerivedPosition() const
+		{ return this-&gt;getPosition(); }
+		virtual Quaternion getDerivedOrientation() const
+		{ return this-&gt;getOrientation(); }
 	};
 
 	/** A listener in a world.
@@ -91,8 +96,13 @@
 	{
 	public:
 		virtual ~IListener() {}
-		virtual void setVelocity( const Vector3 &amp; velocity ) = 0;
-		virtual Vector3 getVelocity() const = 0;
+		virtual void setVelocity( const math::Vector3 &amp; velocity ) = 0;
+		virtual math::Vector3 getVelocity() const = 0;
+
+		virtual Vector3 getDerivedPosition() const
+		{ return this-&gt;getPosition(); }
+		virtual Quaternion getDerivedOrientation() const
+		{ return this-&gt;getOrientation(); }
 	};
 
 	/** Represents an environment in which an audio simulation takes place.

Modified: trunk/yake/yake/audio/yakePCH.h
===================================================================
--- trunk/yake/yake/audio/yakePCH.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/audio/yakePCH.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -30,3 +30,4 @@
 #include &lt;yake/base/yake.h&gt;
 
 #endif
+

Modified: trunk/yake/yake/base/math/yakeColor.h
===================================================================
--- trunk/yake/yake/base/math/yakeColor.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/math/yakeColor.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -35,7 +35,7 @@
 #	include &quot;yakePrerequisites.h&quot;
 #endif
 // Yake
-#include &quot;yakeMath.h&quot;
+#include &quot;yake/base/math/yakeMath.h&quot;
 
 //============================================================================
 //    INTERFACE STRUCTURES / UTILITY CLASSES
@@ -142,3 +142,4 @@
 #include &lt;yake/base/math/yakeColor.inl&gt;
 
 #endif // YAKE_BASE_MATH_COLOR_H
+

Modified: trunk/yake/yake/base/math/yakeColor.inl
===================================================================
--- trunk/yake/yake/base/math/yakeColor.inl	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/math/yakeColor.inl	2006-03-19 17:54:00 UTC (rev 1302)
@@ -250,3 +250,4 @@
 
 } // math
 } // yake
+

Modified: trunk/yake/yake/base/math/yakeGeometry.h
===================================================================
--- trunk/yake/yake/base/math/yakeGeometry.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/math/yakeGeometry.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -114,3 +114,4 @@
 }
 }
 #endif
+

Modified: trunk/yake/yake/base/math/yakeMath.h
===================================================================
--- trunk/yake/yake/base/math/yakeMath.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/math/yakeMath.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -32,10 +32,10 @@
 //============================================================================
 // Standard headers
 #ifndef YAKE_BASE_PREREQUISITES_H
-#	include &quot;yakePrerequisites.h&quot;
+#	include &quot;yake/base/yakePrerequisites.h&quot;
 #endif
 // Yake
-#include &quot;yakeRand.h&quot;
+#include &quot;yake/base/math/yakeRand.h&quot;
 
 //============================================================================
 //    INTERFACE STRUCTURES / UTILITY CLASSES
@@ -235,3 +235,4 @@
 } // yake
 
 #endif // YAKE_BASE_MATH_MATH_H
+

Modified: trunk/yake/yake/base/math/yakeMatrix3.h
===================================================================
--- trunk/yake/yake/base/math/yakeMatrix3.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/math/yakeMatrix3.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -32,11 +32,11 @@
 //============================================================================
 // Standard headers
 #ifndef YAKE_BASE_PREREQUISITES_H
-#	include &quot;yakePrerequisites.h&quot;
+#	include &quot;yake/base/yakePrerequisites.h&quot;
 #endif
 // Yake
-#include &quot;yakeMath.h&quot;
-#include &quot;yakeVector3.h&quot;
+#include &quot;yake/base/math/yakeMath.h&quot;
+#include &quot;yake/base/math/yakeVector3.h&quot;
 
 // NB All code adapted from Wild Magic 0.2 Matrix math (free source code)
 // <A HREF="http://www.magic-software.com">http://www.magic-software.com</A>
@@ -228,3 +228,4 @@
 } // yake
 
 #endif // YAKE_BASE_MATH_MATRIX3_H
+

Modified: trunk/yake/yake/base/math/yakeQuaternion.h
===================================================================
--- trunk/yake/yake/base/math/yakeQuaternion.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/math/yakeQuaternion.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -32,10 +32,10 @@
 //============================================================================
 // Standard headers
 #ifndef YAKE_BASE_PREREQUISITES_H
-#	include &quot;yakePrerequisites.h&quot;
+#	include &quot;yake/base/math/yakePrerequisites.h&quot;
 #endif
 // Yake
-#include &quot;yakeMath.h&quot;
+#include &quot;yake/base/math/yakeMath.h&quot;
 
 //============================================================================
 //    INTERFACE STRUCTURES / UTILITY CLASSES
@@ -52,19 +52,19 @@
         inline Quaternion (
             real fW = 1.0,
             real fX = 0.0, real fY = 0.0, real fZ = 0.0)
-		{
+	{
 			w = fW;
 			x = fX;
 			y = fY;
 			z = fZ;
-		}
+	}
         inline Quaternion (const Quaternion&amp; rkQ)
-		{
+	{
 			w = rkQ.w;
 			x = rkQ.x;
 			y = rkQ.y;
 			z = rkQ.z;
-		}
+	}
 	inline Quaternion ( real angle, const Vector3 &amp; axis )
 	{
 		this-&gt;FromAngleAxis( angle, axis );
@@ -81,13 +81,13 @@
         void ToAxes (Vector3&amp; xAxis, Vector3&amp; yAxis, Vector3&amp; zAxis) const;
 
         inline Quaternion&amp; operator= (const Quaternion&amp; rkQ)
-		{
-			w = rkQ.w;
-			x = rkQ.x;
-			y = rkQ.y;
-			z = rkQ.z;
-			return *this;
-		}
+	{
+		w = rkQ.w;
+		x = rkQ.x;
+		y = rkQ.y;
+		z = rkQ.z;
+		return *this;
+	}
         Quaternion operator+ (const Quaternion&amp; rkQ) const;
         Quaternion operator- (const Quaternion&amp; rkQ) const;
         Quaternion operator* (const Quaternion&amp; rkQ) const;
@@ -136,11 +136,16 @@
         static const Quaternion kIdentity;
 
         real w, x, y, z;
-	};
+    };
 
+    inline std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; lhs, const Quaternion&amp; rhs )
+    {
+	lhs &lt;&lt; rhs.x &lt;&lt; &quot; &quot; &lt;&lt; rhs.y &lt;&lt; &quot; &quot; &lt;&lt; rhs.z &lt;&lt; &quot; &quot; &lt;&lt; rhs.w;
+	return lhs;
+    }
+
 } // math
 } // yake
 
-#endif // YAKE_BASE_MATH_QUATERNION_H
+#endif // YAKE_MATH_QUATERNION_H
 
-

Modified: trunk/yake/yake/base/math/yakeVector3.h
===================================================================
--- trunk/yake/yake/base/math/yakeVector3.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/math/yakeVector3.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -32,11 +32,11 @@
 //============================================================================
 // Standard headers
 #ifndef YAKE_BASE_PREREQUISITES_H
-#	include &quot;yakePrerequisites.h&quot;
+#	include &quot;yake/base/yakePrerequisites.h&quot;
 #endif
 // Yake
-#include &quot;yakeMath.h&quot;
-#include &quot;yakeQuaternion.h&quot;
+#include &quot;yake/base/math/yakeMath.h&quot;
+#include &quot;yake/base/math/yakeQuaternion.h&quot;
 
 //============================================================================
 //    INTERFACE STRUCTURES / UTILITY CLASSES
@@ -415,15 +415,16 @@
         static const Vector3 kUnitX;
         static const Vector3 kUnitY;
         static const Vector3 kUnitZ;
-        static const Vector3 kUnitScale;
+	static const Vector3 kUnitScale;
 
     };
-	inline ::std::ostream&amp; operator &lt;&lt; ( ::std::ostream&amp; lhs, const Vector3 &amp; rhs )
-	{
-		lhs &lt;&lt; rhs.x &lt;&lt; &quot; &quot; &lt;&lt; rhs.y &lt;&lt; &quot; &quot; &lt;&lt; rhs.z;
-		return lhs;
-	}
 
+    inline std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; lhs, const Vector3&amp; rhs )
+    {
+	lhs &lt;&lt; rhs.x &lt;&lt; &quot; &quot; &lt;&lt; rhs.y &lt;&lt; &quot; &quot; &lt;&lt; rhs.z;
+	return lhs;
+    }
+
 } // math
 } // yake
 

Modified: trunk/yake/yake/base/mpl/yakeBuildArguments.h
===================================================================
--- trunk/yake/yake/base/mpl/yakeBuildArguments.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/mpl/yakeBuildArguments.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -31,7 +31,7 @@
 //    IMPLEMENTATION HEADERS
 //============================================================================
 // Yake
-#include &quot;yakeBuildIteration.h&quot;
+#include &quot;yake/base/mpl/yakeBuildIteration.h&quot;
 
 //============================================================================
 //    INTERFACE STRUCTURES / UTILITY CLASSES

Modified: trunk/yake/yake/base/mpl/yakeBuildIteration.h
===================================================================
--- trunk/yake/yake/base/mpl/yakeBuildIteration.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/mpl/yakeBuildIteration.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -56,3 +56,4 @@
 #define YAKE_ITER_FON_N( INTERFACE ) YAKE_ITER_FON_9( INTERFACE )
 
 #endif // YAKE_BASE_MPL_BUILDITERATION_H
+

Modified: trunk/yake/yake/base/native/yakeNative.h
===================================================================
--- trunk/yake/yake/base/native/yakeNative.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/native/yakeNative.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -86,3 +86,4 @@
 } // yake
 
 #endif // YAKE_BASE_NATIVE_NATIVE_H
+

Modified: trunk/yake/yake/base/templates/yakePointer.h
===================================================================
--- trunk/yake/yake/base/templates/yakePointer.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/templates/yakePointer.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -32,7 +32,7 @@
 //============================================================================
 // Standard headers
 #ifndef YAKE_BASEPREREQUISITES_H
-#	include &quot;../yakePrerequisites.h&quot;
+#	include &lt;yake/base/yakePrerequisites.h&gt;
 #endif
 // Boost
 #include &lt;boost/shared_ptr.hpp&gt;
@@ -91,7 +91,7 @@
 	};
 
 	template&lt;class T, class U&gt;
-    bool operator==(SharedPtr&lt;T&gt; const &amp; a, SharedPtr&lt;U&gt; const &amp; b)
+	bool operator==(SharedPtr&lt;T&gt; const &amp; a, SharedPtr&lt;U&gt; const &amp; b)
 	{
 		return (::boost::shared_ptr&lt;T&gt;(a) == ::boost::shared_ptr&lt;U&gt;(b) );
 	}

Modified: trunk/yake/yake/base/templates/yakeRegistry.h
===================================================================
--- trunk/yake/yake/base/templates/yakeRegistry.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/templates/yakeRegistry.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -32,7 +32,7 @@
 //============================================================================
 // Standard headers
 #ifndef YAKE_BASEPREREQUISITES_H
-#include &quot;../yakePrerequisites.h&quot;
+#include &quot;yake/base/yakePrerequisites.h&quot;
 #endif
 // Yake
 #include &lt;yake/base/yakeException.h&gt;

Modified: trunk/yake/yake/base/yake.h
===================================================================
--- trunk/yake/yake/base/yake.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/yake.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -54,3 +54,4 @@
 } // yake
 
 #endif // YAKE_BASE_YAKE_H
+

Modified: trunk/yake/yake/base/yakeConfigFile.h
===================================================================
--- trunk/yake/yake/base/yakeConfigFile.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/yakeConfigFile.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -32,7 +32,7 @@
 //============================================================================
 // Standard headers
 #ifndef YAKE_BASE_PREREQUISITES_H
-#	include &quot;yakePrerequisites.h&quot;
+#	include &lt;yake/base/yakePrerequisites.h&gt;
 #endif
 
 //============================================================================
@@ -145,3 +145,4 @@
 } // yake
 
 #endif // YAKE_BASE_CONFIGFILE_H
+

Modified: trunk/yake/yake/base/yakeLibrary.h
===================================================================
--- trunk/yake/yake/base/yakeLibrary.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/yakeLibrary.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -66,7 +66,7 @@
 } // base
 } // yake
 
-// todo plattform independent library extension?
+// todo platform independent library extension?
 // windows : &quot;.dll&quot;
 // linux : &quot;.so&quot;
 #define YAKE_USE_LIB( dllname ) \
@@ -74,3 +74,4 @@
 	YAKE_ASSERT( pDynLib##dllname ).debug( &quot;Out of memory.&quot; );
 
 #endif // YAKE_BASE_LIBRARY_H
+

Modified: trunk/yake/yake/base/yakeMovable.h
===================================================================
--- trunk/yake/yake/base/yakeMovable.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/yakeMovable.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -51,7 +51,6 @@
 */
 class YAKE_BASE_API Movable
 {
-	YAKE_DECLARE_CLASS( yake::Movable );
 protected:
 	Movable();
 // Class
@@ -60,12 +59,15 @@
 
 // Methods
 public:
-	virtual void setPosition( const Vector3&amp; rPosition ) = 0;
-	virtual void setOrientation( const Quaternion&amp; rOrientation ) = 0;
-	virtual Vector3 getPosition() const = 0;
-	virtual Quaternion getOrientation() const = 0;
+	virtual void setPosition( const math::Vector3&amp; rPosition ) = 0;
+	virtual void setOrientation( const math::Quaternion&amp; rOrientation ) = 0;
+	virtual math::Vector3 getPosition() const = 0;
+	virtual math::Quaternion getOrientation() const = 0;
+	virtual math::Vector3 getDerivedPosition() const = 0;
+	virtual math::Quaternion getDerivedOrientation() const = 0;
+	
 
-	inline virtual void translate( const Vector3&amp; rDelta )
+	inline virtual void translate( const math::Vector3&amp; rDelta )
 	{
 		setPosition( getPosition() + rDelta );
 	}

Modified: trunk/yake/yake/base/yakeProcessor.h
===================================================================
--- trunk/yake/yake/base/yakeProcessor.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/yakeProcessor.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -154,3 +154,4 @@
 } // yake
 
 #endif // YAKE_BASE_PROCESSOR_H
+

Modified: trunk/yake/yake/base/yakeString.h
===================================================================
--- trunk/yake/yake/base/yakeString.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/yakeString.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -54,6 +54,15 @@
 		lhs += ss.str();
 		return lhs;
 	}
+
+	template&lt;typename T&gt;
+	String operator &lt;&lt; ( const String&amp; lhs, const T&amp; rhs)
+	{
+		StrStream ss;
+		ss &lt;&lt; rhs;
+		return lhs + ss.str();
+	}
+
 	typedef Vector&lt;String&gt; StringVector;
 
 	class YAKE_BASE_API StringUtil

Modified: trunk/yake/yake/base/yakeTaggedListenerManager.h
===================================================================
--- trunk/yake/yake/base/yakeTaggedListenerManager.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/base/yakeTaggedListenerManager.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -40,7 +40,7 @@
 		listeners_.push_back( listener_list::value_type(listener,mode) );
 		if (!tag.empty())
 		{
-			tag_listener_map::const_iterator it = listenerMap_.find(tag);
+			typename tag_listener_map::const_iterator it = listenerMap_.find(tag);
 			YAKE_ASSERT( it == listenerMap_.end() );
 			if (it != listenerMap_.end())
 				listenerMap_.insert( tag_listener_map::value_type( tag, listener ) );
@@ -49,7 +49,7 @@
 	template&lt;typename T_listener&gt;
 	typename ListenerManager&lt;T_listener&gt;::listener_type* ListenerManager&lt;T_listener&gt;::getListener(const std::string&amp; tag) const
 	{
-			tag_listener_map::const_iterator it = listenerMap_.find(tag);
+			typename tag_listener_map::const_iterator it = listenerMap_.find(tag);
 			YAKE_ASSERT( it != listenerMap_.end() );
 			if (it == listenerMap_.end())
 				return 0;

Modified: trunk/yake/yake/graphics/yakeGeometryAccess.h
===================================================================
--- trunk/yake/yake/graphics/yakeGeometryAccess.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/graphics/yakeGeometryAccess.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -62,15 +62,15 @@
 
 		virtual bool lockPositions( uint32 start, uint32 count, bool bRead = false ) = 0;
 		virtual bool unlockPositions() = 0;
-		virtual bool setPosition( uint32 index, const Vector3 &amp; position ) = 0;
+		virtual bool setPosition( uint32 index, const math::Vector3 &amp; position ) = 0;
 
 		virtual bool lockTexCoords( uint16 set, uint32 start, uint32 count, bool bRead = false ) = 0;
 		virtual bool unlockTexCoords( uint16 set ) = 0;
-		virtual bool setTexCoord( uint16 set, uint16 index, const Vector3 &amp; uv ) = 0;
+		virtual bool setTexCoord( uint16 set, uint16 index, const math::Vector3 &amp; uv ) = 0;
 
 		virtual bool lockColours( uint32 start, uint32 count, bool bRead = false ) = 0;
 		virtual bool unlockColours() = 0;
-		virtual bool setColour( uint32 index, const Color &amp; colour ) = 0;
+		virtual bool setColour( uint32 index, const math::Color &amp; colour ) = 0;
 
 		virtual bool lockIndices( uint32 start, uint32 count ) = 0;
 		virtual bool setIndex( uint32 index, uint32 value ) = 0;
@@ -94,19 +94,19 @@
 
 		virtual bool lockPositions( uint32 start, uint32 count, bool bRead = false ) = 0;
 		virtual bool unlockPositions() = 0;
-		virtual bool setPosition( uint32 index, const Vector3 &amp; position ) = 0;
+		virtual bool setPosition( uint32 index, const math::Vector3 &amp; position ) = 0;
 
 		virtual bool lockNormals( uint32 start, uint32 count, bool bRead = false ) = 0;
 		virtual bool unlockNormals() = 0;
-		virtual bool setNormal( uint32 index, const Vector3 &amp; normal ) = 0;
+		virtual bool setNormal( uint32 index, const math::Vector3 &amp; normal ) = 0;
 
 		virtual bool lockTexCoords( uint16 set, uint32 start, uint32 count, bool bRead = false ) = 0;
 		virtual bool unlockTexCoords( uint16 set ) = 0;
-		virtual bool setTexCoord( uint16 set, uint16 index, const Vector3 &amp; uv ) = 0;
+		virtual bool setTexCoord( uint16 set, uint16 index, const math::Vector3 &amp; uv ) = 0;
 
 		virtual bool lockColours( uint32 start, uint32 count, bool bRead = false ) = 0;
 		virtual bool unlockColours() = 0;
-		virtual bool setColour( uint32 index, const Color &amp; colour ) = 0;
+		virtual bool setColour( uint32 index, const math::Color&amp; colour ) = 0;
 
 		virtual bool lockIndices( uint32 start, uint32 count ) = 0;
 		virtual bool setIndex( uint32 index, uint32 value ) = 0;

Modified: trunk/yake/yake/graphics/yakeGraphicalWorld.h
===================================================================
--- trunk/yake/yake/graphics/yakeGraphicalWorld.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/graphics/yakeGraphicalWorld.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -42,6 +42,16 @@
 namespace yake {
 namespace graphics {
 
+	enum SceneDetailLevel
+	{
+	    /// Only points are rendered.
+	    SDL_POINTS = 1,
+	    /// Wireframe models are rendered.
+	    SDL_WIREFRAME = 2,
+	    /// Solid polygons are rendered.
+	    SDL_SOLID = 3
+	};
+
 	/**
 	*/
 	class YAKE_GRAPHICS_INTERFACE_API IParticleSystem : public GraphicsEntity
@@ -92,8 +102,8 @@
 		virtual void setEnabled( bool enabled ) = 0;
  		virtual void setCastsShadows( bool enabled ) = 0;
 
-		virtual void setDiffuseColour( const Color &amp; colour ) = 0;
-		virtual void setSpecularColour( const Color &amp; colour ) = 0;
+		virtual void setDiffuseColour( const math::Color&amp; colour ) = 0;
+		virtual void setSpecularColour( const math::Color&amp; colour ) = 0;
 
 		virtual void setAttenuation( real range, real constant, real linear, real quadratic ) = 0;
 		virtual real getAttenuationRange() const = 0;
@@ -110,8 +120,8 @@
 
 		/** Synonims for set/getOrientation.  Meaningful only for directional and spot lights
 		*/
-		virtual void setDirection( const Vector3&amp; rDirection ) = 0;
-		virtual Vector3 getDirection() const = 0;
+		virtual void setDirection( const math::Vector3&amp; rDirection ) = 0;
+		virtual math::Vector3 getDirection() const = 0;
 	};
 
 	/** A concrete instance of a mesh in a graphical world.
@@ -123,8 +133,9 @@
 		
 		virtual ISkeleton* getSkeleton() const = 0;
 		virtual void setVisible( bool visible ) = 0;
-		virtual void setMaterial( const String &amp; materialName ) = 0;
-		virtual void setSubEntityMaterial( const String &amp; subEntity, const String &amp; materialName ) = 0;
+		virtual void setMaterial( const String&amp; materialName ) = 0;
+		virtual void setSubEntityMaterial( const String&amp; subEntity, const String&amp; materialName ) = 0;
+		virtual void setRenderDetail( SceneDetailLevel sdl ) = 0;
 		//virtual void setReceivesShadows( bool receivesShadows ) = 0;
 		virtual void setCastsShadow( bool castsShadow ) = 0;
 	};
@@ -134,16 +145,6 @@
 	class YAKE_GRAPHICS_INTERFACE_API ICamera : public GraphicsEntity, public Movable
 	{
 	public:
-		enum SceneDetailLevel
-		{
-		/// Only points are rendered.
-			SDL_POINTS = 1,
-		/// Wireframe models are rendered.
-			SDL_WIREFRAME = 2,
-		/// Solid polygons are rendered.
-			SDL_SOLID = 3
-		};
-
 		enum ProjectionType
 		{
 			PT_ORTHOGRAPHIC,
@@ -183,30 +184,30 @@
 		Note that the 'up' vector for the camera will automatically be recalculated based on the
 		current 'up' vector (i.e. the roll will remain the same).
 		 */
-		virtual void setDirection( const Vector3&amp; rVec ) = 0;
+		virtual void setDirection( const math::Vector3&amp; rVec ) = 0;
 
         /** Gets the camera's direction.
 		*/
-		virtual Vector3 getDirection() const = 0;
+		virtual math::Vector3 getDirection() const = 0;
 
         /** Gets the camera's up vector.
 		 */
-		virtual Vector3 getUp() const = 0;
+		virtual math::Vector3 getUp() const = 0;
 
         /** Gets the camera's right vector.
 		 */
-		virtual Vector3 getRight() const = 0;
+		virtual math::Vector3 getRight() const = 0;
 		
 		virtual void setFixedYawEnabled( bool enabled ) = 0;
-		virtual void setFixedYawAxis( const Vector3&amp; yawAxis ) = 0;
+		virtual void setFixedYawAxis( const math::Vector3&amp; yawAxis ) = 0;
 	
 		/** Moves movable's position by the vector offset provided along it's own axes (relative to orientation).
 	 	*/
-		virtual void moveRelative( const Vector3&amp; rVec ) = 0;
-		virtual void lookAt( const Vector3&amp; target ) = 0;
+		virtual void moveRelative( const math::Vector3&amp; rVec ) = 0;
+		virtual void lookAt( const math::Vector3&amp; target ) = 0;
 
-		inline void rotate( const Quaternion&amp; q );
-		inline void rotate( const Vector3&amp; axis, real degrees );
+		inline void rotate( const math::Quaternion&amp; q );
+		inline void rotate( const math::Vector3&amp; axis, real degrees );
 		inline void pitch( const real degrees );
 		virtual void yaw( const real degrees ) = 0;
 		virtual void roll( const  real degrees ) = 0;
@@ -215,27 +216,27 @@
 			position.
 			@param screenX, screenY position where the ray intersects the viewport, in normalised screen coords [0,1]
 		*/
-		virtual Ray createCameraToViewportRay(const real screenX, const real screenY) const;
+		virtual math::Ray createCameraToViewportRay(const real screenX, const real screenY) const;
 
 		/** Retrieve the projection matrix. The matrix conforms to the right-handed rules.
 		*/
-		virtual Matrix4 getProjectionMatrix() const = 0;
-		virtual Matrix4 getViewMatrix() const = 0;
+		virtual math::Matrix4 getProjectionMatrix() const = 0;
+		virtual math::Matrix4 getViewMatrix() const = 0;
 	};
 
-	void ICamera::rotate(const Vector3 &amp; axis, real degrees)
+	void ICamera::rotate(const math::Vector3&amp; axis, real degrees)
 	{
-		Quaternion q;
-		q.FromAngleAxis(Math::AngleUnitsToRadians(degrees),axis);
-		rotate(q);
+	    math::Quaternion q;
+	    q.FromAngleAxis( math::Math::AngleUnitsToRadians(degrees), axis );
+	    rotate(q);
 	}
-	void ICamera::rotate(const Quaternion &amp; q)
+	void ICamera::rotate(const math::Quaternion &amp; q)
 	{
 		setOrientation( q * getOrientation() );
 	}
 	void ICamera::pitch( const real degrees )
 	{
-		const Vector3 xAxis = getOrientation() * Vector3::kUnitX;
+		const math::Vector3 xAxis = getOrientation() * math::Vector3::kUnitX;
 		rotate(xAxis, degrees);
 	}
 
@@ -261,10 +262,10 @@
 		};
 
 		/** Returns the position in parent's transform space. */
-		virtual Vector3 getPosition() const = 0;
+		virtual math::Vector3 getPosition() const = 0;
 		
 		/** Returns scene node position in transform space specified by ts parameter. */
-		virtual Vector3 getPosition( TransformSpace ts ) const = 0;
+		virtual math::Vector3 getPosition( TransformSpace ts ) const = 0;
 		
 		/** Adds a node as a child to this node.
 		*/
@@ -302,10 +303,12 @@
 
 		/** Set the scale for this node relative to the local coordinate system.
 		*/
-		virtual void setScale( const Vector3 &amp; scale ) = 0;
+		virtual void setScale( const math::Vector3 &amp; scale ) = 0;
 
-		virtual Vector3 getScale() const = 0;
+		virtual math::Vector3 getScale() const = 0;
 
+		virtual void setInheritScale( bool inherit ) = 0;
+
 		/** Returns a list of all child scene nodes of this scene node.
 		*/
 		virtual void getChildren( SceneNodePtrList&amp; ret, bool bRecursive = false ) const = 0;
@@ -357,31 +360,31 @@
 
 		/** Return the position as transformed through the hierarchy of nodes.
 		*/
-		virtual Vector3 getDerivedPosition() const = 0;
+		virtual math::Vector3 getDerivedPosition() const = 0;
 
 		/** Return the position as transformed through the hierarchy of nodes.
 		*/
-		virtual void getDerivedPosition( Vector3&amp; retPos ) const = 0;
+		virtual void getDerivedPosition( math::Vector3&amp; retPos ) const = 0;
 
 		/** Return the orientation as transformed through the hierarchy of nodes.
 		*/
-		virtual Quaternion getDerivedOrientation() const = 0;
+		virtual math::Quaternion getDerivedOrientation() const = 0;
 
 		/** Return the orientation as transformed through the hierarchy of nodes.
 		*/
-		virtual void getDerivedOrientation( Quaternion&amp; retRot ) const = 0;
+		virtual void getDerivedOrientation( math::Quaternion&amp; retRot ) const = 0;
 
 		/** Translate this scene node by a given amount.
 			@param rDelta amount of translation.
 			@param relativeTo TransformSpace to use for the translation.
 		*/
-		virtual void translate( const Vector3&amp; rDelta, const TransformSpace relativeTo = TS_PARENT ) = 0;
+		virtual void translate( const math::Vector3&amp; rDelta, const TransformSpace relativeTo = TS_PARENT ) = 0;
 
 		/** Rotate this scene node by a given amount.
 			@param rDelta amount of rotation.
 			@param relativeTo TransformSpace to use for the rotation.
 		*/
-		virtual void rotate( const Quaternion&amp; rDelta, const TransformSpace relativeTo = TS_PARENT ) = 0;
+		virtual void rotate( const math::Quaternion&amp; rDelta, const TransformSpace relativeTo = TS_PARENT ) = 0;
 	};
 
 	/** Viewport abstract interface.
@@ -394,6 +397,8 @@
 		virtual ICamera* getAttachedCamera() const = 0;
 		virtual void setDimensions( real left, real top, real width, real height ) = 0;
 		virtual void setZ( int z ) = 0;
+		virtual void setBackgroundColor( const math::Color&amp; col ) = 0;
+		virtual math::Color getBackgroundColor() const = 0;
 	};
 
 	class IMeshGeometryAccess;
@@ -445,7 +450,7 @@
 		virtual real getRenderWindowWidth() const = 0;
 		virtual real getRenderWindowHeight() const = 0;
 
-		virtual IEntity* pickEntity(const Ray&amp; ray) = 0;
+		virtual IEntity* pickEntity(const math::Ray&amp; ray) = 0;
 
 		YAKE_MEMBERSIGNAL_PUREINTERFACE( public, void(real), PreRender );
 		YAKE_MEMBERSIGNAL_PUREINTERFACE( public, void(real), PostRender );
@@ -462,3 +467,4 @@
 } // yake
 
 #endif // YAKE_GRAPHICALWORLD_H
+

Modified: trunk/yake/yake/graphics/yakeGraphicsSystem.h
===================================================================
--- trunk/yake/yake/graphics/yakeGraphicsSystem.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/graphics/yakeGraphicsSystem.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -99,3 +99,4 @@
 } // yake
 
 #endif // YAKE_GRAPHICSSYSTEM_H
+

Modified: trunk/yake/yake/object/ClassAndObjectIdManager.inl
===================================================================
--- trunk/yake/yake/object/ClassAndObjectIdManager.inl	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/object/ClassAndObjectIdManager.inl	2006-03-19 17:54:00 UTC (rev 1302)
@@ -103,7 +103,7 @@
 	template&lt;typename classentry_type,typename objectid_type&gt;
 	ResultCode ClassAndObjectIdManager&lt;classentry_type,objectid_type&gt;::registerClassId(const ClassId clsId, const classdata_type&amp; data)
 	{
-		ClassMap::const_iterator it = classes_.find( clsId );
+		typename ClassMap::const_iterator it = classes_.find( clsId );
 		if (it != classes_.end())
 		{
 			if (classIds_.find( clsId ) != classIds_.end())
@@ -124,7 +124,7 @@
 	template&lt;typename classentry_type,typename objectid_type&gt;
 	objectid_type ClassAndObjectIdManager&lt;classentry_type,objectid_type&gt;::createObjectId(const typename objectid_type::ClassId clsId)
 	{
-		ClassMap::iterator it = classes_.find( clsId );
+		typename ClassMap::iterator it = classes_.find( clsId );
 		if (it == classes_.end())
 			return ObjectId::kNull;
 		uint16 no = it-&gt;second.nextSerialNo();
@@ -137,7 +137,7 @@
 	template&lt;typename classentry_type,typename objectid_type&gt;
 	ResultCode ClassAndObjectIdManager&lt;classentry_type,objectid_type&gt;::addObjectId(const ObjectId&amp; objId)
 	{
-		ClassMap::iterator it = classes_.find( objId.classId() );
+		typename ClassMap::iterator it = classes_.find( objId.classId() );
 		if (it == classes_.end())
 			return RC_UNKNOWN_CLASS;
 		return it-&gt;second.addObjectId(objId);
@@ -145,7 +145,7 @@
 	template&lt;typename classentry_type,typename objectid_type&gt;
 	typename objectid_type::ObjectIdSet ClassAndObjectIdManager&lt;classentry_type,objectid_type&gt;::getObjectIds(const ClassId clsId) const
 	{
-		ClassMap::const_iterator it = classes_.find( clsId );
+		typename ClassMap::const_iterator it = classes_.find( clsId );
 		if (it == classes_.end())
 			return ObjectIdSet();
 		return it-&gt;second.getObjectIds();
@@ -153,16 +153,16 @@
 	template&lt;typename classentry_type,typename objectid_type&gt;
 	ResultCode ClassAndObjectIdManager&lt;classentry_type,objectid_type&gt;::removeObjectId(const ObjectId&amp; objId)
 	{
-		ClassMap::iterator it = classes_.find( objId.classId() );
+		typename ClassMap::iterator it = classes_.find( objId.classId() );
 		if (it == classes_.end())
 			return RC_UNKNOWN_CLASS;
 		return it-&gt;second.removeObjectId( objId );
 	}
 	template&lt;typename classentry_type,typename objectid_type&gt;
-	typename const classentry_type::data_type&amp; ClassAndObjectIdManager&lt;classentry_type,objectid_type&gt;::getClassData(const ClassId clsId) const
+	const typename classentry_type::data_type&amp; ClassAndObjectIdManager&lt;classentry_type,objectid_type&gt;::getClassData(const ClassId clsId) const
 	{
-		ClassMap::const_iterator it = classes_.find( clsId );
+		typename ClassMap::const_iterator it = classes_.find( clsId );
 		if (it == classes_.end())
 			throw &quot;ClassAndObjectIdManager&lt;&gt;::getClassData(): Class entry not found!&quot;;
 		return it-&gt;second.getData();
-	}
\ No newline at end of file
+	}

Modified: trunk/yake/yake/object/ObjectContainer.h
===================================================================
--- trunk/yake/yake/object/ObjectContainer.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/object/ObjectContainer.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -69,7 +69,7 @@
 		assert( !exists );
 		if (exists)
 			return false;
-		id2obj_.insert( IdObjMap::value_type(objId,obj) );
+		id2obj_.insert( typename IdObjMap::value_type(objId,obj) );
 		return true;
 	}
 	template&lt;typename object_type,typename objectid_type&gt;
@@ -78,7 +78,7 @@
 		assert( !objId.isNull() );
 		if (objId.isNull())
 			return 0;
-		IdObjMap::iterator it = id2obj_.find( objId );
+		typename IdObjMap::iterator it = id2obj_.find( objId );
 		assert( it != id2obj_.end() );
 		if (it == id2obj_.end())
 			return 0;
@@ -92,7 +92,7 @@
 		assert( !objId.isNull() );
 		if (objId.isNull())
 			return 0;
-		IdObjMap::const_iterator it = id2obj_.find( objId );
+		typename IdObjMap::const_iterator it = id2obj_.find( objId );
 		assert( it != id2obj_.end() );
 		if (it == id2obj_.end())
 			return 0;

Modified: trunk/yake/yake/object/ObjectManager.h
===================================================================
--- trunk/yake/yake/object/ObjectManager.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/object/ObjectManager.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -153,7 +153,7 @@
 		ClassIdSet ids = objMgr.getRegisteredClasses();
 		idMap.clear();
 		ClassId lastId = minId;
-		for (ClassIdSet::const_iterator itId = ids.begin(); itId != ids.end(); ++itId)
+		for (typename ClassIdSet::const_iterator itId = ids.begin(); itId != ids.end(); ++itId)
 		{
 			idMap.insert( std::make_pair(lastId++,*itId) );
 		}

Modified: trunk/yake/yake/object/ObjectManager.inl
===================================================================
--- trunk/yake/yake/object/ObjectManager.inl	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/object/ObjectManager.inl	2006-03-19 17:54:00 UTC (rev 1302)
@@ -56,7 +56,7 @@
 		assert( !id.empty() );
 		if (id.empty())
 			return std::make_pair(RC_INVALID_INPUT,0);
-		StringToClassIdMap::const_iterator it = strIdAliases_.find( id );
+		typename StringToClassIdMap::const_iterator it = strIdAliases_.find( id );
 		if (it == strIdAliases_.end())
 			return std::make_pair(RC_NOT_FOUND,0);
 		return std::make_pair(RC_OK,it-&gt;second);
@@ -94,7 +94,7 @@
 		if (rc != RC_OK)
 			return rc;
 
-		strIdAliases_.insert( StringToClassIdMap::value_type(name,clsId) );
+		strIdAliases_.insert( typename StringToClassIdMap::value_type(name,clsId) );
 
 		return RC_OK;
 	}
@@ -199,7 +199,7 @@
 	void ObjectManager&lt;obj_type,objectid_type&gt;::destroyAllObjects()
 	{
 		IdObjMap objs = objs_; // copy!
-		for (IdObjMap::const_iterator it = objs.begin(); it != objs.end(); ++it)
+		for (typename IdObjMap::const_iterator it = objs.begin(); it != objs.end(); ++it)
 		{
 			destroyObject( it-&gt;second );
 		}
@@ -215,7 +215,7 @@
 		assert( !obj-&gt;id().isNull() );
 		if (!obj-&gt;id().isNull())
 		{
-			IdObjMap::iterator it = objs_.find( obj-&gt;id() );
+			typename IdObjMap::iterator it = objs_.find( obj-&gt;id() );
 			if (it != objs_.end())
 				objs_.erase( obj-&gt;id() );
 		}
@@ -225,7 +225,7 @@
 		if (!idMgr_.hasClass( clsId ))
 		{
 			// try alias
-			ClassIdMap::const_iterator it = idAliases_.find( clsId );
+			typename ClassIdMap::const_iterator it = idAliases_.find( clsId );
 			assert( it != idAliases_.end() );
 			if (it == idAliases_.end())
 				return; //@FIXME or throw ?
@@ -245,7 +245,7 @@
 		data.destroy_( obj );
 	}
 	template&lt;typename obj_type, typename objectid_type&gt;
-	typename ObjectManager&lt;obj_type,objectid_type&gt;::object_type* ObjectManager&lt;obj_type,objectid_type&gt;::createObject(const std::string&amp; id, const objectid_type&amp; userObjId = objectid_type::kNull)
+	typename ObjectManager&lt;obj_type,objectid_type&gt;::object_type* ObjectManager&lt;obj_type,objectid_type&gt;::createObject(const std::string&amp; id, const objectid_type&amp; userObjId )
 	{
 		// check params
 		assert( !id.empty() );
@@ -259,7 +259,7 @@
 		return this-&gt;createObject( ret.second, userObjId );
 	}
 	template&lt;typename obj_type, typename objectid_type&gt;
-	typename ObjectManager&lt;obj_type,objectid_type&gt;::object_type* ObjectManager&lt;obj_type,objectid_type&gt;::createObject(const ClassId clsId, const objectid_type&amp; userObjId = objectid_type::kNull)
+	typename ObjectManager&lt;obj_type,objectid_type&gt;::object_type* ObjectManager&lt;obj_type,objectid_type&gt;::createObject(const ClassId clsId, const objectid_type&amp; userObjId)
 	{
 		if (!userObjId.isNull())
 		{
@@ -272,7 +272,7 @@
 		if (!idMgr_.hasClass( theClsId ))
 		{
 			// try alias
-			ClassIdMap::const_iterator it = idAliases_.find( theClsId );
+			typename ClassIdMap::const_iterator it = idAliases_.find( theClsId );
 			assert( it != idAliases_.end() );
 			if (it == idAliases_.end())
 				return 0;

Modified: trunk/yake/yake/object/common.h
===================================================================
--- trunk/yake/yake/object/common.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/object/common.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -48,10 +48,6 @@
 
 	/** Common types */
 
-	typedef unsigned __int16 uint16;
-	typedef unsigned __int32 uint32;
-	typedef unsigned __int8 uint8;
-
 	enum ResultCode
 	{
 		RC_OK,
@@ -82,7 +78,7 @@
 		@return true if element was erased, false if element couldn't be found in the container.
 	*/
 	template&lt;typename T&gt;
-		bool safeErase( T&amp; container, typename const T::value_type value)
+		bool safeErase( T&amp; container, const typename T::value_type value)
 	{
 		typename T::iterator it = std::find(container.begin(), container.end(), value);
 		if (it == container.end())
@@ -94,7 +90,7 @@
 		@return true if element was found in the container, false if not.
 	*/
 	template&lt;typename T&gt;
-		bool contains( const T&amp; container, typename const T::value_type&amp; value)
+		bool contains( const T&amp; container, const typename T::value_type&amp; value)
 	{
 		return (container.end() != std::find(container.begin(), container.end(), value));
 	}
@@ -102,7 +98,7 @@
 		@return true if element was found in the container, false if not.
 	*/
 	template&lt;typename T&gt;
-		bool map_contains( const T&amp; container, typename const T::key_type key)
+		bool map_contains( const T&amp; container, const typename T::key_type key)
 	{
 		return (container.end() != container.find(key));
 	}
@@ -111,3 +107,4 @@
 } // namespace yake
 
 #endif
+

Modified: trunk/yake/yake/physics/yakeAffectorZone.h
===================================================================
--- trunk/yake/yake/physics/yakeAffectorZone.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/physics/yakeAffectorZone.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -140,3 +140,4 @@
 }
 
 #endif
+

Modified: trunk/yake/yake/physics/yakePhysicsActor.h
===================================================================
--- trunk/yake/yake/physics/yakePhysicsActor.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/physics/yakePhysicsActor.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -45,13 +45,21 @@
 		virtual void onAddShape(IShape* pShape);
 	};
 
+	/** Structure describes collision event between two actors.
+	 * Respective collided shapes are supplied.
+	 */
 	struct ActorCollisionInfo
 	{
 		IActor*	pThis;
+		IShape* pThisShape_;
+
 		IActor*	pOther;
-		ActorCollisionInfo( IActor* pThisActor = 0, IActor* pOtherActor = 0) :
-			pThis( pThisActor ),
-			pOther( pOtherActor )
+		IShape* pOtherShape_;
+
+		ActorCollisionInfo( IActor* pThisActor = 0, IShape* pThisShape = 0, 
+				    IActor* pOtherActor = 0, IShape* pOtherShape = 0 ) :
+			pThis( pThisActor ), pThisShape_( pThisShape ),
+			pOther( pOtherActor ), pOtherShape_( pOtherShape )
 		{}
 	};
 
@@ -84,20 +92,22 @@
 		virtual IBody* getBodyPtr() const = 0;
 		virtual IBody&amp; getBody() const = 0;
 
-		virtual void setPosition(const Vector3&amp; position) = 0;
-		virtual Vector3 getPosition() const = 0;
+		// inherited from yake::Movable
+	//	virtual void setPosition(const math::Vector3&amp; position) = 0;
+	//	virtual math::Vector3 getPosition() const = 0;
 
-		virtual void setOrientation( const Quaternion &amp; rkOrientation ) = 0;
-		virtual Quaternion getOrientation() const = 0;
+	//	virtual void setOrientation( const math::Quaternion &amp; rkOrientation ) = 0;
+	//	virtual math::Quaternion getOrientation() const = 0;
 
 		virtual void setEnabled(const bool enabled) = 0;
 		virtual bool isEnabled() const = 0;
 
-		YAKE_MEMBERSIGNAL_PUREINTERFACE( public, void(ActorCollisionInfo&amp;), CollisionEntered )
-		YAKE_MEMBERSIGNAL_PUREINTERFACE( public, void(ActorCollisionInfo&amp;), CollisionExited )
+		YAKE_MEMBERSIGNAL_PUREINTERFACE( public, void(const ActorCollisionInfo&amp;), CollisionEntered )
+		YAKE_MEMBERSIGNAL_PUREINTERFACE( public, void(const ActorCollisionInfo&amp;), CollisionExited )
 	};
 	YAKE_PHYSICS_COMMON_POINTERS( IActor );
 
 }
 }
 #endif
+

Modified: trunk/yake/yake/physics/yakePhysicsAffectors.h
===================================================================
--- trunk/yake/yake/physics/yakePhysicsAffectors.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/physics/yakePhysicsAffectors.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -73,7 +73,7 @@
 
 	/** A directional constant acceleration affector. Actually it could be used for dynamic accelerations, too.
 	*/
-	class ConstantDirectionalAccelerationBodyAffector : public ConstantAccelerationBodyAffector&lt;Vector3&gt;
+	class ConstantDirectionalAccelerationBodyAffector : public ConstantAccelerationBodyAffector&lt;math::Vector3&gt;
 	{
 		YAKE_DECLARE_CONCRETE( ConstantDirectionalAccelerationBodyAffector, &quot;yake.constant_directional_acceleration&quot; )
 	public:
@@ -91,22 +91,21 @@
 	{
 		YAKE_DECLARE_CONCRETE( BodyConstantSphericalAccelerationAffector, &quot;yake.constant_spherical_acceleration&quot; )
 	protected:
-		Vector3		mPoint;
+		math::Vector3		mPoint;
 	public:
-		BodyConstantSphericalAccelerationAffector( const Vector3 &amp; point = Vector3::kZero, const real acc = 1. ) : 
+		BodyConstantSphericalAccelerationAffector( const math::Vector3 &amp; point = math::Vector3::kZero, const real acc = 1. ) : 
 			mPoint( point ), 
 			ConstantAccelerationBodyAffector&lt;real&gt;( acc )
 		{ }
 
 		virtual void applyTo( IBody &amp; rBody, const real timeElapsed )
 		{
-			Vector3 direction = rBody.getActor().getPosition() - mPoint;
+			math::Vector3 direction = rBody.getActor().getPosition() - mPoint;
 			direction.normalise();
 			rBody.addForce( direction * mAcceleration * rBody.getMass() );
 		}
 	};
 
-
 }
 }
 

Modified: trunk/yake/yake/physics/yakePhysicsAvatar.h
===================================================================
--- trunk/yake/yake/physics/yakePhysicsAvatar.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/physics/yakePhysicsAvatar.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -51,23 +51,23 @@
 	public:
 		struct Desc
 		{
-			Desc(	const Vector3 &amp; rkDimensions = Vector3(0,2,0),
-					const Vector3 &amp; rkPosition = Vector3::kZero,
-					const Quaternion &amp; rkOrientation = Quaternion::kIdentity) :
+			Desc(	const math::Vector3 &amp; rkDimensions = math::Vector3(0,2,0),
+					const math::Vector3 &amp; rkPosition = math::Vector3::kZero,
+					const math::Quaternion &amp; rkOrientation = math::Quaternion::kIdentity) :
 				position( rkPosition ),
 				orientation( rkOrientation ),
 				dimensions( rkDimensions )
 			{}
-			Vector3		position;
-			Quaternion	orientation;
-			Vector3		dimensions;
+			math::Vector3		position;
+			math::Quaternion	orientation;
+			math::Vector3		dimensions;
 		};
 	public:
 
-		virtual void setDimensions( const Vector3 &amp; rkDimensions ) = 0;
+		virtual void setDimensions( const math::Vector3 &amp; rkDimensions ) = 0;
 		virtual void setInfluenceByDynamics( const real ratio ) = 0;
 
-		virtual void setTargetVelocity( const Vector3 &amp; rkTargetVelocity ) = 0;
+		virtual void setTargetVelocity( const math::Vector3 &amp; rkTargetVelocity ) = 0;
 		virtual void jump() = 0;
 		virtual bool isJumping() const = 0;
 		virtual void duck(const bool yes) = 0;
@@ -82,3 +82,4 @@
 }
 
 #endif
+

Modified: trunk/yake/yake/physics/yakePhysicsBody.h
===================================================================
--- trunk/yake/yake/physics/yakePhysicsBody.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/physics/yakePhysicsBody.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -43,14 +43,14 @@
 
 	struct YAKE_PHYSICS_API Force
 	{
-		Vector3			force;
+		math::Vector3			force;
 		real				duration;
 		ReferenceFrame	frameType;
 
 		Force() :
 			duration(0)
 		{}
-		Force( const Vector3&amp; f, const real t, const ReferenceFrame rf = RF_GLOBAL ) :
+		Force( const math::Vector3&amp; f, const real t, const ReferenceFrame rf = RF_GLOBAL ) :
 			force(f),
 			duration(t),
 			frameType(rf)
@@ -100,20 +100,20 @@
 			}
 			void reset()
 			{
-				linVelocity = Vector3::kZero;
-				angVelocity = Vector3::kZero;
-				massOffset = Vector3::kZero;
+				linVelocity = math::Vector3::kZero;
+				angVelocity = math::Vector3::kZero;
+				massOffset = math::Vector3::kZero;
 				totalMass = real(1.);
 			}
-			Vector3		linVelocity;
-			Vector3		angVelocity;
+			math::Vector3		linVelocity;
+			math::Vector3		angVelocity;
 			real		totalMass;
-			Vector3		massOffset;
+			math::Vector3		massOffset;
 		};
 
 		struct MassDesc
 		{
-			MassDesc( real massOrDensity, const Vector3&amp; rOffset = Vector3::kZero, quantityType type = QT_MASS ) :
+			MassDesc( real massOrDensity, const math::Vector3&amp; rOffset = math::Vector3::kZero, quantityType type = QT_MASS ) :
 					quantity( massOrDensity ),
 					offset( rOffset ),
 					qType( type )
@@ -121,19 +121,19 @@
 
 			virtual ~MassDesc() {}
 
-			real 			quantity; /// For all of them. You can set total mass via setMass
-			Vector3		offset; /// Mass can be offseted. TODO Add rotation &quot;offset&quot;?
-			quantityType qType;
+			real 		quantity; /// For all of them. You can set total mass via setMass
+			math::Vector3		offset; /// Mass can be offseted. TODO Add rotation &quot;offset&quot;?
+			quantityType	qType;
 		};
 
 		struct SphereMassDesc : public MassDesc
 		{
 			SphereMassDesc(	real radiusValue,
-								real shapeDensity,
-								const Vector3&amp; rOffset = Vector3::kZero,
-								quantityType type = QT_MASS ) :
-									MassDesc( shapeDensity, rOffset, type ),
-							 		radius( radiusValue )
+					real shapeDensity,
+					const math::Vector3&amp; rOffset = math::Vector3::kZero,
+					quantityType type = QT_MASS ) :
+							MassDesc( shapeDensity, rOffset, type ),
+					 		radius( radiusValue )
 			{}
 
 			real radius;
@@ -142,32 +142,32 @@
 		struct BoxMassDesc : public MassDesc
 		{
 			BoxMassDesc(	real boxSizeX,
-							real boxSizeY,
-							real boxSizeZ,
-							real shapeDensity,
-							const Vector3&amp; rOffset = Vector3::kZero,
-							quantityType type = QT_MASS ) :
-								MassDesc( shapeDensity, rOffset, type ),
-								sizeX( boxSizeX ),
-								sizeY( boxSizeY ),
-								sizeZ( boxSizeZ )
+					real boxSizeY,
+					real boxSizeZ,
+					real shapeDensity,
+					const math::Vector3&amp; rOffset = math::Vector3::kZero,
+					quantityType type = QT_MASS ) :
+						MassDesc( shapeDensity, rOffset, type ),
+					 	sizeX( boxSizeX ),
+						sizeY( boxSizeY ),
+						sizeZ( boxSizeZ )
 			{}
 
-			real	sizeX;
+			real sizeX;
 			real sizeY;
 			real sizeZ;
 		};
 
 		struct CapsuleMassDesc : public MassDesc /// Corresponds to ODE CappedCylinder
 		{
-			CapsuleMassDesc(	real capRadius,
-								real capLength,
-								real shapeDensity,
-								const Vector3&amp; rOffset = Vector3::kZero,
-								quantityType type = QT_MASS ) :
-									MassDesc( shapeDensity, rOffset, type ),
-									radius( capRadius ),
-									length( capLength )
+			CapsuleMassDesc( real capRadius,
+				         real capLength,
+					 real shapeDensity,
+				         const math::Vector3&amp; rOffset = math::Vector3::kZero,
+					 quantityType type = QT_MASS ) :
+						MassDesc( shapeDensity, rOffset, type ),
+						radius( capRadius ),
+						length( capLength )
 			{}
 
 			real radius;
@@ -176,14 +176,14 @@
 
 		struct CylinderMassDesc : public MassDesc
 		{
-			CylinderMassDesc(	real cylRadius,
-								real cylLength,
-								real shapeDensity,
-								const Vector3&amp; rOffset = Vector3::kZero,
-								quantityType type = QT_MASS ) :
-									MassDesc( shapeDensity, rOffset, type ),
-									radius( cylRadius ),
-									length( cylLength )
+			CylinderMassDesc( real cylRadius,
+					  real cylLength,
+					  real shapeDensity,
+					  const math::Vector3&amp; rOffset = math::Vector3::kZero,
+					  quantityType type = QT_MASS ) :
+						MassDesc( shapeDensity, rOffset, type ),
+						radius( cylRadius ),
+						length( cylLength )
 			{}
 
 			real radius;
@@ -225,19 +225,19 @@
 
 		/** Sets the linear velocity of the body/actor directly, i.e. with immediate effect.
 		*/
-		virtual void setLinearVelocity( const Vector3&amp; rVelocity ) = 0;
+		virtual void setLinearVelocity( const math::Vector3&amp; rVelocity ) = 0;
 
 		/** Returns the current velocity of the body.
 		*/
-		virtual Vector3 getLinearVelocity() const = 0;
+		virtual math::Vector3 getLinearVelocity() const = 0;
 
 		/** Sets the angular velocity [rad/s] of the body/actor directly, i.e. with immediate effect.
 		*/
-		virtual void setAngularVelocity( const Vector3&amp; rVelocity ) = 0;
+		virtual void setAngularVelocity( const math::Vector3&amp; rVelocity ) = 0;
 
 		/** Returns the angular velocity of the body in [rad/s].
 		*/
-		virtual Vector3 getAngularVelocity() const = 0;
+		virtual math::Vector3 getAngularVelocity() const = 0;
 
 		/** Adds a force. The specifics are detailed in the Force object.
 		*/
@@ -245,42 +245,44 @@
 
 		/** Adds a force defined in the global reference frame. 
 		*/
-		virtual void addForce( const Vector3&amp; rForce ) = 0;
+		virtual void addForce( const math::Vector3&amp; rForce ) = 0;
 
 		/** Adds a force defined in the global reference frame, acting at a position defined
 			in the global reference frame.
 		*/
-		virtual void addForceAtPos( const Vector3&amp; rForce, const Vector3&amp; rPos ) = 0;
+		virtual void addForceAtPos( const math::Vector3&amp; rForce, const math::Vector3&amp; rPos ) = 0;
 
 		/** Adds a force defined in the global reference frame, acting at a position defined
 			in the local reference frame.
 		*/
-		virtual void addForceAtLocalPos( const Vector3&amp; rForce, const Vector3&amp; rPos ) = 0;
+		virtual void addForceAtLocalPos( const math::Vector3&amp; rForce, const math::Vector3&amp; rPos ) = 0;
 
 		/** Adds a force defined in the local reference frame.
 		*/
-		virtual void addLocalForce( const Vector3&amp; rForce ) = 0;
+		virtual void addLocalForce( const math::Vector3&amp; rForce ) = 0;
 
 		/** Adds a force defined in the local reference frame, acting at a position defined
 			in the local reference frame (relative to the actor the body object belongs to).
 		*/
-		virtual void addLocalForceAtLocalPos( const Vector3&amp; rForce, const Vector3&amp; rPos ) = 0;
+		virtual void addLocalForceAtLocalPos( const math::Vector3&amp; rForce, const math::Vector3&amp; rPos ) = 0;
 
 		/** Adds a force defined in the local reference frame, acting at a position defined
 			in the global reference frame.
 		*/
-		virtual void addLocalForceAtPos( const Vector3&amp; rForce, const Vector3&amp; rPos ) = 0;
+		virtual void addLocalForceAtPos( const math::Vector3&amp; rForce, const math::Vector3&amp; rPos ) = 0;
 
 		/** Adds a torque defined in the global reference frame.
 		*/
-		virtual void addTorque( const Vector3&amp; rTorque ) = 0;
+		virtual void addTorque( const math::Vector3&amp; rTorque ) = 0;
 
 		/** Adds a torque defined in the local reference frame.
 		*/
-		virtual void addLocalTorque( const Vector3&amp; rTorque ) = 0;
+		virtual void addLocalTorque( const math::Vector3&amp; rTorque ) = 0;
 	};
 	YAKE_PHYSICS_COMMON_POINTERS( IBody );
 
 }
 }
+
 #endif
+

Modified: trunk/yake/yake/physics/yakePhysicsBodyGroup.h
===================================================================
--- trunk/yake/yake/physics/yakePhysicsBodyGroup.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/physics/yakePhysicsBodyGroup.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -63,3 +63,4 @@
 }
 }
 #endif
+

Modified: trunk/yake/yake/physics/yakePhysicsJoint.h
===================================================================
--- trunk/yake/yake/physics/yakePhysicsJoint.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/physics/yakePhysicsJoint.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -108,7 +108,7 @@
 		struct DescFixed : DescBase
 		{
 			DescFixed(	IActor* pFirst,
-						IActor* pSecond ) :
+				IActor* pSecond ) :
 				DescBase( JT_FIXED,pFirst,pSecond )
 			{}
 		};
@@ -117,70 +117,70 @@
 		{
 			DescHinge(	IActor* pFirst,
 						IActor* pSecond,
-						const Vector3&amp; rAxis,
-						const Vector3&amp; rAnchor ) :
+						const math::Vector3&amp; rAxis,
+						const math::Vector3&amp; rAnchor ) :
 				DescBase( JT_HINGE,pFirst,pSecond ),
 				axis( rAxis ),
 				anchor( rAnchor )
 			{}
-			Vector3		axis;
-			Vector3		anchor;
+			math::Vector3		axis;
+			math::Vector3		anchor;
 		};
 
 		struct DescHinge2 : DescBase
 		{
 			DescHinge2(	IActor* pFirst,
 						IActor* pSecond,
-						const Vector3&amp; rAxis0, 
-						const Vector3&amp; rAxis1,
-						const Vector3&amp; rAnchor ) :
+						const math::Vector3&amp; rAxis0, 
+						const math::Vector3&amp; rAxis1,
+						const math::Vector3&amp; rAnchor ) :
 				DescBase( JT_HINGE2,pFirst,pSecond ),
 				axis0( rAxis0 ),
 				axis1( rAxis1 ),
 				anchor( rAnchor )
 			{}
-			Vector3		axis0;
-			Vector3		axis1;
-			Vector3		anchor;
+			math::Vector3		axis0;
+			math::Vector3		axis1;
+			math::Vector3		anchor;
 		};
 
 		struct DescBall : DescBase
 		{
 			DescBall(	IActor* pFirst,
-						IActor* pSecond,
-						const Vector3&amp; rAnchor ) :
-				DescBase( JT_BALL, pFirst, pSecond ),
-				anchor( rAnchor )
+				IActor* pSecond,
+				const math::Vector3&amp; rAnchor ) :
+			    DescBase( JT_BALL, pFirst, pSecond ),
+			    anchor( rAnchor )
 			{}
-			Vector3		anchor;
+			math::Vector3		anchor;
 		};
 	
 		struct DescSlider : DescBase
 		{
 			DescSlider(	IActor* pFirst,
 						IActor* pSecond,
-						const Vector3&amp; rAxis ) :
+						const math::Vector3&amp; rAxis ) :
 				DescBase( JT_SLIDER, pFirst, pSecond ),
 				axis( rAxis )
 			{}
-			Vector3		axis;
+			math::Vector3		axis;
 		};
 	
 		struct DescUniversal : DescBase
 		{
 			DescUniversal(	IActor* pFirst,
 							IActor* pSecond,
-							const Vector3&amp; rAxis0, 
-							const Vector3&amp; rAxis1,
-							const Vector3&amp; rAnchor ) :
+							const math::Vector3&amp; rAxis0, 
+							const math::Vector3&amp; rAxis1,
+							const math::Vector3&amp; rAnchor ) :
 				DescBase( JT_UNIVERSAL, pFirst, pSecond ),
 				axis0( rAxis0 ),
 				axis1( rAxis1 ),
 				anchor( rAnchor )
  			{}
- 			Vector3		axis0;
- 			Vector3		axis1;
-			Vector3		anchor;
+ 			math::Vector3		axis0;
+ 			math::Vector3		axis1;
+			math::Vector3		anchor;
  		};
 	public:
 		virtual ~IJoint() {}
@@ -190,9 +190,9 @@
 
 		virtual JointType getType() const = 0;
 		virtual size_t getNumAxis() const = 0;
-		virtual void setAxis(size_t axisIndex, const Vector3&amp; rAxis) = 0;
+		virtual void setAxis(size_t axisIndex, const math::Vector3&amp; rAxis) = 0;
 		virtual size_t getNumAnchors() const = 0;
-		virtual void setAnchor(size_t anchorIndex, const Vector3&amp; rAnchor) = 0;
+		virtual void setAnchor(size_t anchorIndex, const math::Vector3&amp; rAnchor) = 0;
 		virtual void setMotor(size_t axisIndex, real velocityTarget, real maximumForce) = 0;
 		virtual void setMotorEnabled(size_t axisIndex, bool enabled) = 0;
 		virtual void setLimits(size_t axisIndex, real low, real high) = 0;
@@ -214,3 +214,4 @@
 }
 }
 #endif
+

Modified: trunk/yake/yake/physics/yakePhysicsMaterial.h
===================================================================
--- trunk/yake/yake/physics/yakePhysicsMaterial.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/physics/yakePhysicsMaterial.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -77,3 +77,4 @@
 }
 }
 #endif
+

Modified: trunk/yake/yake/physics/yakePhysicsMotors.h
===================================================================
--- trunk/yake/yake/physics/yakePhysicsMotors.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/physics/yakePhysicsMotors.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -67,8 +67,8 @@
 		virtual void setAffectedBody( IBody&amp; rBody ) = 0;
 		virtual void setVelocityTarget( const real velTarget ) = 0;
 		virtual void setMaximumForce( const real maxForce ) = 0;
-		virtual void setAxis0( const Vector3&amp; rAxis ) = 0;
-		virtual void setAxis1( const Vector3&amp; rAxis ) = 0;
+		virtual void setAxis0( const math::Vector3&amp; rAxis ) = 0;
+		virtual void setAxis1( const math::Vector3&amp; rAxis ) = 0;
 		virtual void set( const real velTarget, const real maxForce, bool enabled = true ) = 0;
 	};
 	YAKE_PHYSICS_COMMON_POINTERS( IAngularMotor );
@@ -81,7 +81,7 @@
 		virtual void setAffectedBody( IBody&amp; rBody ) = 0;
 		virtual void setVelocityTarget( const real velTarget ) = 0;
 		virtual void setMaximumForce( const real maxForce ) = 0;
-		virtual void setAxis( const Vector3&amp; rAxis ) = 0;
+		virtual void setAxis( const math::Vector3&amp; rAxis ) = 0;
 		virtual void set( const real velTarget, const real maxForce, bool enabled = true ) = 0;
 	};
 	YAKE_PHYSICS_COMMON_POINTERS( ILinearMotor );

Modified: trunk/yake/yake/physics/yakePhysicsPrerequisites.h
===================================================================
--- trunk/yake/yake/physics/yakePhysicsPrerequisites.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/physics/yakePhysicsPrerequisites.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -79,12 +79,12 @@
 
 	struct TriangleMeshDesc
 	{
-		/** Important Notice: Vector3Vector, VertexVector, NormalVector and IndexVector HAVE to
+		/** Important Notice: math::Vector3Vector, VertexVector, NormalVector and IndexVector HAVE to
 			be vectors because they may be accessed like C arrays ( e.g. &amp;arr[0] ).
 			Is this OK? Today, it's practically OK and tomorrow it'll be even more as it's part
 			of the first Technical Corrigendum.
 		*/
-		typedef std::vector&lt;Vector3&gt; Vector3Vector;
+		typedef std::vector&lt;math::Vector3&gt; Vector3Vector;
 		typedef Vector3Vector VertexVector;
 		typedef Vector3Vector NormalVector;
 		typedef uint32 IndexType;
@@ -109,7 +109,7 @@
 		}
 		
 		VertexVector	vertices;
-		IndexVector		indices;
+		IndexVector	indices;
 		NormalVector	normals;
 	};
 }

Modified: trunk/yake/yake/physics/yakePhysicsShape.h
===================================================================
--- trunk/yake/yake/physics/yakePhysicsShape.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/physics/yakePhysicsShape.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -35,110 +35,113 @@
 namespace physics {
 
 	/**
-		YAKE         ODE               NX
-		Plane        Plane             Plane
-		Box          Box               Box
-		Sphere       Sphere            Sphere
-		Capsule      Capped Cylinder   Capsule
-		Cylinder     ?                 ?           (could be approximated with a shorter capsule...)
-		Tri Mesh     TriMesh           Mesh
-		Voxel Set    ?                 ?
-		Transform    ?                 ?           (could be simulated)
-	*/
+	  YAKE         ODE               NX
+	  Plane        Plane             Plane
+	  Box          Box               Box
+	  Sphere       Sphere            Sphere
+	  Capsule      Capped Cylinder   Capsule
+	  Cylinder     ?                 ?           (could be approximated with a shorter capsule...)
+	  Tri Mesh     TriMesh           Mesh
+	  Voxel Set    ?                 ?
+	  Transform    ?                 ?           (could be simulated)
+	  */
 	enum ShapeType
 	{
-		ST_PLANE,
-		ST_BOX,
-		ST_SPHERE,
-		ST_CAPSULE,
-		ST_CYLINDER,
-		ST_TRIANGLE_MESH,
-		ST_VOXEL_SET,
-		ST_OTHER
+	    ST_PLANE,
+	    ST_BOX,
+	    ST_SPHERE,
+	    ST_CAPSULE,
+	    ST_CYLINDER,
+	    ST_TRIANGLE_MESH,
+	    ST_VOXEL_SET,
+	    ST_OTHER
 	};
 
 	class IMaterial;
-	/** A shape is what we formerly called &quot;collision geom&quot; in yake::physics. */
 	class YAKE_PHYSICS_API IShape : public Movable
 	{
-	public:
+	    public:
 		struct Desc
 		{
-			Desc(	const ShapeType type_,
-					const Vector3&amp; rPosition = Vector3::kZero, 
-					const Quaternion&amp; rOrientation = Quaternion::kIdentity,
-					const String&amp; material_ = &quot;&quot; ) :
-				type( type_ ),
-				position( rPosition ),
-				orientation( rOrientation ),
-				material( material_ )
-			{}
+		    Desc(   const ShapeType type_,
+			    const math::Vector3&amp; rPosition = math::Vector3::kZero, 
+			    const math::Quaternion&amp; rOrientation = math::Quaternion::kIdentity,
+			    const String&amp; material_ = &quot;&quot; ) :
+			type( type_ ),
+			position( rPosition ),
+			orientation( rOrientation ),
+			material( material_ )
+		    {}
 
-			virtual ~Desc() {}
-			//virtual Desc* clone() const = 0;
+		    virtual ~Desc() {}
+		    //virtual Desc* clone() const = 0;
 
-			ShapeType	type; // superfluous as shape type is determined by dynamic_cast on Desc struct...
-			Vector3		position;
-			Quaternion	orientation;
-			String		material;
+		    ShapeType	type; // superfluous as shape type is determined by dynamic_cast on Desc struct...
+		    math::Vector3		position;
+		    math::Quaternion	orientation;
+		    String		material;
 		};
+
 		struct SphereDesc : Desc
 		{
-			SphereDesc(	real radius_ = real(1.),
-						// base class:
-						const String&amp; material_ = &quot;&quot;,
-						const Vector3&amp; rPosition = Vector3::kZero, 
-						const Quaternion&amp; rOrientation = Quaternion::kIdentity
-						 ) :
-				Desc( ST_SPHERE, rPosition, rOrientation, material_ ),
-				radius( radius_ )
-			{}
-			real		radius;
+		    SphereDesc(	real radius_ = real(1.),
+			    // base class:
+			    const String&amp; material_ = &quot;&quot;,
+			    const math::Vector3&amp; rPosition = math::Vector3::kZero, 
+			    const math::Quaternion&amp; rOrientation = math::Quaternion::kIdentity
+			    ) :
+			Desc( ST_SPHERE, rPosition, rOrientation, material_ ),
+			radius( radius_ )
+		    {}
+		    real		radius;
 		};
+
 		struct BoxDesc : Desc
 		{
-			BoxDesc(	const Vector3&amp; rDimensions = Vector3(1,1,1),
-						// base class:
-						const String&amp; material_ = &quot;&quot;,
-						const Vector3&amp; rPosition = Vector3::kZero, 
-						const Quaternion&amp; rOrientation = Quaternion::kIdentity
-						 ) :
-				Desc( ST_BOX, rPosition, rOrientation, material_ ),
-				dimensions( rDimensions )
-			{}
-			Vector3		dimensions;
+		    BoxDesc(	const math::Vector3&amp; rDimensions = math::Vector3(1,1,1),
+			    // base class:
+			    const String&amp; material_ = &quot;&quot;,
+			    const math::Vector3&amp; rPosition = math::Vector3::kZero, 
+			    const math::Quaternion&amp; rOrientation = math::Quaternion::kIdentity
+			   ) :
+			Desc( ST_BOX, rPosition, rOrientation, material_ ),
+			dimensions( rDimensions )
+		    {}
+		    math::Vector3		dimensions;
 		};
+
 		struct PlaneDesc : Desc
 		{
-			PlaneDesc(	const Vector3&amp; rNormal = Vector3(0,1,0),
-						const real d_ = real(1.),
-						// base class:
-						const String&amp; material_ = &quot;&quot;,
-						const Vector3&amp; rPosition = Vector3::kZero, 
-						const Quaternion&amp; rOrientation = Quaternion::kIdentity
-						 ) :
-				Desc( ST_PLANE, rPosition, rOrientation, material_ ),
-				normal( rNormal ),
-				d( d_ )
-			{}
-			Vector3		normal;
-			real		d;
+		    PlaneDesc(	const math::Vector3&amp; rNormal = math::Vector3(0,1,0),
+			    const real d_ = real(1.),
+			    // base class:
+			    const String&amp; material_ = &quot;&quot;,
+			    const math::Vector3&amp; rPosition = math::Vector3::kZero, 
+			    const math::Quaternion&amp; rOrientation = math::Quaternion::kIdentity
+			    ) :
+			Desc( ST_PLANE, rPosition, rOrientation, material_ ),
+			normal( rNormal ),
+			d( d_ )
+		    {}
+		    math::Vector3		normal;
+		    real		d;
 		};
+
 		struct CapsuleDesc : Desc
 		{
-			CapsuleDesc(const real height_ = real(2.),
-						const real radius_ = real(1.),
-						// base class:
-						const String&amp; material_ = &quot;&quot;,
-						const Vector3&amp; rPosition = Vector3::kZero, 
-						const Quaternion&amp; rOrientation = Quaternion::kIdentity
-						 ) :
-				Desc( ST_CAPSULE, rPosition, rOrientation, material_ ),
-				height( height_ ),
-				radius( radius_ )
-			{}
-			real		height;
-			real		radius;
+		    CapsuleDesc(const real height_ = real(2.),
+			    const real radius_ = real(1.),
+			    // base class:
+			    const String&amp; material_ = &quot;&quot;,
+			    const math::Vector3&amp; rPosition = math::Vector3::kZero, 
+			    const math::Quaternion&amp; rOrientation = math::Quaternion::kIdentity
+			    ) :
+			Desc( ST_CAPSULE, rPosition, rOrientation, material_ ),
+			height( height_ ),
+			radius( radius_ )
+		    {}
+		    real		height;
+		    real		radius;
 		};
 
 		struct TriMeshDesc : Desc
@@ -146,8 +149,8 @@
 		    TriMeshDesc(	const TriangleMeshDesc trimesh,
 			    // base class:
 			    const String&amp; material_ = &quot;&quot;,
-			    const Vector3&amp; rPosition = Vector3::kZero, 
-			    const Quaternion&amp; rOrientation = Quaternion::kIdentity
+			    const math::Vector3&amp; rPosition = math::Vector3::kZero, 
+			    const math::Quaternion&amp; rOrientation = math::Quaternion::kIdentity
 			    ) :
 				Desc( ST_TRIANGLE_MESH, rPosition, rOrientation, material_ ),
 				trimesh_( trimesh ),
@@ -156,8 +159,8 @@
 		    TriMeshDesc(	const TriangleMeshId trimeshId,
 			    // base class:
 			    const String&amp; material_ = &quot;&quot;,
-			    const Vector3&amp; rPosition = Vector3::kZero, 
-			    const Quaternion&amp; rOrientation = Quaternion::kIdentity
+			    const math::Vector3&amp; rPosition = math::Vector3::kZero, 
+			    const math::Quaternion&amp; rOrientation = math::Quaternion::kIdentity
 			    ) :
 				Desc( ST_TRIANGLE_MESH, rPosition, rOrientation, material_ ),
 				trimeshId_( trimeshId )
@@ -165,16 +168,18 @@
 		    TriangleMeshDesc	trimesh_;
 			TriangleMeshId		trimeshId_;
 		};
-	public:
+
+	    public:
 		virtual ~IShape() {}
 
 		virtual ShapeType getType() const = 0;
 		virtual void setMaterial( IMaterial* pMaterial ) = 0;
+		virtual IMaterial* getMaterial() const = 0;
 
-		//virtual Vector3 getDerivedPosition() const = 0;
-		//virtual Quaternion getDerivedOrientation() const = 0;
+		//virtual math::Vector3 getDerivedPosition() const = 0;
+		//virtual math::Quaternion getDerivedOrientation() const = 0;
 
-		virtual Vector3 getPropertyVector3(const String&amp;) const = 0;
+		virtual math::Vector3 getPropertyVector3(const String&amp;) const = 0;
 		virtual real getPropertyReal(const String&amp;) const = 0;
 	};
 	YAKE_PHYSICS_COMMON_POINTERS( IShape );

Modified: trunk/yake/yake/physics/yakePhysicsWorld.h
===================================================================
--- trunk/yake/yake/physics/yakePhysicsWorld.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/physics/yakePhysicsWorld.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -79,10 +79,11 @@
 		virtual const StringVector getCurrentSolverParams() const = 0;
 		virtual void setCurrentSolverParam( const String&amp; rName, const boost::any&amp; rValue ) = 0;
 
-		virtual void setGlobalGravity( const Vector3&amp; g ) = 0;
-		virtual Vector3 getGlobalGravity() const = 0;
+		virtual void setGlobalGravity( const math::Vector3&amp; g ) = 0;
+		virtual math::Vector3 getGlobalGravity() const = 0;
 
 		virtual void step(const real timeElapsed) = 0;
+		virtual real getStepSize() const = 0;
 
 		YAKE_MEMBERSIGNAL_PUREINTERFACE( public, void(void), PreStep )
 		YAKE_MEMBERSIGNAL_PUREINTERFACE( public, void(real), PostStep )
@@ -92,3 +93,4 @@
 }
 }
 #endif
+

Modified: trunk/yake/yake/plugins/graphicsOgre/graphicsOgreCamera.h
===================================================================
--- trunk/yake/yake/plugins/graphicsOgre/graphicsOgreCamera.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/graphicsOgre/graphicsOgreCamera.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -41,43 +41,45 @@
 		virtual ~OgreCamera();
 
 		// Movable
-		virtual void setPosition( const Vector3 &amp; position );
-		virtual Vector3 getPosition() const;
-		virtual void setOrientation( const Quaternion &amp; orientation );
-		virtual Quaternion getOrientation() const;
-		
+		virtual void setPosition( const math::Vector3&amp; position );
+		virtual void setOrientation( const math::Quaternion&amp; orientation );
+		virtual math::Vector3 getPosition() const;
+		virtual math::Quaternion getOrientation() const;
+		virtual math::Vector3 getDerivedPosition() const;
+		virtual math::Quaternion getDerivedOrientation() const;
+
 		void setDetailLevel(SceneDetailLevel sd);
 
-        /** Retrieves the level of detail that the camera will render.
+		/** Retrieves the level of detail that the camera will render.
 		 */
 		SceneDetailLevel getDetailLevel(void) const;
 
-        /** Sets the camera's direction vector.
+		/** Sets the camera's direction vector.
 		@remarks
 		Note that the 'up' vector for the camera will automatically be recalculated based on the
 		current 'up' vector (i.e. the roll will remain the same).
 				 */
-		virtual void setDirection( const Vector3&amp; rVec );
+		virtual void setDirection( const math::Vector3&amp; rVec );
 
-        /** Gets the camera's direction.
+		/** Gets the camera's direction.
 		 */
-		virtual Vector3 getDirection() const;
+		virtual math::Vector3 getDirection() const;
 
         /** Gets the camera's up vector.
 		 */
-		virtual Vector3 getUp() const;
+		virtual math::Vector3 getUp() const;
 
         /** Gets the camera's right vector.
 		 */
-		virtual Vector3 getRight() const;
+		virtual math::Vector3 getRight() const;
 		
 		virtual void setFixedYawEnabled( bool enabled );
-		virtual void setFixedYawAxis( const Vector3&amp; yawAxis );
+		virtual void setFixedYawAxis( const math::Vector3&amp; yawAxis );
 	
 		/** Moves movable's position by the vector offset provided along it's own axes (relative to orientation).
 		 */
-		virtual void moveRelative( const Vector3&amp; rVec );
-		virtual void lookAt( const Vector3&amp; target );
+		virtual void moveRelative( const math::Vector3&amp; rVec );
+		virtual void lookAt( const math::Vector3&amp; target );
 		virtual void yaw( const real degrees );
 		virtual void roll( const  real degrees );
 
@@ -85,8 +87,8 @@
 		// ICamera
 		virtual void setProjectionType( const ProjectionType type );
 		virtual ProjectionType getProjectionType() const;
-		virtual Matrix4 getProjectionMatrix() const;
-		virtual Matrix4 getViewMatrix() const;
+		virtual math::Matrix4 getProjectionMatrix() const;
+		virtual math::Matrix4 getViewMatrix() const;
 		virtual void setNearClipDistance( real clipDistance );
 		virtual real getNearClipDistance() const;
 		virtual void setFarClipDistance( real clipDistance );
@@ -102,9 +104,9 @@
 		Ogre::SceneManager*	mSceneMgr;
 		Ogre::Camera*		mCam;
 	};
-
 }
 }
 }
 
 #endif
+

Modified: trunk/yake/yake/plugins/graphicsOgre/graphicsOgreCore.h
===================================================================
--- trunk/yake/yake/plugins/graphicsOgre/graphicsOgreCore.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/graphicsOgre/graphicsOgreCore.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -97,3 +97,4 @@
 }
 
 #endif
+

Modified: trunk/yake/yake/plugins/graphicsOgre/graphicsOgreEntity.h
===================================================================
--- trunk/yake/yake/plugins/graphicsOgre/graphicsOgreEntity.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/graphicsOgre/graphicsOgreEntity.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -1,7 +1,7 @@
 /*
    ------------------------------------------------------------------------------------
    This file is part of YAKE
-   Copyright &#169; 2004 The YAKE Team
+   Copyright  2004 The YAKE Team
    For the latest information visit <A HREF="http://www.yake.org">http://www.yake.org</A> 
    ------------------------------------------------------------------------------------
    This program is free software; you can redistribute it and/or modify it under
@@ -47,6 +47,8 @@
 		virtual void setMaterial( const String&amp; materialName );
 		virtual void setSubEntityMaterial( const String&amp; subEntity, const String&amp; materialName );
 		virtual void setCastsShadow( bool castsShadow );
+		
+		virtual void setRenderDetail( SceneDetailLevel sdl );
 
 		Ogre::Entity* getEntity_() const
 		{ return mEntity; }
@@ -60,3 +62,4 @@
 }
 
 #endif
+

Modified: trunk/yake/yake/plugins/graphicsOgre/graphicsOgreGeometryAccess.h
===================================================================
--- trunk/yake/yake/plugins/graphicsOgre/graphicsOgreGeometryAccess.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/graphicsOgre/graphicsOgreGeometryAccess.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -29,7 +29,6 @@
 
 using namespace yake::base::mpl;
 using namespace yake::base::templates;
-using namespace yake::math;
 
 namespace yake {
 namespace graphics {
@@ -86,19 +85,19 @@
 
 		virtual bool lockPositions( uint32 start, uint32 count, bool bRead = false );
 		virtual bool unlockPositions();
-		virtual bool setPosition( uint32 index, const Vector3 &amp; position );
+		virtual bool setPosition( uint32 index, const math::Vector3 &amp; position );
 
 		virtual bool lockNormals( uint32 start, uint32 count, bool bRead = false );
 		virtual bool unlockNormals();
-		virtual bool setNormal( uint32 index, const Vector3 &amp; normal );
+		virtual bool setNormal( uint32 index, const math::Vector3 &amp; normal );
 
 		virtual bool lockTexCoords( uint16 set, uint32 start, uint32 count, bool bRead = false );
 		virtual bool unlockTexCoords( uint16 set );
-		virtual bool setTexCoord( uint16 set, uint16 index, const Vector3 &amp; uv );
+		virtual bool setTexCoord( uint16 set, uint16 index, const math::Vector3 &amp; uv );
 
 		virtual bool lockColours( uint32 start, uint32 count, bool bRead = false );
 		virtual bool unlockColours();
-		virtual bool setColour( uint32 index, const Color &amp; colour );
+		virtual bool setColour( uint32 index, const math::Color&amp; colour );
 
 		virtual bool lockIndices( uint32 start, uint32 count );
 		virtual bool setIndex( uint32 index, uint32 value );
@@ -111,3 +110,4 @@
 } // yake
 
 #endif
+

Modified: trunk/yake/yake/plugins/graphicsOgre/graphicsOgreLight.h
===================================================================
--- trunk/yake/yake/plugins/graphicsOgre/graphicsOgreLight.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/graphicsOgre/graphicsOgreLight.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -52,18 +52,18 @@
 		virtual real getSpotlightOuterAngle() const;
 		virtual real getSpotlightFalloff() const;
 
-		virtual void setDiffuseColour( const Color&amp; colour );
-		virtual void setSpecularColour( const Color&amp; colour );
+		virtual void setDiffuseColour( const math::Color&amp; colour );
+		virtual void setSpecularColour( const math::Color&amp; colour );
 
 		virtual void setEnabled( bool enabled );
 		virtual void setCastsShadows( bool enabled );
 
-		virtual void setPosition( const Vector3 &amp; position );
-		virtual Vector3 getPosition() const;
-		virtual void setOrientation( const Quaternion &amp; orientation );
-		virtual Quaternion getOrientation() const;
-		virtual void setDirection( const Vector3&amp; direction );
-		virtual Vector3 getDirection() const;
+		virtual void setPosition( const math::Vector3 &amp; position );
+		virtual math::Vector3 getPosition() const;
+		virtual void setOrientation( const math::Quaternion &amp; orientation );
+		virtual math::Quaternion getOrientation() const;
+		virtual void setDirection( const math::Vector3&amp; direction );
+		virtual math::Vector3 getDirection() const;
 
 		virtual const String&amp; getName() { return mLight-&gt;getName(); }
 
@@ -79,3 +79,4 @@
 }
 
 #endif
+

Modified: trunk/yake/yake/plugins/graphicsOgre/graphicsOgreNode.h
===================================================================
--- trunk/yake/yake/plugins/graphicsOgre/graphicsOgreNode.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/graphicsOgre/graphicsOgreNode.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -41,22 +41,24 @@
 		OgreNode( Ogre::SceneNode * node, GraphicalWorld&amp; owningWorld, Ogre::SceneManager * sceneMgr );
 		virtual ~OgreNode();
 
-		virtual void setPosition( const Vector3 &amp; position );
-		virtual Vector3 getPosition() const;
-		virtual Vector3 getPosition( TransformSpace ts ) const;
-		virtual void setOrientation( const Quaternion &amp; orientation );
-		virtual Quaternion getOrientation() const;
+		virtual void setPosition( const math::Vector3 &amp; position );
+		virtual math::Vector3 getPosition() const;
+		virtual math::Vector3 getPosition( TransformSpace ts ) const;
+		virtual void setOrientation( const math::Quaternion &amp; orientation );
+		virtual math::Quaternion getOrientation() const;
 
-		virtual void setScale( const Vector3 &amp; scale );
-		virtual Vector3 getScale() const;
+		virtual void setScale( const math::Vector3 &amp; scale );
+		virtual math::Vector3 getScale() const;
 
-		virtual Vector3 getDerivedPosition() const;
-		virtual void getDerivedPosition( Vector3&amp; retPos ) const;
-		virtual Quaternion getDerivedOrientation() const;
-		virtual void getDerivedOrientation( Quaternion&amp; retRot ) const;
-		virtual void translate( const Vector3&amp; rDelta, const TransformSpace relativeTo = TS_PARENT );
-		virtual void rotate( const Quaternion&amp; rDelta, const TransformSpace relativeTo = TS_PARENT );
+		virtual void setInheritScale( bool inherit );
 
+		virtual math::Vector3 getDerivedPosition() const;
+		virtual void getDerivedPosition( math::Vector3&amp; retPos ) const;
+		virtual math::Quaternion getDerivedOrientation() const;
+		virtual void getDerivedOrientation( math::Quaternion&amp; retRot ) const;
+		virtual void translate( const math::Vector3&amp; rDelta, const TransformSpace relativeTo = TS_PARENT );
+		virtual void rotate( const math::Quaternion&amp; rDelta, const TransformSpace relativeTo = TS_PARENT );
+
 		virtual void addChildNode( ISceneNode* pNode );
 		virtual ISceneNode* createChildNode( const String&amp; name = &quot;&quot; );
 		virtual void attachEntity( IEntity* pEntity );
@@ -84,15 +86,15 @@
 		OgreNode* _getParent() const;
 	protected:
 		typedef SceneNodePtrList NodeList;
-		NodeList					mChildren;
-		EntityPtrList			mEntities;
-		LightPtrList			mLights;
-		CameraPtrList			mCameras;
+		NodeList		mChildren;
+		EntityPtrList		mEntities;
+		LightPtrList		mLights;
+		CameraPtrList		mCameras;
 		ParticleSystemPtrList	mParticleSystems;
 
 		Ogre::SceneNode* 		mSceneNode;
 		Ogre::SceneManager*	mSceneMgr;
-		OgreNode*				mParentNode;
+		OgreNode*		mParentNode;
 		GraphicalWorld&amp;		mWorld;
 	};
 
@@ -101,3 +103,4 @@
 }
 
 #endif
+

Modified: trunk/yake/yake/plugins/graphicsOgre/graphicsOgreParticleSystem.h
===================================================================
--- trunk/yake/yake/plugins/graphicsOgre/graphicsOgreParticleSystem.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/graphicsOgre/graphicsOgreParticleSystem.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -33,7 +33,12 @@
 	class OgreParticleSystem : public graphics::IParticleSystem
 	{
 	public:
+// for Ogre 1.1.0 &quot;Dagon&quot; compatibility
+#if OGRE_VERSION_MINOR &gt;= 1 
+		OgreParticleSystem( Ogre::SceneManager&amp; rSMgr, const String&amp; rPSTemplateName);
+#else
 		OgreParticleSystem( Ogre::ParticleSystemManager&amp; rPSMgr, const String&amp; rPSTemplateName);
+#endif
 		virtual ~OgreParticleSystem();
 
 		virtual void setVisible( bool visible );
@@ -51,7 +56,12 @@
 		}
 
 	protected:
+// for Ogre 1.1.0 &quot;Dagon&quot; compatibility
+#if OGRE_VERSION_MINOR &gt;= 1 
+		Ogre::SceneManager&amp;	mSceneMgr;
+#else
 		Ogre::ParticleSystemManager&amp;	mParticleSysMgr;
+#endif
 		Ogre::ParticleSystem*			mParticleSys;
 	};
 
@@ -59,3 +69,4 @@
 } // yake
 
 #endif
+

Modified: trunk/yake/yake/plugins/graphicsOgre/graphicsOgreViewport.h
===================================================================
--- trunk/yake/yake/plugins/graphicsOgre/graphicsOgreViewport.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/graphicsOgre/graphicsOgreViewport.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -45,6 +45,10 @@
 
 		virtual void setDimensions( real left, real top, real width, real height );
 		virtual void setZ( int z );
+
+		virtual void setBackgroundColor( const math::Color&amp; col );
+		virtual math::Color getBackgroundColor() const;
+
 	protected:
 		void killViewport();
 	protected:

Modified: trunk/yake/yake/plugins/graphicsOgre/yakeGraphicsSystem.h
===================================================================
--- trunk/yake/yake/plugins/graphicsOgre/yakeGraphicsSystem.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/graphicsOgre/yakeGraphicsSystem.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -39,6 +39,14 @@
 #	define YAKE_GRAPHICS_CONCRETE_API DLLIMPORT
 #endif
 
+#if YAKE_PLATFORM == PLATFORM_WIN32
+#	define YAKE_USE_OSM
+#	pragma message(&quot;Compiling graphicsOGRE with OSM support.&quot;)
+#else
+#	pragma message(&quot;Compiling graphicsOGRE without OSM support.&quot;)
+#endif
+
+
 #include &lt;yake/plugins/graphicsOgre/yakeGraphicsWorld.h&gt;
 
 //============================================================================
@@ -82,8 +90,10 @@
 		virtual const std::type_info &amp; get_type_info()
 		{ return typeid(GraphicsSystem); }
 
+		OgreCore* _getCore() { return mCore; }
+
 	private: // data
-		OgreCore * mCore;
+		OgreCore* mCore;
 	};
 
 } // ogre3d

Modified: trunk/yake/yake/plugins/graphicsOgre/yakeGraphicsWorld.h
===================================================================
--- trunk/yake/yake/plugins/graphicsOgre/yakeGraphicsWorld.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/graphicsOgre/yakeGraphicsWorld.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -87,7 +87,7 @@
 		virtual real getRenderWindowWidth() const;
 		virtual real getRenderWindowHeight() const;
 
-		virtual IEntity* pickEntity(const Ray&amp; ray);
+		virtual IEntity* pickEntity(const math::Ray&amp; ray);
 
 		static void setCore( OgreCore* core );
 

Modified: trunk/yake/yake/plugins/graphicsOgre/yakePCH.h
===================================================================
--- trunk/yake/yake/plugins/graphicsOgre/yakePCH.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/graphicsOgre/yakePCH.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -24,8 +24,8 @@
    source code distribution.
    ------------------------------------------------------------------------------------
 */
-#ifndef __INC_PCH_H__
-#define __INC_PCH_H__
+#ifndef __INC_OGRE_PCH_H__
+#define __INC_OGRE_PCH_H__
 
 #include &lt;yake/base/yake.h&gt;
 
@@ -72,4 +72,5 @@
 	{ \
 	}
 
-#endif // __INC_PCH_H__
+#endif // __INC_OGRE_PCH_H__
+

Modified: trunk/yake/yake/plugins/inputOgre/InputSystemOgre.h
===================================================================
--- trunk/yake/yake/plugins/inputOgre/InputSystemOgre.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/inputOgre/InputSystemOgre.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -32,7 +32,6 @@
 };
 
 namespace yake {
-	using namespace math;
 namespace input {
 
 	//-----------------------------------------------------------------------
@@ -53,11 +52,11 @@
 		virtual void poll();
 
 	protected:
-		Ogre::InputReader	* mInputReader;
+		Ogre::InputReader*		mInputReader;
 		bool				mButtons[3];
-		Vector3				mPosition;
-		Vector3				mScale;
-		Rectangle			mClip;
+		math::Vector3			mPosition;
+		math::Vector3			mScale;
+		math::Rectangle			mClip;
 	};
 
 	//-----------------------------------------------------------------------
@@ -106,3 +105,4 @@
 }
 }
 #endif
+

Modified: trunk/yake/yake/plugins/physicsODE/OdeActor.h
===================================================================
--- trunk/yake/yake/plugins/physicsODE/OdeActor.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/physicsODE/OdeActor.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -47,10 +47,12 @@
 
 		virtual IWorld* getCreator() const;
 
-		virtual void setPosition( const Vector3&amp; rPosition );
-		virtual void setOrientation( const Quaternion&amp; rOrientation );
-		virtual Vector3 getPosition() const;
-		virtual Quaternion getOrientation() const;
+		virtual void setPosition( const math::Vector3&amp; rPosition );
+		virtual void setOrientation( const math::Quaternion&amp; rOrientation );
+		virtual math::Vector3 getPosition() const;
+		virtual math::Quaternion getOrientation() const;
+		virtual math::Vector3 getDerivedPosition() const { return getPosition(); }
+		virtual math::Quaternion getDerivedOrientation() const { return getOrientation(); }
 		
 		virtual IShape* createShape( const IShape::Desc&amp; rShapeDesc, real massOrDensity = 0.0f, IBody::quantityType type = IBody::QT_MASS );
 		virtual void destroyShape( IShape* pShape );
@@ -59,11 +61,11 @@
 		virtual void setEnabled(const bool enabled);
 		virtual bool isEnabled() const;
 
-		YAKE_MEMBERSIGNAL_VIRTUALIMPL(public, void(ActorCollisionInfo&amp;), CollisionEntered)
-		YAKE_MEMBERSIGNAL_FIRE_FN1(public, CollisionEntered, ActorCollisionInfo&amp; info, info)
+		YAKE_MEMBERSIGNAL_VIRTUALIMPL(public, void(const ActorCollisionInfo&amp;), CollisionEntered)
+		YAKE_MEMBERSIGNAL_FIRE_FN1(public, CollisionEntered, const ActorCollisionInfo&amp; info, info)
 
-		YAKE_MEMBERSIGNAL_VIRTUALIMPL(public, void(ActorCollisionInfo&amp;), CollisionExited)
-		YAKE_MEMBERSIGNAL_FIRE_FN1(public, CollisionExited, ActorCollisionInfo&amp; info, info)
+		YAKE_MEMBERSIGNAL_VIRTUALIMPL(public, void(const ActorCollisionInfo&amp;), CollisionExited)
+		YAKE_MEMBERSIGNAL_FIRE_FN1(public, CollisionExited, const ActorCollisionInfo&amp; info, info)
 	
 		// Ode helpers
 		void _collide( OdeActor* pOther, dGeomID geomA, dGeomID geomB, dJointGroup* pContactJointGroup );
@@ -74,10 +76,10 @@
 		IBody::MassDesc* createMassDescFromShapeDesc( const IShape::Desc&amp; rShapeDesc, real massOrDensity, IBody::quantityType qType );
 		
 		OdeGeom* createShapeFromDesc( const IShape::Desc&amp; rShapeDesc );
-		OdeGeom* createTransformGeomIfNeeded( OdeGeom* pGeom, const Vector3&amp; rOffset, const Quaternion&amp; rRelOrientation );
+		OdeGeom* createTransformGeom( OdeGeom* pGeom, const math::Vector3&amp; rOffset, const math::Quaternion&amp; rRelOrientation );
 
-		Vector3							mPosition;
-		Quaternion						mOrientation;
+		math::Vector3						mPosition;
+		math::Quaternion					mOrientation;
 		
 		OdeBody*						mBody; 
 		OdeWorld*						mOdeWorld;
@@ -87,10 +89,13 @@
 		
 		typedef real CollisionInfo;
 		typedef std::map&lt; OdeActor*, CollisionInfo &gt; CollisionCache;
-		CollisionCache					mCollisions;
+		CollisionCache						mCollisions;
+
+		SigCollisionEnteredType	    mEnterCollisionSignal;
 	};
 
 } // physics
 } // yake
 
 #endif
+

Modified: trunk/yake/yake/plugins/physicsODE/OdeAvatar.h
===================================================================
--- trunk/yake/yake/plugins/physicsODE/OdeAvatar.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/physicsODE/OdeAvatar.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -47,15 +47,17 @@
 
 		bool init(const IAvatar::Desc&amp;);
 
-		virtual void setPosition( const Vector3&amp; rPosition );
-		virtual void setOrientation( const Quaternion&amp; rOrientation );
-		virtual Vector3 getPosition() const;
-		virtual Quaternion getOrientation() const;
+		virtual void setPosition( const math::Vector3&amp; rPosition );
+		virtual void setOrientation( const math::Quaternion&amp; rOrientation );
+		virtual math::Vector3 getPosition() const;
+		virtual math::Vector3 getDerivedPosition() const { return getPosition(); }//FIXME is this enough? 
+		virtual math::Quaternion getOrientation() const;
+		virtual math::Quaternion getDerivedOrientation() const { return getOrientation(); }//FIXME is this enough?
 
-		virtual void setDimensions( const Vector3 &amp; rkDimensions );
+		virtual void setDimensions( const math::Vector3&amp; rkDimensions );
 		virtual void setInfluenceByDynamics( const real ratio );
 
-		virtual void setTargetVelocity( const Vector3 &amp; rkTargetVelocity );
+		virtual void setTargetVelocity( const math::Vector3&amp; rkTargetVelocity );
 		virtual void jump();
 		virtual bool isJumping() const;
 		virtual void duck(const bool yes);
@@ -73,12 +75,12 @@
 		void onPostStepInternal(const real dt);
 		void _updateRayData();
 	private:
-		mutable Vector3					mPosition;
-		mutable Quaternion				mOrientation;
+		mutable math::Vector3					mPosition;
+		mutable math::Quaternion				mOrientation;
 
-		Vector3							mDimensions;
+		math::Vector3						mDimensions;
 		real							mDynamicsInfluence;
-		Vector3							mTargetVelocity;
+		math::Vector3						mTargetVelocity;
 
 		bool							mJumping;
 		bool							mJumpStartInProgress;
@@ -93,7 +95,7 @@
 		double							mRayLength;
 
 		double							mSphereRadius;
-		Vector3							mSphereOffset;
+		math::Vector3						mSphereOffset;
 
 		real							mHeightAboveGround;
 		real							mHeightAboveGroundDuck;
@@ -107,3 +109,4 @@
 } // yake
 
 #endif
+

Modified: trunk/yake/yake/plugins/physicsODE/OdeBody.h
===================================================================
--- trunk/yake/yake/plugins/physicsODE/OdeBody.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/physicsODE/OdeBody.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -49,26 +49,28 @@
 			virtual void setMass( const MassDesc&amp; rDesc );
 			virtual void addMass( const MassDesc&amp; rDesc );
 
-			virtual void setLinearVelocity( Vector3 const&amp; rVelocity );
-			virtual Vector3 getLinearVelocity() const;
-			virtual void setAngularVelocity( Vector3 const&amp; rVelocity);
-			virtual Vector3 getAngularVelocity() const;
+			virtual void setLinearVelocity( math::Vector3 const&amp; rVelocity );
+			virtual math::Vector3 getLinearVelocity() const;
+			virtual void setAngularVelocity( math::Vector3 const&amp; rVelocity);
+			virtual math::Vector3 getAngularVelocity() const;
 			
 			virtual void addForce( const Force&amp; force );
-			virtual void addForce( Vector3 const&amp; rForce );
-			virtual void addForceAtPos( Vector3 const&amp; rForce, Vector3 const&amp; rPos );
-			virtual void addForceAtLocalPos( const Vector3&amp; rForce, const Vector3&amp; rPos );
-			virtual void addLocalForce( Vector3 const&amp; rForce );
-			virtual void addLocalForceAtLocalPos( Vector3 const&amp; rForce, Vector3 const&amp; rPos );
-			virtual void addLocalForceAtPos( Vector3 const&amp; rForce, Vector3 const&amp; rPos );
-			virtual void addTorque( Vector3 const&amp; rTorque );
-			virtual void addLocalTorque( Vector3 const&amp; rTorque );
+			virtual void addForce( math::Vector3 const&amp; rForce );
+			virtual void addForceAtPos( math::Vector3 const&amp; rForce, math::Vector3 const&amp; rPos );
+			virtual void addForceAtLocalPos( const math::Vector3&amp; rForce, const math::Vector3&amp; rPos );
+			virtual void addLocalForce( math::Vector3 const&amp; rForce );
+			virtual void addLocalForceAtLocalPos( math::Vector3 const&amp; rForce, math::Vector3 const&amp; rPos );
+			virtual void addLocalForceAtPos( math::Vector3 const&amp; rForce, math::Vector3 const&amp; rPos );
+			virtual void addTorque( math::Vector3 const&amp; rTorque );
+			virtual void addLocalTorque( math::Vector3 const&amp; rTorque );
 			
 			// helpers for OdeActor
-			virtual void setPosition( const Vector3 &amp; position );
-			virtual Vector3 getPosition() const;
-			virtual void setOrientation( const Quaternion &amp; orientation );
-			virtual Quaternion getOrientation() const;
+			virtual void setPosition( const math::Vector3 &amp; position );
+			virtual void setOrientation( const math::Quaternion &amp; orientation );
+			virtual math::Vector3 getPosition() const;
+			virtual math::Quaternion getOrientation() const;
+			virtual math::Vector3 getDerivedPosition() const { return this-&gt;getPosition(); }
+			virtual math::Quaternion getDerivedOrientation() const { return this-&gt;getOrientation(); }
 
 			
 // 			virtual void setMassBox(real lx, real ly, real lz, real density = 1.);
@@ -77,9 +79,9 @@
 // 			/// void dMassAdd (dMass *a, const dMass *b);
 // 			virtual real getMass() const;
 // //			virtual MassType getType() const;
-// 			virtual void translateMass( const Vector3 &amp; d );
+// 			virtual void translateMass( const math::Vector3 &amp; d );
 // 
-// 			virtual Vector3 getTorque() const;
+// 			virtual math::Vector3 getTorque() const;
 // 
 // 			virtual void setEnabled( bool enabled );
 
@@ -102,3 +104,4 @@
 } // yake
 
 #endif
+

Modified: trunk/yake/yake/plugins/physicsODE/OdeJoint.h
===================================================================
--- trunk/yake/yake/plugins/physicsODE/OdeJoint.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/physicsODE/OdeJoint.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -44,15 +44,18 @@
 		public:
 			virtual ~OdeJoint();
 
-			virtual void attach( IBody&amp; rBody1, IBody&amp; rBody2 );
+			/** Attach joint to bodies. If one of the bodies is 0, then attach
+			 * to static environment.
+			 */
+			virtual void attach( IBody* pBody1, IBody* pBody2 );
 
 			//virtual JointType getType() const;
 			
 			//virtual size_t getNumAxis() const;
-			//virtual void setAxis( size_t axisIndex, Vector3 const&amp; rAxis );
+			//virtual void setAxis( size_t axisIndex, math::Vector3 const&amp; rAxis );
 			
 			//virtual size_t getNumAnchors() const;
-			//virtual void setAnchor( size_t anchorIndex, Vector3 const&amp; rAnchor );
+			//virtual void setAnchor( size_t anchorIndex, math::Vector3 const&amp; rAnchor );
 			
 			//virtual void setMotor( size_t axisIndex, real velocityTarget, real maximumForce );
 			
@@ -95,10 +98,10 @@
 			virtual JointType getType() const;
 			
 			virtual size_t getNumAxis() const;
-			virtual void setAxis( size_t axisIndex, Vector3 const&amp; rAxis );
+			virtual void setAxis( size_t axisIndex, math::Vector3 const&amp; rAxis );
 			
 			virtual size_t getNumAnchors() const;
-			virtual void setAnchor( size_t anchorIndex, Vector3 const&amp; rAnchor );
+			virtual void setAnchor( size_t anchorIndex, math::Vector3 const&amp; rAnchor );
 			
 			virtual void setMotor( size_t axisIndex, real velocityTarget, real maximumForce );
 			virtual void setMotorEnabled( size_t axisIndex, bool enabled );
@@ -117,10 +120,10 @@
 			virtual JointType getType() const;
 			
 			virtual size_t getNumAxis() const;
-			virtual void setAxis( size_t axisIndex, Vector3 const&amp; rAxis );
+			virtual void setAxis( size_t axisIndex, math::Vector3 const&amp; rAxis );
 			
 			virtual size_t getNumAnchors() const;
-			virtual void setAnchor( size_t anchorIndex, Vector3 const&amp; rAnchor );
+			virtual void setAnchor( size_t anchorIndex, math::Vector3 const&amp; rAnchor );
 			
 			virtual void setMotor( size_t axisIndex, real velocityTarget, real maximumForce );
 			virtual void setMotorEnabled( size_t axisIndex, bool enabled );
@@ -140,10 +143,10 @@
 			virtual JointType getType() const;
 			
 			virtual size_t getNumAxis() const;
-			virtual void setAxis( size_t axisIndex, Vector3 const&amp; rAxis );
+			virtual void setAxis( size_t axisIndex, math::Vector3 const&amp; rAxis );
 			
 			virtual size_t getNumAnchors() const;
-			virtual void setAnchor( size_t anchorIndex, Vector3 const&amp; rAnchor );
+			virtual void setAnchor( size_t anchorIndex, math::Vector3 const&amp; rAnchor );
 			
 			virtual void setMotor( size_t axisIndex, real velocityTarget, real maximumForce );
 			virtual void setMotorEnabled( size_t axisIndex, bool enabled );
@@ -156,15 +159,15 @@
 		public:
 			OdeFixedJoint( OdeWorld* pWorld );
 
-			virtual void attach( IBody&amp; rBody1, IBody&amp; rBody2 );
+			virtual void attach( IBody* pBody1, IBody* pBody2 );
 			
 			virtual JointType getType() const;
 			
 			virtual size_t getNumAxis() const;
-			virtual void setAxis( size_t axisIndex, Vector3 const&amp; rAxis );
+			virtual void setAxis( size_t axisIndex, math::Vector3 const&amp; rAxis );
 			
 			virtual size_t getNumAnchors() const;
-			virtual void setAnchor( size_t anchorIndex, Vector3 const&amp; rAnchor );
+			virtual void setAnchor( size_t anchorIndex, math::Vector3 const&amp; rAnchor );
 			
 			virtual void setMotor( size_t axisIndex, real velocityTarget, real maximumForce );
 			virtual void setMotorEnabled( size_t axisIndex, bool enabled );
@@ -180,10 +183,10 @@
 			virtual JointType getType() const;
 			
 			virtual size_t getNumAxis() const;
-			virtual void setAxis( size_t axisIndex, Vector3 const&amp; rAxis );
+			virtual void setAxis( size_t axisIndex, math::Vector3 const&amp; rAxis );
 			
 			virtual size_t getNumAnchors() const;
-			virtual void setAnchor( size_t anchorIndex, Vector3 const&amp; rAnchor );
+			virtual void setAnchor( size_t anchorIndex, math::Vector3 const&amp; rAnchor );
 			
 			virtual void setMotor( size_t axisIndex, real velocityTarget, real maximumForce );
 			virtual void setMotorEnabled( size_t axisIndex, bool enabled );
@@ -203,10 +206,10 @@
 			virtual JointType getType() const;
 			
 			virtual size_t getNumAxis() const;
-			virtual void setAxis( size_t axisIndex, Vector3 const&amp; rAxis );
+			virtual void setAxis( size_t axisIndex, math::Vector3 const&amp; rAxis );
 			
 			virtual size_t getNumAnchors() const;
-			virtual void setAnchor( size_t anchorIndex, Vector3 const&amp; rAnchor );
+			virtual void setAnchor( size_t anchorIndex, math::Vector3 const&amp; rAnchor );
 			
 			virtual void setMotor( size_t axisIndex, real velocityTarget, real maximumForce );
 			virtual void setMotorEnabled( size_t axisIndex, bool enabled );
@@ -221,3 +224,4 @@
 } // yake
 
 #endif
+

Modified: trunk/yake/yake/plugins/physicsODE/OdeMaterial.h
===================================================================
--- trunk/yake/yake/plugins/physicsODE/OdeMaterial.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/physicsODE/OdeMaterial.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -50,8 +50,7 @@
 		real					mRestitution;
 		real					mFriction2;
 		bool					mLateralSlip;
-//		ISlipNormalSource*		mSlipNormalSource;
-		Vector3					mSlipNormal;
+		math::Vector3				mSlipNormal;
 		real					mSlipLinearCoeff;
 		real					mSlipAngularCoeff;
 
@@ -62,3 +61,4 @@
 } // yake
 
 #endif
+

Modified: trunk/yake/yake/plugins/physicsODE/OdeRay.h
===================================================================
--- trunk/yake/yake/plugins/physicsODE/OdeRay.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/physicsODE/OdeRay.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -46,17 +46,19 @@
 		real length() const;
 		bool intersects() const;
 		real intersectionDepth() const;
-		Vector3 intersectionPoint() const;
-		Vector3 intersectionNormal() const;
+		math::Vector3 intersectionPoint() const;
+		math::Vector3 intersectionNormal() const;
 
-		virtual void setPosition( Vector3 const&amp; rPosition);
-		virtual Vector3 getPosition() const;
+		virtual void setPosition( math::Vector3 const&amp; rPosition);
+		virtual math::Vector3 getPosition() const;
+		virtual math::Vector3 getDerivedPosition() const { return getPosition(); }//FIXME is this enough? 
 
-		virtual void setOrientation( Quaternion const&amp; rOrientation );
-		virtual Quaternion getOrientation() const;
+		virtual void setOrientation( math::Quaternion const&amp; rOrientation );
+		virtual math::Quaternion getOrientation() const;
+		virtual math::Quaternion getDerivedOrientation() const { return getOrientation(); }//FIXME is this enough?
 
-		void setDirection(const Vector3&amp;);
-		Vector3 getDirection() const;
+		void setDirection(const math::Vector3&amp;);
+		math::Vector3 getDirection() const;
 
 		void ignore(dGeomID);
 
@@ -74,13 +76,13 @@
 		dRay*		mRay;
 		OdeWorld*	mWorld;
 		real		mLength;
-		mutable Vector3	mPosition;
-		mutable Vector3	mDirection;
+		mutable math::Vector3	mPosition;
+		mutable math::Vector3	mDirection;
 
 		bool		mIntersects;
 		real		mIntersectionDepth;
-		Vector3		mIntersectionPoint;
-		Vector3		mIntersectionNormal;
+		math::Vector3	mIntersectionPoint;
+		math::Vector3	mIntersectionNormal;
 
 		typedef std::deque&lt;dGeomID&gt; GeomIdList;
 		GeomIdList	mIgnoreGeoms;
@@ -90,3 +92,4 @@
 } // yake
 
 #endif
+

Modified: trunk/yake/yake/plugins/physicsODE/OdeShapes.h
===================================================================
--- trunk/yake/yake/plugins/physicsODE/OdeShapes.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/physicsODE/OdeShapes.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -54,15 +54,15 @@
 			OdeActor* getOwner() const
 			{ return mOwner; }
 
-			virtual void setPosition( Vector3 const&amp; rPosition);
-			virtual Vector3 getPosition() const;
-			virtual void setOrientation( Quaternion const&amp; rOrientation );
-			virtual Quaternion getOrientation() const;
+			virtual void setPosition( math::Vector3 const&amp; rPosition);
+			virtual math::Vector3 getPosition() const;
+			virtual void setOrientation( math::Quaternion const&amp; rOrientation );
+			virtual math::Quaternion getOrientation() const;
 
-			virtual Vector3 getDerivedPosition() const;
-			virtual Quaternion getDerivedOrientation() const;
+			virtual math::Vector3 getDerivedPosition() const;
+			virtual math::Quaternion getDerivedOrientation() const;
 
-			virtual Vector3 getPropertyVector3(const String&amp;) const;
+			virtual math::Vector3 getPropertyVector3(const String&amp;) const;
 			virtual real getPropertyReal(const String&amp;) const;
 
 		protected:
@@ -86,16 +86,16 @@
 			
 			virtual ShapeType getType() const;
 			
-			virtual void setPosition( Vector3 const&amp; rPosition);
-			virtual Vector3 getPosition() const;
-			virtual void setOrientation( Quaternion const&amp; rOrientation );
-			virtual Quaternion getOrientation() const;
+			virtual void setPosition( math::Vector3 const&amp; rPosition);
+			virtual math::Vector3 getPosition() const;
+			virtual void setOrientation( math::Quaternion const&amp; rOrientation );
+			virtual math::Quaternion getOrientation() const;
 
 			void attachGeom( OdeGeom* pGeom );
 			OdeGeom* getAttachedGeom() const;
 		
-			virtual Vector3 getDerivedPosition() const;
-			virtual Quaternion getDerivedOrientation() const;
+			virtual math::Vector3 getDerivedPosition() const;
+			virtual math::Quaternion getDerivedOrientation() const;
 		private:
 			OdeGeom*	mAttachedGeom;
 		};
@@ -164,3 +164,4 @@
 } // yake
 
 #endif
+

Modified: trunk/yake/yake/plugins/physicsODE/OdeWorld.h
===================================================================
--- trunk/yake/yake/plugins/physicsODE/OdeWorld.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/plugins/physicsODE/OdeWorld.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -31,9 +31,6 @@
 #include &quot;yake/plugins/physicsODE/OdeShapes.h&quot;
 
 namespace yake {
-
-	using namespace math;
-
 namespace physics {
 
 		class OdeBody;
@@ -52,33 +49,36 @@
 			virtual IJointPtr createJoint( const IJoint::DescBase&amp; rkJointDesc );
 			virtual IActorPtr createActor( const IActor::Desc&amp; rActorDesc = IActor::Desc( ACTOR_MOVABLE ) );
 			virtual IAvatarPtr createAvatar( const IAvatar::Desc&amp; rkAvatarDesc );
+	
 			virtual IMaterialPtr getMaterial( const String&amp; id ) const;
-			virtual IMaterialPtr createMaterial( const IMaterial::Desc &amp; rkMatDesc, const String&amp; id = &quot;&quot; );
+			virtual IMaterialPtr createMaterial( const IMaterial::Desc&amp; rkMatDesc, const String&amp; id = &quot;&quot; );
 			virtual void destroyJoint( IJointPtr pJoint );
 			virtual void destroyActor( IActorPtr pActor );
 			virtual void destroyAvatar( IAvatarPtr pAvatar );
 			virtual void destroyMaterial( IMaterialPtr pMaterial );
 			
-			virtual TriangleMeshId createTriangleMesh( TriangleMeshDesc const&amp; rTrimeshDesc );
+			virtual TriangleMeshId createTriangleMesh( const TriangleMeshDesc&amp; rTrimeshDesc );
 
 			virtual Deque&lt;ShapeType&gt; getSupportedShapes( bool bStatic = true, bool bDynamic = true) const;
 			virtual Deque&lt;JointType&gt; getSupportedJoints() const;
 			virtual Deque&lt;String&gt; getSupportedSolvers() const;
-			virtual bool useSolver( String const&amp; rSolver );
+			virtual bool useSolver( const String&amp; rSolver );
 			virtual String getCurrentSolver() const;
 			virtual const StringVector getCurrentSolverParams() const;
-			virtual void setCurrentSolverParam( String const&amp; rName, boost::any const&amp; rValue );
+			virtual void setCurrentSolverParam( const String&amp; rName, const boost::any&amp; rValue );
 
 			virtual void step( const real timeElapsed );
-			virtual void setGlobalGravity( const Vector3&amp; g );
-			virtual Vector3 getGlobalGravity() const;
+			virtual real getStepSize() const { return _getStepSize(); }
 
-			YAKE_MEMBERSIGNAL_VIRTUALIMPL( public, void, PreStep )
-			YAKE_MEMBERSIGNAL_FIRE_FN0( public, PreStep )
-			YAKE_MEMBERSIGNAL_VIRTUALIMPL( public, void, PostStep )
-			YAKE_MEMBERSIGNAL_FIRE_FN1( public, PostStep, real t, t )
-			YAKE_MEMBERSIGNAL_VIRTUALIMPL( public, void, PreStepInternal )
-			YAKE_MEMBERSIGNAL_FIRE_FN1( public, PreStepInternal, const real dt, dt )
+			virtual void setGlobalGravity( const math::Vector3&amp; g );
+			virtual math::Vector3 getGlobalGravity() const;
+
+			YAKE_MEMBERSIGNAL_VIRTUALIMPL( public, void, PreStep );
+			YAKE_MEMBERSIGNAL_FIRE_FN0( public, PreStep );
+			YAKE_MEMBERSIGNAL_VIRTUALIMPL( public, void, PostStep );
+			YAKE_MEMBERSIGNAL_FIRE_FN1( public, PostStep, real t, t );
+			YAKE_MEMBERSIGNAL_VIRTUALIMPL( public, void, PreStepInternal );
+			YAKE_MEMBERSIGNAL_FIRE_FN1( public, PreStepInternal, const real dt, dt );
 			YAKE_MEMBERSIGNAL( public, void(const real), PostStepInternal )
 		public:
 

Modified: trunk/yake/yake/prop/prerequisites.h
===================================================================
--- trunk/yake/yake/prop/prerequisites.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/prop/prerequisites.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -20,4 +20,5 @@
 
 } // namespace yake
 
-#endif
\ No newline at end of file
+#endif
+

Modified: trunk/yake/yake/prop/prop_def.h
===================================================================
--- trunk/yake/yake/prop/prop_def.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/prop/prop_def.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -60,4 +60,5 @@
 	{ return new Prop(*this,defaultValue_,readOnly_); }
 } // namespace yake
 
-#endif
\ No newline at end of file
+#endif
+

Modified: trunk/yake/yake/prop/prop_holder.h
===================================================================
--- trunk/yake/yake/prop/prop_holder.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/prop/prop_holder.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -1,7 +1,8 @@
 #ifndef YAKE_PROP_HOLDER_H
 #define YAKE_PROP_HOLDER_H
 
-#include &quot;prerequisites.h&quot;
+#include &quot;yake/prop/prerequisites.h&quot;
+#include &quot;yake/prop/rtti_class.h&quot;
 #include &lt;iostream&gt; // std::cout for warnings
 
 namespace yake {
@@ -22,7 +23,7 @@
 		template&lt;typename T_value&gt;
 		bool getValue(const std::string&amp; name, T_value&amp; retValue) const
 		{
-			StringPropPtrMap::const_iterator it = props_.find(name);
+			typename StringPropPtrMap::const_iterator it = props_.find(name);
 			if (it == props_.end())
 				return false;
 			assert( it-&gt;second );
@@ -31,7 +32,7 @@
 		template&lt;typename T_value&gt;
 		bool setValue(const std::string&amp; name, const T_value&amp; value)
 		{
-			StringPropPtrMap::iterator it = props_.find(name);
+			typename StringPropPtrMap::iterator it = props_.find(name);
 			if (it == props_.end())
 				return false;
 			assert( it-&gt;second );
@@ -52,14 +53,14 @@
 	private:
 		void initProps(const RttiClass&amp; cls, StringPropPtrMap&amp; props)
 		{
-			const RttiClass::ParentClassList&amp; parentClsList = cls.getParents();
-			RttiClass::ParentClassList::const_iterator itClsEnd = parentClsList.end();
-			for (RttiClass::ParentClassList::const_iterator itCls = parentClsList.begin(); itCls != itClsEnd; ++itCls)
+			const typename RttiClass::ParentClassList&amp; parentClsList = cls.getParents();
+			typename RttiClass::ParentClassList::const_iterator itClsEnd = parentClsList.end();
+			for ( typename RttiClass::ParentClassList::const_iterator itCls = parentClsList.begin(); itCls != itClsEnd; ++itCls)
 				initProps(**itCls, props);
 
 			const PropDefMap&amp; defs = cls.getPropDefs();
-			PropDefMap::const_iterator itDefEnd = defs.end();
-			for (PropDefMap::const_iterator itDef = defs.begin(); itDef != itDefEnd; ++itDef)
+			typename PropDefMap::const_iterator itDefEnd = defs.end();
+			for ( typename PropDefMap::const_iterator itDef = defs.begin(); itDef != itDefEnd; ++itDef)
 			{
 				const PropDef&amp; def = itDef-&gt;second;
 				if (def.name().empty())
@@ -67,7 +68,7 @@
 					std::cout &lt;&lt; &quot;warning: empty property name in class '&quot; &lt;&lt; cls.name() &lt;&lt; &quot;'. skipping.\n&quot;;
 					continue;
 				}
-				StringPropPtrMap::const_iterator itFind = props.find(def.name());
+				typename StringPropPtrMap::const_iterator itFind = props.find(def.name());
 				if (itFind == props.end())
 				{
 					props[ def.name() ] = def.create();
@@ -99,3 +100,4 @@
 } // namespace yake
 
 #endif
+

Modified: trunk/yake/yake/prop/rtti_class.h
===================================================================
--- trunk/yake/yake/prop/rtti_class.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/prop/rtti_class.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -109,7 +109,11 @@
 				out &lt;&lt; &quot;  File: &quot; &lt;&lt; file &lt;&lt; &quot;@&quot; &lt;&lt; line &lt;&lt; &quot;\n&quot;;
 			msg_ = out.str();
 		}
-		const char* what() const
+		virtual ~RttiException() throw()
+		{
+		    // empty implementation. Required to avoid &quot;looser throw specifier error&quot;.
+		}
+		const char* what() const throw ()
 		{ return msg_.c_str(); }
 	private:
 		std::string		msg_;
@@ -119,8 +123,10 @@
 #define THROW_RTTI_LOC(MSG,LOC) \
 	throw RttiException(MSG,LOC,__FILE__,__LINE__)
 
+#if YAKE_COMPILER == COMPILER_MSVC
 #pragma warning(push)
 #pragma warning(disable: 4290) // C4290: C++ exception specification ignored except to indicate a function is not __declspec(nothrow)
+#endif
 	struct RttiClassMgr
 	{
 		// insert into existing hierarchy
@@ -131,13 +137,19 @@
 		typedef std::map&lt;std::string,RttiClass*&gt; StringClassPtrMap;
 		StringClassPtrMap	classes_;
 	};
+#if YAKE_COMPILER == COMPILER_MSVC
 #pragma warning(pop)
-	inline RttiClass* RttiClassMgr::get(const std::string&amp; clsName) const
+#endif
+	inline RttiClass* RttiClassMgr::get(const std::string&amp; clsName) const throw ()
 	{
 		StringClassPtrMap::const_iterator it = classes_.find(clsName);
 		return (it == classes_.end()) ? 0 : it-&gt;second;
 	}
-	inline void RttiClassMgr::insert(RttiClass* cls)
+#if YAKE_COMPILER == COMPILER_MSVC
+#pragma warning(push)
+#pragma warning(disable: 4290) // C4290: C++ exception specification ignored except to indicate a function is not __declspec(nothrow)
+#endif
+	inline void RttiClassMgr::insert(RttiClass* cls) throw(yake::RttiException)
 	{
 		assert( cls );
 		if (!cls)
@@ -168,6 +180,9 @@
 
 		// post-process
 	}
+#if YAKE_COMPILER == COMPILER_MSVC
+#pragma warning(pop)
+#endif
 	inline void RttiClass::add(const PropDef &amp; propdef)
 	{
 		props_[ propdef.name() ] = propdef;

Modified: trunk/yake/yake/samples/common/yakeExampleApplication.h
===================================================================
--- trunk/yake/yake/samples/common/yakeExampleApplication.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/samples/common/yakeExampleApplication.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -12,7 +12,7 @@
 #include &lt;iostream&gt;
 
 namespace yake {
-	using namespace base::templates;
+	using namespace yake::templates;
 namespace exapp {
 
 // todo: kick the plugin approach or combine it with class registry

Modified: trunk/yake/yake/scripting/yakeScriptingSystem.h
===================================================================
--- trunk/yake/yake/scripting/yakeScriptingSystem.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/scripting/yakeScriptingSystem.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -171,3 +171,4 @@
 
 
 #endif
+

Modified: trunk/yake/yake/statemachine/fsm_core.h
===================================================================
--- trunk/yake/yake/statemachine/fsm_core.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/statemachine/fsm_core.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -185,7 +185,7 @@
 			{
 				out &lt;&lt; &quot;  state '&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;'\n&quot;;
 				const event_state_map&amp; evt2state = it-&gt;second.offgoing_transitions;
-				for (event_state_map::const_iterator itT = evt2state.begin(); itT != evt2state.end(); ++itT)
+				for ( typename event_state_map::const_iterator itT = evt2state.begin(); itT != evt2state.end(); ++itT)
 				{
 					out &lt;&lt; &quot;    event '&quot; &lt;&lt; itT-&gt;first &lt;&lt; &quot;' -&gt; state '&quot; &lt;&lt; itT-&gt;second &lt;&lt; &quot;'\n&quot;;
 				}
@@ -214,14 +214,14 @@
 		template&lt;typename enter_state_op_t, typename exit_state_op_t&gt;
 		void processEventCb(const event_type&amp; evt, enter_state_op_t&amp; enterOp, exit_state_op_t&amp; exitOp)
 		{
-			const state_map::const_iterator it = states_.find( curr_ );
+			const typename state_map::const_iterator it = states_.find( curr_ );
 			if (it == states_.end())
 			{
 				std::cerr &lt;&lt; &quot;error: machine&lt;&gt;::processEventCb():\n   invalid current state.\n\n&quot;;
 				return;
 			}
 			const event_state_map&amp; evt2state = it-&gt;second.offgoing_transitions;
-			const event_state_map::const_iterator itFindTransition = evt2state.find(evt);
+			const typename event_state_map::const_iterator itFindTransition = evt2state.find(evt);
 			if (itFindTransition == evt2state.end())
 			{
 				std::cerr &lt;&lt; &quot;error: machine&lt;&gt;::processEventCb():\n   transition not found! (evt=&quot; &lt;&lt; evt &lt;&lt; &quot;, src=&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;)\n\n&quot;;
@@ -247,7 +247,7 @@
 	template&lt;typename _state_type, typename _event_type&gt;
 	void machine&lt;_state_type,_event_type&gt;::setState(const state_type&amp; dest)
 	{
-		const state_map::const_iterator it = states_.find( dest );
+		const typename state_map::const_iterator it = states_.find( dest );
 		if (it == states_.end())
 		{
 			std::cerr &lt;&lt; &quot;error: machine&lt;&gt;::setState():\n   unregistered state.\n\n&quot;;
@@ -293,10 +293,10 @@
 	template&lt;typename _state_type, typename _event_type&gt;
 	void machine&lt;_state_type,_event_type&gt;::addState(const state_type&amp; state)
 	{
-		state_map::iterator it = states_.find( state );
+		typename state_map::iterator it = states_.find( state );
 		if (it == states_.end())
 		{
-			states_.insert( state_map::value_type(state,state_e()) );
+			states_.insert( typename state_map::value_type(state,state_e()) );
 			return;
 		}
 #ifdef _DEBUG
@@ -311,14 +311,14 @@
 			std::cerr &lt;&lt; &quot;error: machine&lt;&gt;::addTransition():\n   source and destination are identical!\n\n&quot;;
 			return;
 		}
-		state_map::iterator it = states_.find( src );
+		typename state_map::iterator it = states_.find( src );
 		if (it == states_.end())
 		{
 			std::cerr &lt;&lt; &quot;error: machine&lt;&gt;::addTransition():\n   unregistered source state!\n\n&quot;;
 			return;
 		}
 		{
-			const state_map::const_iterator itDest = states_.find( dest );
+			const typename state_map::const_iterator itDest = states_.find( dest );
 			if (itDest == states_.end())
 			{
 				std::cerr &lt;&lt; &quot;error: machine&lt;&gt;::addTransition():\n   unregistered destination state!\n\n&quot;;
@@ -333,7 +333,7 @@
 			return;
 		}
 #endif
-		evt2state.insert( event_state_map::value_type( evt, dest) );
+		evt2state.insert( typename event_state_map::value_type( evt, dest) );
 #ifdef _DEBUG
 		std::cout &lt;&lt; &quot;machine&lt;&gt;::addTransition(): from=&quot; &lt;&lt; src &lt;&lt; &quot; evt=&quot; &lt;&lt; evt &lt;&lt; &quot; dest=&quot; &lt;&lt; dest &lt;&lt; &quot;\n&quot;;
 #endif
@@ -346,9 +346,10 @@
 	template&lt;typename _state_type, typename _event_type&gt;
 	size_t machine&lt;_state_type,_event_type&gt;::numOffgoingTransitions(const state_type&amp; src) const
 	{
-		const state_map::const_iterator it = states_.find( src );
+		const typename state_map::const_iterator it = states_.find( src );
 		return ( (it == states_.end()) ? 0 : it-&gt;second.offgoing_transitions.size() );
 	}
 } // namespace fsm
 
 #endif
+

Modified: trunk/yake/yake/thread/ZThreadMutexForwarder.h
===================================================================
--- trunk/yake/yake/thread/ZThreadMutexForwarder.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/thread/ZThreadMutexForwarder.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -81,4 +81,5 @@
 } // namespace thread
 } // namespace yake
 
-#endif
\ No newline at end of file
+#endif
+

Modified: trunk/yake/yake/thread/ZThreadThreadForwarder.h
===================================================================
--- trunk/yake/yake/thread/ZThreadThreadForwarder.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/thread/ZThreadThreadForwarder.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -116,4 +116,5 @@
 } // namespace thread
 } // namespace yake
 
-#endif
\ No newline at end of file
+#endif
+

Modified: trunk/yake/yake/thread/yakeThread.h
===================================================================
--- trunk/yake/yake/thread/yakeThread.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/thread/yakeThread.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -192,4 +192,5 @@
 } // namespace thread
 } // namespace yake
 
-#endif
\ No newline at end of file
+#endif
+

Modified: trunk/yake/yake/thread/yakeThreadPrerequisites.h
===================================================================
--- trunk/yake/yake/thread/yakeThreadPrerequisites.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yake/thread/yakeThreadPrerequisites.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -40,4 +40,5 @@
 
 #define YAKE_THREAD_EXCEPT(m,s) throw( yake::Exception(m,s,__FILE__,__LINE__) )
 
-#endif
\ No newline at end of file
+#endif
+

Modified: trunk/yake/yapp/common/yakeCameraControllers.h
===================================================================
--- trunk/yake/yapp/common/yakeCameraControllers.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/common/yakeCameraControllers.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -10,36 +10,36 @@
 
 		void setCamera(graphics::ICamera*);
 
-		void setTarget( const Point3&amp; );
-		void setOffset( const Vector3&amp; );
-		Vector3 getOffset() const;
+		void setTarget( const math::Point3&amp; );
+		void setOffset( const math::Vector3&amp; );
+		math::Vector3 getOffset() const;
 
 		void update(const real dt);
 	private:
-		Point3				mTargetPos;
+		math::Point3		mTargetPos;
 		graphics::ICamera*	mCam;
-		Vector3				mCamOffset;
+		math::Vector3		mCamOffset;
 	};
 	/** @todo move into .inl file! */
 	TopDownCameraController::TopDownCameraController() :
 		mCam(0),
-		mTargetPos(Point3::kZero),
-		mCamOffset(Vector3(2,0,2))
+		mTargetPos(math::Point3::kZero),
+		mCamOffset(math::Vector3(2,0,2))
 	{
 	}
 	void TopDownCameraController::setCamera(graphics::ICamera* cam)
 	{
 		mCam = cam;
 	}
-	void TopDownCameraController::setTarget( const Point3&amp; pt )
+	void TopDownCameraController::setTarget( const math::Point3&amp; pt )
 	{
 		mTargetPos = pt;
 	}
-	void TopDownCameraController::setOffset( const Vector3&amp; offset )
+	void TopDownCameraController::setOffset( const math::Vector3&amp; offset )
 	{
 		mCamOffset = offset;
 	}
-	Vector3 TopDownCameraController::getOffset() const
+	math::Vector3 TopDownCameraController::getOffset() const
 	{
 		return mCamOffset;
 	}
@@ -47,7 +47,7 @@
 	{
 		if (!mCam)
 			return;
-		const Point3 targetCamPos = mTargetPos + mCamOffset;
+		const math::Point3 targetCamPos = mTargetPos + mCamOffset;
 		mCam-&gt;translate( 0.5 * (targetCamPos - mCam-&gt;getPosition()) );
 		mCam-&gt;lookAt( mTargetPos );
 	}
@@ -55,3 +55,4 @@
 } // namespace yake
 
 #endif
+

Modified: trunk/yake/yapp/loader/yakeDotScene.h
===================================================================
--- trunk/yake/yapp/loader/yakeDotScene.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/loader/yakeDotScene.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -53,9 +53,9 @@
 		
 		struct Transform
 		{
-			Vector3		position;
-			Quaternion	rotation;
-			Vector3		scale; 
+			math::Vector3		position;
+			math::Quaternion	rotation;
+			math::Vector3		scale; 
 		};
 		
 		struct NodeDesc : public Desc
@@ -73,34 +73,34 @@
 		
 		struct CameraDesc : public Desc
 		{
-			real								fov;
-			real								aspectRatio;
+			real					fov;
+			real					aspectRatio;
 			graphics::ICamera::ProjectionType	projectionType;
-			String								trackTargetName;
-			Vector3								normal;
+			String					trackTargetName;
+			math::Vector3				normal;
 			
 			struct Clipping
 			{
 				real nearClip;
 				real farClip;
-			}									clipping;
+			} clipping;
 		};
 		
 		struct LightDesc : public Desc
 		{
 			graphics::ILight::LightType	type;
-			bool						visible;
-			bool						castsShadows;
-			Color						diffuseColor;
-			Color						specularColor;
-			Vector3					normal;
+			bool				visible;
+			bool				castsShadows;
+			math::Color			diffuseColor;
+			math::Color			specularColor;
+			math::Vector3			normal;
 			
 			struct Range
 			{
 				real inner;
 				real outer;
 				real falloff;
-			} 							range;
+			} range;
 			
 			struct Attenuation
 			{
@@ -177,14 +177,14 @@
 		virtual void readNode( const SharedPtr&lt;dom::INode&gt;&amp; pNode, String parentNodeName );
 		virtual void readEntity( const SharedPtr&lt;dom::INode&gt;&amp; pNode, String parentNodeName );
 		
-		virtual void readRotation( const SharedPtr&lt;dom::INode&gt;&amp; pNode, Quaternion&amp; rotation );
-		virtual void readPosition( const SharedPtr&lt;dom::INode&gt;&amp; pNode, Vector3&amp; position );
-		virtual void readScale( const SharedPtr&lt;dom::INode&gt;&amp; pNode, Vector3&amp; rScale );
-		virtual void readVector( const SharedPtr&lt;dom::INode&gt;&amp; pNode, Vector3&amp; rVec );
+		virtual void readRotation( const SharedPtr&lt;dom::INode&gt;&amp; pNode, math::Quaternion&amp; rotation );
+		virtual void readPosition( const SharedPtr&lt;dom::INode&gt;&amp; pNode, math::Vector3&amp; position );
+		virtual void readScale( const SharedPtr&lt;dom::INode&gt;&amp; pNode, math::Vector3&amp; rScale );
+		virtual void readVector( const SharedPtr&lt;dom::INode&gt;&amp; pNode, math::Vector3&amp; rVec );
 		
 		virtual void readLight( const SharedPtr&lt;dom::INode&gt;&amp; pNode, String parentNodeName );
 		
-		virtual void readColour( const SharedPtr&lt;dom::INode&gt;&amp; pNode, Color&amp; colour );
+		virtual void readColour( const SharedPtr&lt;dom::INode&gt;&amp; pNode, math::Color&amp; colour );
 		virtual void readLightRange( const SharedPtr&lt;dom::INode&gt;&amp; pNode, LightDesc&amp; );
 		virtual void readLightAttenuation( const SharedPtr&lt;dom::INode&gt;&amp; pNode, LightDesc&amp; );
 		

Modified: trunk/yake/yapp/loader/yakeXODE.h
===================================================================
--- trunk/yake/yapp/loader/yakeXODE.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/loader/yakeXODE.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -1,176 +0,0 @@
-/*
-   ------------------------------------------------------------------------------------
-   This file is part of YAKE
-   Copyright &#169; 2004 The YAKE Team
-   For the latest information visit <A HREF="http://www.yake.org">http://www.yake.org</A> 
-   ------------------------------------------------------------------------------------
-   This program is free software; you can redistribute it and/or modify it under
-   the terms of the GNU Lesser General Public License as published by the Free Software
-   Foundation; either version 2 of the License, or (at your option) any later
-   version.
-
-   This program is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
-   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public License along with
-   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
-   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
-   <A HREF="http://www.gnu.org/copyleft/lesser.txt.">http://www.gnu.org/copyleft/lesser.txt.</A>
-   ------------------------------------------------------------------------------------
-   If you are interested in another license model contact the Yake Team via
-   E-Mail: <A HREF="https://lists.berlios.de/mailman/listinfo/yake-svn">team at yake.org.</A>
-   For more information see the LICENSE file in the root directory of the
-   source code distribution.
-   ------------------------------------------------------------------------------------
-*/
-#ifndef YAKE_DATA_DOTSCENE_H
-#define YAKE_DATA_DOTSCENE_H
-
-#include &lt;yake/data/yakeData.h&gt;
-#include &lt;yapp/model/yakePhysical.h&gt;
-
-namespace yake {
-namespace data {
-namespace parser {
-namespace xode {
-
-using namespace yake::app; // model::Physical
-
-	/** XODEParser base class providing default implementation for DOM parsing.
-	* \todo read lights, environment, external references ..
-	*/
-	class XODEParser
-	{
-	public:
-		XODEParser( model::Physical&amp; rBaseModel );
-		virtual ~XODEParser() {}
-
-		String getName() const
-		{ 
-			return &quot;yake.data.xode&quot;;
-		}
-
-		virtual Version getVersion() const = 0;
-
-		/** Build physics model from DOM!
-			\param file 
-			\return 
-		*/
-		virtual bool load( const SharedPtr&lt;dom::INode&gt;&amp; docNode,  physics::IWorld* pPWorld );
-
-		/** Prepare for next run of load/store.
-		*/
-		virtual void reset();
-	
-	protected:
-		/// XODE &quot;transform&quot; node representation
-		struct Transform
-		{
-			Vector3 	mPosition;
-			Quaternion	mRotation;
-			Vector3		mScale;
-			
-			Transform() : mScale( Vector3::kUnitScale )
-			{
-			}
-			
-			bool isIdentity() const
-			{
-				bool result = mScale == Vector3::kUnitScale;
-				result &amp;= mPosition == Vector3::kZero;
-				result &amp;= mRotation == Quaternion::kZero;
-				
-				return result;
-			}
-			
-			const Transform getDerivedTransform( Transform const&amp; parentTransform )
-			{
-				Transform result;
-				
-				Quaternion const&amp; rParRot = parentTransform.mRotation;
-				Vector3 const&amp; rParPos = parentTransform.mPosition;
-				Vector3 const&amp; rParScale = parentTransform.mScale;
-				
-				result.mPosition = parentTransform.mPosition 
-					+ rParRot*( mPosition*rParScale );
-					
-				result.mRotation = rParRot*mRotation;
-				
-				result.mScale = mScale*rParScale;;  
-				
-				return result;
-			}
-		};
-		
-		/// Default implementations for common functions.
-		
-
-		virtual void readXODE( SharedPtr&lt;dom::INode&gt; const&amp; pNode );
-		virtual void readWorld( SharedPtr&lt;dom::INode&gt; const&amp; pWorldNode );
-		virtual void readSpace( SharedPtr&lt;dom::INode&gt; const&amp; pSpaceNode );
-		virtual void readBody( SharedPtr&lt;dom::INode&gt; const&amp; pBodyNode );
-		virtual void readGeom( SharedPtr&lt;dom::INode&gt; const&amp; pGeomNode, physics::IComplexObject* pParentObject = NULL, Transform const&amp; rParentTransform = Transform() );
-		virtual void readBox( SharedPtr&lt;dom::INode&gt; const&amp; pNode, real&amp; sX, real&amp; sY, real&amp; sZ );
-		virtual void readCappedCylinder( SharedPtr&lt;dom::INode&gt; const&amp; pNode, real&amp; radius, real&amp; length );
-		virtual void readCone( SharedPtr&lt;dom::INode&gt; const&amp; pNode, real&amp; radius, real&amp; length );
-		virtual void readCylinder( SharedPtr&lt;dom::INode&gt; const&amp; pNode, real&amp; radius, real&amp; length );
-		virtual void readPlane( SharedPtr&lt;dom::INode&gt; const&amp; pNode, real&amp; a, real&amp; b, real&amp; c, real&amp; d );
-		virtual void readRay( SharedPtr&lt;dom::INode&gt; const&amp; pNode, real&amp; length );
-		virtual void readSphere( SharedPtr&lt;dom::INode&gt; const&amp; pNode, real&amp; radius );
-		virtual void readTrimesh( SharedPtr&lt;dom::INode&gt; const&amp; pNode, physics::ICollisionGeometry* pCollGeom );
-		
-		virtual void readTransform( SharedPtr&lt;dom::INode&gt; const&amp; pTransformNode, Transform&amp; rTrans );
-
-		virtual void readVector3( SharedPtr&lt;dom::INode&gt; const&amp; pVecNode, Vector3&amp; rVec );  
-		virtual void readPosition( SharedPtr&lt;dom::INode&gt; const&amp; pPosNode, Vector3&amp; rPos );  
-		virtual void readQuaternion( SharedPtr&lt;dom::INode&gt; const&amp; pQuatNode, Quaternion&amp; rQuat );
-		virtual void readRotation( SharedPtr&lt;dom::INode&gt; const&amp; pRotNode, Quaternion&amp; rRot );
-		virtual void readScale( SharedPtr&lt;dom::INode&gt; const&amp; pScaleNode, Vector3&amp; rScale );  
-		virtual void readAxisAngleRot( SharedPtr&lt;dom::INode&gt; const&amp; pRotNode, Quaternion&amp; rRot );
-		virtual void readMass( SharedPtr&lt;dom::INode&gt; const&amp; pMassNode, physics::IBody* pBody, Transform const&amp; rParentTransform ); 
-		virtual void readMassShape( SharedPtr&lt;dom::INode&gt; const&amp; pMShapeNode, physics::IBody* pBody, Transform const&amp; rParentTransform ); 
-		virtual void readMassAdjust( SharedPtr&lt;dom::INode&gt; const&amp; pMAdjustNode, physics::IBody* pBody ); 
-				
-// 		readGroup
-// 		readJointgroup
-// 		virtual void readJoint
-// 		virtual void readMass
-// 		virtual void readMassStruct
-// 		readMassShape
-// 		readTransform
-		
-		
-		
-		
-/*		virtual void readScene( const SharedPtr&lt;dom::INode&gt; &amp; pNode, graphics::ISceneNode* pParentSN );
-		virtual void readNodes( const SharedPtr&lt;dom::INode&gt; &amp; pNodes, graphics::ISceneNode* pParentSN );
-		virtual void readNode( const SharedPtr&lt;dom::INode&gt; &amp; pNode, graphics::ISceneNode* pParentSN );
-		virtual void readEntity( const SharedPtr&lt;dom::INode&gt; &amp; pNode, graphics::ISceneNode* pParentSN );
-		virtual void readOrientation( const SharedPtr&lt;dom::INode&gt; &amp; pNode, Quaternion &amp; orientation );
-		virtual void readPosition( const SharedPtr&lt;dom::INode&gt; &amp; pNode, Vector3 &amp; position );*/
-		
-	private:
-		SharedPtr&lt;dom::INode&gt;					mDocNode;
-		physics::IWorld*					mPWorld;
-		model::Physical&amp;					mBaseModel;
-	};
-	
-	class XODEParserV1 : public XODEParser
-	{
-	public:
-		XODEParserV1( model::Physical&amp; rBaseModel ):XODEParser( rBaseModel ) {}
-		virtual ~XODEParserV1() {}
-		
-		virtual Version getVersion() const
-		{ 
-			return Version( 0, 1, 0 );
-		}
-	};
-
-} // dotscene
-} // serializer
-} // data
-} // yake
-
-#endif

Modified: trunk/yake/yapp/loader/yakeXODEParser.h
===================================================================
--- trunk/yake/yapp/loader/yakeXODEParser.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/loader/yakeXODEParser.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -68,19 +68,19 @@
 		/// XODE &quot;transform&quot; node representation
 		struct Transform
 		{
-			Vector3 	position_;
-			Quaternion	rotation_;
-			Vector3		scale_;
+			math::Vector3		position_;
+			math::Quaternion	rotation_;
+			math::Vector3		scale_;
 			
-			Transform() : scale_( Vector3::kUnitScale )
+			Transform() : scale_( math::Vector3::kUnitScale )
 			{
 			}
 			
 			bool isIdentity() const
 			{
-				bool result = scale_ == Vector3::kUnitScale;
-				result &amp;= position_ == Vector3::kZero;
-				result &amp;= rotation_ == Quaternion::kZero;
+				bool result = scale_ == math::Vector3::kUnitScale;
+				result &amp;= position_ == math::Vector3::kZero;
+				result &amp;= rotation_ == math::Quaternion::kZero;
 				
 				return result;
 			}
@@ -89,9 +89,9 @@
 			{
 				Transform result;
 				
-				Quaternion const&amp; rParRot = parentTransform.rotation_;
-				Vector3 const&amp; rParPos = parentTransform.position_;
-				Vector3 const&amp; rParScale = parentTransform.scale_;
+				const math::Quaternion&amp; rParRot = parentTransform.rotation_;
+				const math::Vector3&amp; rParPos = parentTransform.position_;
+				const math::Vector3&amp; rParScale = parentTransform.scale_;
 				
 				result.position_ = parentTransform.position_ 
 					+ rParRot*( position_*rParScale );
@@ -107,9 +107,9 @@
 		// Event-spawning parser makes heavy use of these
 		struct Desc
 		{
-		  String	name_;
-		  String	parentName_;
-		  Transform	transform_;
+		    String	name_;
+		    String	parentName_;
+		    Transform	transform_;
 		};
 
 		struct BodyDesc : public Desc
@@ -121,21 +121,22 @@
 		    SharedPtr&lt;physics::IShape::Desc&gt; shape_;
 		};
 
-		struct MassDesc : public Desc // ??? is this needed??
+		struct MassDesc : public Desc
 		{
-		  SharedPtr&lt;physics::IBody::MassDesc&gt; mass_;
+		    SharedPtr&lt;physics::IBody::MassDesc&gt; mass_;
 		};
 
 		struct JointDesc : public Desc
 		{
-		  String otherBody_;
+		    String body1_;
+		    String body2_;
 
-		  SharedPtr&lt;physics::IJoint::DescBase&gt; joint_;
+		    SharedPtr&lt;physics::IJoint::DescBase&gt; joint_;
 		};
 
-		struct MaterialDesc : public Desc // ?? no... not needed
+		struct MaterialDesc : public Desc
 		{
-		  physics::IMaterial::Desc material_;
+		    physics::IMaterial::Desc material_;
 		};
 		
 		typedef SignalX&lt; void( const BodyDesc&amp; ) &gt; BodySignal;
@@ -190,7 +191,8 @@
 		virtual void readWorld( const NodeSharedPtr pWorldNode );
 		virtual void readSpace( const NodeSharedPtr pSpaceNode, const String&amp; parent );
 		virtual void readBody( const NodeSharedPtr pBodyNode, const String&amp; parent );
-		virtual void readGeom( const NodeSharedPtr pGeomNode, const String&amp; parent , const Transform&amp; rParentTransform = Transform() );
+		virtual void readGeom( const NodeSharedPtr pGeomNode, const String&amp; parent , 
+			const Transform&amp; rParentTransform = Transform(), bool absoluteTransform = false );
 		virtual void readBox( const NodeSharedPtr pNode, real&amp; sX, real&amp; sY, real&amp; sZ );
 		virtual void readCappedCylinder( const NodeSharedPtr pNode, real&amp; radius, real&amp; length );
 		virtual void readCone( const NodeSharedPtr pNode, real&amp; radius, real&amp; length );
@@ -204,27 +206,32 @@
 		
 		virtual void readTransform( const NodeSharedPtr pTransformNode, Transform&amp; rTrans );
 
-		virtual void readVector3( const NodeSharedPtr pVecNode, Vector3&amp; rVec );  
-		virtual void readPosition( const NodeSharedPtr pPosNode, Vector3&amp; rPos );  
-		virtual void readQuaternion( const NodeSharedPtr pQuatNode, Quaternion&amp; rQuat );
-		virtual void readRotation( const NodeSharedPtr pRotNode, Quaternion&amp; rRot );
-		virtual void readScale( const NodeSharedPtr pScaleNode, Vector3&amp; rScale );  
-		virtual void readAxisAngleRot( const NodeSharedPtr pRotNode, Quaternion&amp; rRot );
+		virtual void readVector3( const NodeSharedPtr pVecNode, math::Vector3&amp; rVec );  
+		virtual void readPosition( const NodeSharedPtr pPosNode, math::Vector3&amp; rPos );  
+		virtual void readQuaternion( const NodeSharedPtr pQuatNode, math::Quaternion&amp; rQuat );
+		virtual void readRotation( const NodeSharedPtr pRotNode, math::Quaternion&amp; rRot );
+		virtual void readScale( const NodeSharedPtr pScaleNode, math::Vector3&amp; rScale );  
+		virtual void readAxisAngleRot( const NodeSharedPtr pRotNode, math::Quaternion&amp; rRot );
 		virtual void readMass( const NodeSharedPtr pMassNode, const String&amp; parent , const Transform&amp; rParentTransform ); 
 		virtual void readMassShape( const NodeSharedPtr pMShapeNode, const String&amp; parent, const Transform&amp; rParentTransform ); 
 		virtual void readMassAdjust( const NodeSharedPtr pMAdjustNode, const String&amp; parent ); 
-		virtual void readJoint( const NodeSharedPtr pJointNode, const String&amp; parent , Transform&amp; rParentTransform );
+		virtual void readJoint( const NodeSharedPtr pJointNode, const String&amp; parent , const Transform&amp; rParentTransform = Transform() );
 		
-		virtual physics::IJoint::DescBase* readBall( const NodeSharedPtr pJointNode, Transform&amp; rJointTransform );
-		virtual physics::IJoint::DescBase* readFixed( const NodeSharedPtr pJointNode, Transform&amp; rJointTransform );
-		virtual physics::IJoint::DescBase* readHinge( const NodeSharedPtr pJointNode, Transform&amp; rJointTransform );
-		virtual physics::IJoint::DescBase* readHinge2( const NodeSharedPtr pJointNode, Transform&amp; rJointTransform );
-		virtual physics::IJoint::DescBase* readSlider( const NodeSharedPtr pJointNode, Transform&amp; rJointTransform );
-		virtual physics::IJoint::DescBase* readUniversal( const NodeSharedPtr pJointNode, Transform&amp; rJointTransform );
+		virtual physics::IJoint::DescBase* readBall( const NodeSharedPtr pJointNode, const Transform&amp; rJointTransform );
+		virtual physics::IJoint::DescBase* readFixed( const NodeSharedPtr pJointNode, const Transform&amp; rJointTransform );
+		virtual physics::IJoint::DescBase* readHinge( const NodeSharedPtr pJointNode, const Transform&amp; rJointTransform );
+		virtual physics::IJoint::DescBase* readHinge2( const NodeSharedPtr pJointNode, const Transform&amp; rJointTransform );
+		virtual physics::IJoint::DescBase* readSlider( const NodeSharedPtr pJointNode, const Transform&amp; rJointTransform );
+		virtual physics::IJoint::DescBase* readUniversal( const NodeSharedPtr pJointNode, const Transform&amp; rJointTransform );
 		
-		virtual void readAnchor( const NodeSharedPtr pAnchorNode, Vector3&amp; rAnchor, Transform&amp; rJointTransform );
-		virtual void readAxis( const NodeSharedPtr pAxisNode, Vector3&amp; rAxis, Transform&amp; rJointTransform );
+		virtual void readAnchor( const NodeSharedPtr pAnchorNode, math::Vector3&amp; rAnchor, const Transform&amp; rJointTransform );
+		virtual void readAxis( const NodeSharedPtr pAxisNode, math::Vector3&amp; rAxis, const Transform&amp; rJointTransform );
 		virtual void readMaterialExt( const NodeSharedPtr pNode, const String&amp; parent  );
+		
+		// override to read xode extensions unknown to original parser
+		virtual void readExtension( const NodeSharedPtr, 
+			const String&amp; parent, 
+			const Transform&amp; parentTransformIfAny );
 
 	private:
 		NodeSharedPtr		mDocNode;
@@ -237,7 +244,7 @@
 		
 		virtual Version getVersion() const
 		{ 
-			return Version( 0, 5, 0 );
+			return Version( 0, 5, 2 );
 		}
 	};
 
@@ -247,3 +254,4 @@
 } // yake
 
 #endif
+

Modified: trunk/yake/yapp/model/yakeComplexModel.h
===================================================================
--- trunk/yake/yapp/model/yakeComplexModel.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/model/yakeComplexModel.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -30,14 +30,14 @@
 #include &lt;yapp/base/yappPrerequisites.h&gt;
 #include &lt;yapp/model/yakeGraphical.h&gt;
 #include &lt;yapp/model/yakePhysical.h&gt;
+#include &lt;yapp/model/yakeModelLink.h&gt;
 
-
 namespace yake {
 	using namespace base::templates;
 namespace model {
-
 	class ModelLink;
 	class ModelMovableLink;
+	class ModelMovableWorldLink;
 
 namespace complex {
 
@@ -57,20 +57,20 @@
 		/** @todo Exchange &quot;Model&quot; with &quot;Entity&quot; (which has dynamic properties etc) ?
 		*/
 		Model* getParentModel() const;
-		void addChildModel( SharedPtr&lt;Model&gt; &amp; rModel );
-		SharedPtr&lt;Model&gt; getChildModelByName( const String &amp; rName ) const;
-		SharedPtr&lt;Model&gt; removeChildModel( const String &amp; rName );
+		void addChildModel( SharedPtr&lt;Model&gt;&amp; rModel );
+		SharedPtr&lt;Model&gt; getChildModelByName( const String&amp; rName ) const;
+		SharedPtr&lt;Model&gt; removeChildModel( const String&amp; rName );
 		SharedPtr&lt;Model&gt; removeChildModel( const SharedPtr&lt;Model&gt;&amp; rModel );
 
 		/**
 			&quot;<A HREF="graphical://model.model...model/graphicalname">graphical://model.model...model/graphicalname</A>&quot;
 			&quot;<A HREF="physical://model.model...model/physicalname">physical://model.model...model/physicalname</A>&quot;
 		*/
-		Physical* queryPhysical( const String &amp; rQuery ) const;
-		Graphical* queryGraphical( const String &amp; rQuery ) const;
+		Physical* queryPhysical( const String&amp; rQuery ) const;
+		Graphical* queryGraphical( const String&amp; rQuery ) const;
 
-		Physical* getPhysicalByName( const String &amp; rName ) const;
-		Graphical* getGraphicalByName( const String &amp; rName ) const;
+		Physical* getPhysicalByName( const String&amp; rName ) const;
+		Graphical* getGraphicalByName( const String&amp; rName ) const;
 
 		/** Adds a &quot;Physical&quot; object to this model.
 			The model references it using a shared pointer.
@@ -79,10 +79,10 @@
 			A name can optionally be supplied. It can then be used for retrieving
 			objects by name.
 		*/
-		void addPhysical( const SharedPtr&lt;Physical&gt; &amp; pPhysical, const String &amp; rName = &quot;&quot;/*, bool bManaged*/ );
+		void addPhysical( const SharedPtr&lt;Physical&gt;&amp; pPhysical, const String&amp; rName = &quot;&quot;/*, bool bManaged*/ );
 
 		/** @copydoc addPhysical */
-		void addPhysical( Physical* pPhysical, const String &amp; rName = &quot;&quot;/*, bool bManaged*/ );
+		void addPhysical( Physical* pPhysical, const String&amp; rName = &quot;&quot;/*, bool bManaged*/ );
 
 		/** Adds a &quot;Graphical&quot; object to this model.
 			The model references it using a shared pointer.
@@ -91,15 +91,15 @@
 			A name can optionally be supplied. It can then be used for retrieving
 			objects by name.
 		*/
-		void addGraphical( const SharedPtr&lt;Graphical&gt; &amp; pGraphical, const String &amp; rName = &quot;&quot; );
+		void addGraphical( const SharedPtr&lt;Graphical&gt;&amp; pGraphical, const String&amp; rName = &quot;&quot; );
 
 		/** @copydoc addGraphical
 		*/
-		void addGraphical( Graphical* pGraphical, const String &amp; rName = &quot;&quot; );
+		void addGraphical( Graphical* pGraphical, const String&amp; rName = &quot;&quot; );
 
-		void addGraphicsController( const SharedPtr&lt;IObjectController&gt; &amp; pController, const String &amp; rName = &quot;&quot; );
-		void addGraphicsController( IObjectController* pController, const String &amp; rName = &quot;&quot; );
-		void addLink( const SharedPtr&lt;ModelLink&gt; &amp; pModelLink, const String &amp; rName = &quot;&quot; );
+		void addGraphicsController( const SharedPtr&lt;IObjectController&gt;&amp; pController, const String&amp; rName = &quot;&quot; );
+		void addGraphicsController( IObjectController* pController, const String&amp; rName = &quot;&quot; );
+		void addLink( const SharedPtr&lt;ModelLink&gt;&amp; pModelLink, const String&amp; rName = &quot;&quot; );
 
 		void updatePhysics( real timeElapsed );
 		void updateGraphics( real timeElapsed );
@@ -113,6 +113,7 @@
 				pair of source/target objects).
 		*/
 		ModelMovableLink* addLink( Movable* pSource, Movable* pTarget );
+		ModelMovableWorldLink* addWorldLink( Movable* pSource, Movable* pTarget );
 	private:
 		typedef AssocVector&lt; String, SharedPtr&lt;Physical&gt; &gt; PhysicalMap;
 		PhysicalMap			mPhysicals;
@@ -122,8 +123,8 @@
 
 		typedef Vector&lt; SharedPtr&lt;Model&gt; &gt; ModelList;
 		ModelList			mChildren;
-
-		typedef AssocVector&lt; Movable*, ModelMovableLink* &gt; MovableLinkMap;
+		
+		typedef AssocVector&lt; Movable*, ModelLinkController&lt; Movable &gt;* &gt; MovableLinkMap;
 		MovableLinkMap		mMovableLinkMap;
 
 		Model*				mParent;
@@ -137,3 +138,4 @@
 } // yake
 
 #endif
+

Modified: trunk/yake/yapp/model/yakeGraphical.h
===================================================================
--- trunk/yake/yapp/model/yakeGraphical.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/model/yakeGraphical.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -93,3 +93,4 @@
 } // yake
 
 #endif
+

Modified: trunk/yake/yapp/model/yakeModel.h
===================================================================
--- trunk/yake/yapp/model/yakeModel.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/model/yakeModel.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -46,3 +46,4 @@
 }
 
 #endif
+

Modified: trunk/yake/yapp/model/yakeModelLink.h
===================================================================
--- trunk/yake/yapp/model/yakeModelLink.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/model/yakeModelLink.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -51,7 +51,7 @@
 	class ModelLinkController : public ModelLink
 	{
 	private:
-		SourceType	* mSource;
+		SourceType*	mSource;
 	public:
 		virtual void setSource( SourceType * source )
 		{ mSource = source; }
@@ -63,3 +63,4 @@
 }
 
 #endif
+

Modified: trunk/yake/yapp/model/yakeModelMovableLink.h
===================================================================
--- trunk/yake/yapp/model/yakeModelMovableLink.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/model/yakeModelMovableLink.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -40,10 +40,10 @@
 	class YAPP_BASE_API ModelMovableLink : public ModelLinkController&lt; Movable &gt;
 	{
 	protected:
-		typedef Signal1&lt; void(const Vector3 &amp;) &gt; PositionSignal;
+		typedef Signal1&lt; void(const Vector3&amp;) &gt; PositionSignal;
 		PositionSignal		mPositionSignal;
 
-		typedef Signal1&lt; void(const Quaternion &amp;) &gt; OrientationSignal;
+		typedef Signal1&lt; void(const Quaternion&amp;) &gt; OrientationSignal;
 		OrientationSignal	mOrientationSignal;
 
 		Vector3				mLastPosition;
@@ -53,14 +53,42 @@
 		YAKE_DECLARE_CONCRETE( ModelMovableLink, &quot;yake.movable&quot; );
 
 		ModelMovableLink();
-		SignalConnection subscribeToPositionChanged( const PositionSignal::slot_type &amp; slot );
-		SignalConnection subscribeToOrientationChanged( const OrientationSignal::slot_type &amp; slot );
+		SignalConnection subscribeToPositionChanged( const PositionSignal::slot_type&amp; slot );
+		SignalConnection subscribeToOrientationChanged( const OrientationSignal::slot_type&amp; slot );
 		SignalConnection subscribeToPositionChanged( Movable* pMovable );
 		SignalConnection subscribeToOrientationChanged( Movable* pMovable );
 		virtual void update( real timeElapsed );
 	};
+	
+	/** A link controller designed to WORLD forward position and/or orientation to
+		to other clients using signals. Factory item id is &quot;yake.movable_world&quot;.
+		@Remarks A controller only fires signals when the values have changed!
+	*/
+	class YAPP_BASE_API ModelMovableWorldLink : public ModelLinkController&lt; Movable &gt;
+	{
+	protected:
+		typedef Signal1&lt; void(const Vector3&amp;) &gt; PositionSignal;
+		PositionSignal		mPositionSignal;
 
+		typedef Signal1&lt; void(const Quaternion&amp;) &gt; OrientationSignal;
+		OrientationSignal	mOrientationSignal;
+
+		Vector3				mLastPosition;
+		Quaternion			mLastOrientation;
+
+	public:
+		YAKE_DECLARE_CONCRETE( ModelMovableWorldLink, &quot;yake.movable_world&quot; );
+
+		ModelMovableWorldLink();
+		SignalConnection subscribeToPositionChanged( const PositionSignal::slot_type&amp; slot );
+		SignalConnection subscribeToOrientationChanged( const OrientationSignal::slot_type&amp; slot );
+		SignalConnection subscribeToPositionChanged( Movable* pMovable );
+		SignalConnection subscribeToOrientationChanged( Movable* pMovable );
+		virtual void update( real timeElapsed );
+	};
+
 }
 }
 
 #endif
+

Modified: trunk/yake/yapp/model/yakePhysical.h
===================================================================
--- trunk/yake/yapp/model/yakePhysical.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/model/yakePhysical.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -27,6 +27,8 @@
 #ifndef YAPP_MODEL_PHYSICAL_H
 #define YAPP_MODEL_PHYSICAL_H
 
+#include &lt;map&gt;
+
 #include &lt;yapp/base/yappPrerequisites.h&gt;
 #include &lt;yake/physics/yakePhysics.h&gt;
 #include &lt;yapp/model/yakeModel.h&gt;
@@ -46,21 +48,21 @@
 
 		/** Adds a physical actor and registers it with a name for easy lookup.
 		*/
-		void addActor( physics::IActorPtr pActor, const String &amp; rName );
+		void addActor( physics::IActorPtr pActor, const String&amp; rName );
 
 		/** Retrieve a physical actor by the name it was registered within this model::Physical object.
 		*/
 		physics::IActorPtr getActorByName( const String&amp; rName ) const;
 
 		/** Adds a body affector. */
-		void addAffector( SharedPtr&lt;physics::IBodyAffector&gt;&amp; pAffector );
+		void addAffector( SharedPtr&lt;physics::IBodyAffector&gt; pAffector, const String&amp; rName );
 
 		/** Adds a joint. */
 		void addJoint( physics::IJointPtr pJoint );
-		//void addJointGroup( SharedPtr&lt;physics::IJointGroup&gt; &amp; pJointGroup );
+		//void addJointGroup( SharedPtr&lt;physics::IJointGroup&gt;&amp; pJointGroup );
 
 		/** Adds a body. */
-		void addBody( SharedPtr&lt;physics::IBody&gt;&amp; pBody, const String &amp; rName );
+		void addBody( SharedPtr&lt;physics::IBody&gt;&amp; pBody, const String&amp; rName );
 
 		/** Translates this model::Physical object by translating all contained actors. */
 		void translate( const Vector3&amp; d );
@@ -68,6 +70,8 @@
 		typedef Vector&lt; physics::IActorPtr &gt; ActorVector;
 		/** @todo optimize! */
 		ActorVector getActors() const;
+
+		void updateAffectors( real timeElapsed );
 	private:
 		typedef AssocVector&lt; String, physics::IActorPtr &gt; ActorMap;
 		ActorMap		mActors;
@@ -75,9 +79,13 @@
 		typedef Vector&lt; physics::IJointPtr &gt; JointList;
 		JointList		mJoints;
 
+		typedef std::pair&lt; String, SharedPtr&lt;physics::IBodyAffector&gt; &gt; AffectorRecord;
+		typedef Vector&lt; AffectorRecord &gt; AffectorList;
+		AffectorList		mAffectors;
 	};
 
 } // model
 } // yake
 
 #endif
+

Modified: trunk/yake/yapp/model/yakePhysicalDataImporter.h
===================================================================
--- trunk/yake/yapp/model/yakePhysicalDataImporter.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/model/yakePhysicalDataImporter.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -52,15 +52,23 @@
 
 	    virtual ~XODEListener() {}		
 
-	    void processBody( const XODEParser::BodyDesc&amp; desc );
-	    void processGeom( const XODEParser::GeomDesc&amp; desc );
-	    void processMass( const XODEParser::MassDesc&amp; desc );
-	    void processJoint( const XODEParser::JointDesc&amp; desc );
-	    void processMaterial( const XODEParser::MaterialDesc&amp; desc );
-	    void postprocess();
+	    virtual void processBody( const XODEParser::BodyDesc&amp; desc );
+	    virtual void processGeom( const XODEParser::GeomDesc&amp; desc );
+	    virtual void processMass( const XODEParser::MassDesc&amp; desc );
+	    virtual void processJoint( const XODEParser::JointDesc&amp; desc );
+	    virtual void processMaterial( const XODEParser::MaterialDesc&amp; desc );
+	    virtual void postprocess();
 
-	private:
+	    IJoint* getJointByName( const String&amp; name )
+	    {
+		if ( joints_.find( name ) != joints_.end() )
+		    return joints_[ name ].joint_;
+		else
+		    return NULL;
+	    }
 
+	protected:
+
 	    struct ActorInfo
 	    {
 		IActor*	actor_;

Modified: trunk/yake/yapp/plugins/ceguiOgreRendererAdapter/pch.h
===================================================================
--- trunk/yake/yapp/plugins/ceguiOgreRendererAdapter/pch.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/plugins/ceguiOgreRendererAdapter/pch.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -37,4 +37,4 @@
 #include &lt;yake/samples/common/yakeExampleApplication.h&gt;
 #include &lt;yake/data/yakeData.h&gt;
 
-#include &lt;Ogre.h&gt;
\ No newline at end of file
+#include &quot;Ogre.h&quot;
\ No newline at end of file

Added: trunk/yake/yapp/plugins/terrainPhysMgr/TerrainOdeActor.h
===================================================================
--- trunk/yake/yapp/plugins/terrainPhysMgr/TerrainOdeActor.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/plugins/terrainPhysMgr/TerrainOdeActor.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -0,0 +1,72 @@
+/*
+  ------------------------------------------------------------------------------------
+  This file is part of YAKE
+  Copyright  2004 The YAKE Team
+  For the latest information visit <A HREF="http://www.yake.org">http://www.yake.org</A> 
+  ------------------------------------------------------------------------------------
+  This program is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free Software
+  Foundation; either version 2 of the License, or (at your option) any later
+  version.
+
+  This program is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+  <A HREF="http://www.gnu.org/copyleft/lesser.txt.">http://www.gnu.org/copyleft/lesser.txt.</A>
+  ------------------------------------------------------------------------------------
+  If you are interested in another license model contact the Yake Team via
+  E-Mail: <A HREF="https://lists.berlios.de/mailman/listinfo/yake-svn">team at yake.org.</A>
+  For more information see the LICENSE file in the root directory of the
+  source code distribution.
+  ------------------------------------------------------------------------------------
+*/
+#ifndef TERRAIN_ACTOR_H
+#define TERRAIN_ACTOR_H
+
+#include &lt;map&gt;
+#include &lt;vector&gt;
+
+#include &lt;yake/plugins/physicsODE/yakePCH.h&gt;
+
+#include &lt;yake/plugins/physicsODE/OdeWorld.h&gt;
+#include &lt;yake/plugins/physicsODE/OdeBody.h&gt;
+#include &lt;yake/plugins/physicsODE/OdeActor.h&gt;
+
+#include &quot;TerrainPhysicsManager.h&quot;
+
+#include &quot;OgrePagingLandScapeTileInfo.h&quot;
+
+using namespace std;
+
+namespace yake
+{
+	namespace physics
+	{
+		class OdeWorld;
+		class OdeGeom;
+		class Ogre::PagingLandScapeTileInfo;
+		
+		class YAKE_PHYSICSODE_API TerrainCollisionDetectionActor : public OdeActor
+		{
+			public:
+				TerrainCollisionDetectionActor( OdeWorld* pOdeWorld );
+				virtual ~TerrainCollisionDetectionActor();
+
+				void createTerrainCollisionDetectionShape( const math::Vector3&amp; rDimensions,
+					        const math::Vector3&amp; rPosition,
+				       		Ogre::PagingLandScapeTileInfo* tileInfo );
+
+				void createTerrainCollisionShape(  const math::Vector3&amp; rPosition, TriangleMeshDesc::VertexVector &amp; vertices,
+						TriangleMeshDesc::IndexVector &amp; indexes);
+				
+				void onCollision( const ActorCollisionInfo &amp; collisionInfo );
+		};
+		//------------------------------------------------------------------------------------
+	} // physics
+} // yake
+
+#endif //	TERRAIN_ACTOR_H

Added: trunk/yake/yapp/plugins/terrainPhysMgr/TerrainOdeShape.h
===================================================================
--- trunk/yake/yapp/plugins/terrainPhysMgr/TerrainOdeShape.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/plugins/terrainPhysMgr/TerrainOdeShape.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -0,0 +1,66 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright  2004 The YAKE Team
+   For the latest information visit <A HREF="http://www.yake.org">http://www.yake.org</A> 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   <A HREF="http://www.gnu.org/copyleft/lesser.txt.">http://www.gnu.org/copyleft/lesser.txt.</A>
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: <A HREF="https://lists.berlios.de/mailman/listinfo/yake-svn">team at yake.org.</A>
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#ifndef YAKE_TERRAIN_ODESHAPES_H
+#define YAKE_TERRAIN_ODESHAPES_H
+
+#include &lt;yake/plugins/physicsODE/OdeShapes.h&gt;
+
+#include &quot;OgreRenderQueue.h&quot;
+#include &quot;OgreRenderable.h&quot;
+#include &quot;OgreMovableObject.h&quot;
+
+#include &quot;OgrePagingLandScapePrerequisites.h&quot;
+#include &quot;OgrePagingLandScapeRenderable.h&quot;
+
+#include &quot;OgrePagingLandScapeTile.h&quot;
+#include &quot;OgrePagingLandScapeTileInfo.h&quot;
+
+namespace yake {
+namespace physics {
+
+	class YAKE_PHYSICSODE_API OdeTerrainCollisionBox : public OdeBox
+	{
+		public:
+			OdeTerrainCollisionBox( dSpace* pSpace, OdeActor* pOwner, real sizex, real sizey, real sizez, Ogre::PagingLandScapeTileInfo * _tileInfo) : 
+				OdeBox( pSpace, pOwner, sizex, sizey, sizez)
+			{
+				tileInfo.pageX = _tileInfo-&gt;pageX;
+				tileInfo.pageZ = _tileInfo-&gt;pageZ;
+				tileInfo.tileX = _tileInfo-&gt;tileX;
+				tileInfo.tileZ = _tileInfo-&gt;tileZ;
+			};
+							
+			Ogre::PagingLandScapeTileInfo * getTileInfo() { return &tileInfo;};
+			
+		protected:
+					
+			Ogre::PagingLandScapeTileInfo 	tileInfo;						
+	};
+	
+}
+}
+#endif //YAKE_TERRAIN_ODESHAPES_H

Added: trunk/yake/yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.h
===================================================================
--- trunk/yake/yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -0,0 +1,109 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright  2004 The YAKE Team
+   For the latest information visit <A HREF="http://www.yake.org">http://www.yake.org</A> 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   <A HREF="http://www.gnu.org/copyleft/lesser.txt.">http://www.gnu.org/copyleft/lesser.txt.</A>
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: <A HREF="https://lists.berlios.de/mailman/listinfo/yake-svn">team at yake.org.</A>
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#ifndef __TERRAIN_PHYS_MANAGER
+#define  __TERRAIN_PHYS_MANAGER
+
+#include &lt;yake/base/yakePCH.h&gt;
+
+#include &lt;Ogre.h&gt;
+
+#include &lt;OgrePagingLandScapeSceneManager.h&gt;
+#include &lt;OgrePagingLandScapeCallBackEvent.h&gt;
+#include &lt;OgrePagingLandScapeListener.h&gt;
+#include &lt;OgreDefaultHardwareBufferManager.h&gt;
+#include &lt;OgrePagingLandScapePageManager.h&gt;
+
+#include &lt;yapp/plugins/terrainPhysMgr/TerrainOdeActor.h&gt;
+
+#include &lt;yake/plugins/graphicsOgre/yakeGraphicsSystem.h&gt;
+#include &lt;yapp/model/yakeGraphical.h&gt;
+
+namespace yake
+{
+namespace physics
+{	
+	class IWorld;
+	class IActor;
+	class OdeWorld;
+	class TerrainCollisionDetectionActor;
+	class TerrainCollisionActor;
+		
+	class PLSMTerrainPhysicsManager
+	{
+		protected:
+			void pageLoaded( Ogre::PagingLandscapeEvent* event);
+			void tileLoaded( Ogre::PagingLandscapeEvent* event);
+			
+			void processAllTilesInPage( Ogre::PagingLandScapePage * page, int pageX, int pageZ);
+			
+			void createCollisionBoundingBox( Ogre::PagingLandScapeTile* tile);
+			
+			void convertIndexDataForOde( Ogre::IndexData* indexData, TriangleMeshDesc::IndexVector &amp; destBuffer) ;
+			
+		public: 
+			PLSMTerrainPhysicsManager( );
+			~PLSMTerrainPhysicsManager();
+	
+			void init( Ogre::PagingLandScapeSceneManager * _sceneManager, IWorld *  _odeWorld, 
+				   graphics::IWorld* graphicsWorld = 0);
+			
+			void processTile( Ogre::PagingLandScapeTileInfo * tileInfo);
+	
+			real getHeightAt( const math::Vector3&amp; position);
+			real getHeightAt( const Ogre::Vector3&amp; position);
+			
+			Ogre::AxisAlignedBox calcActorAABB( IActor * _actor);
+		
+			void placeActorOnTerrain( const math::Vector3 &amp; position,  IActor * _actor);
+			
+		protected:
+			Ogre::PagingLandScapeSceneManager * sceneManager;
+			
+			Ogre::PagingLandscapeDelegate * 	pageLoadListener;		
+			Ogre::PagingLandscapeDelegate * 	tileLoadListener;		
+			
+			Ogre::Ray 				ray;
+			Ogre::RaySceneQuery * 			rayQuery;
+			
+			OdeWorld *	odeWorld;
+			
+			TerrainCollisionDetectionActor * 	terrainCollisionDetectionActor;
+			
+			graphics::IWorld* graphicsWorld;
+			
+			typedef std::list&lt;Ogre::PagingLandScapeTile*&gt; TileList;
+			typedef TileList::iterator TileListIterator;
+			
+			TileList 				alreadyLoadedCollisionTiles;
+			TileList				alreadyLoadedCollisionDetectionTiles;
+	};
+	
+ 	typedef yake::base::templates::SingletonHolder&lt; PLSMTerrainPhysicsManager, 
+	 		yake::base::templates::CreateUsingNew&gt; TerrainPhysicsManager;
+}
+}
+#endif // __TERRAIN_PHYS_MANAGER

Modified: trunk/yake/yapp/raf/pch.h
===================================================================
--- trunk/yake/yapp/raf/pch.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/raf/pch.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -36,4 +36,3 @@
 #include &lt;yake/statemachine/fsm_oo_machine.h&gt;
 #include &lt;yake/ent/ent.h&gt;
 
-#include &lt;yapp/raf/yakePrerequisites.h&gt;

Modified: trunk/yake/yapp/raf/yakeApplication.h
===================================================================
--- trunk/yake/yapp/raf/yakeApplication.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/raf/yakeApplication.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -168,7 +168,7 @@
 		void onKeyUp( const yake::input::KeyboardEvent&amp; rEvent );
 		void onMBDown( uint8 btn );
 		void onMBUp( uint8 btn );
-		void onMouseMoved( const Vector3&amp; rDelta );
+		void onMouseMoved( const math::Vector3&amp; rDelta );
 #endif
 	private:
 		typedef Deque&lt;SharedPtr&lt;base::Library&gt; &gt; LibList;
@@ -225,3 +225,4 @@
 } // namespace yake
 
 #endif
+

Modified: trunk/yake/yapp/raf/yakeApplicationState.h
===================================================================
--- trunk/yake/yapp/raf/yakeApplicationState.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/raf/yakeApplicationState.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -27,6 +27,9 @@
 #ifndef YAKE_RAF_APPLICATIONSTATE_H
 #define YAKE_RAF_APPLICATIONSTATE_H
 
+#include &quot;yapp/raf/yakePrerequisites.h&quot;
+#include &quot;yake/statemachine/fsm_core.h&quot;
+
 namespace yake {
 namespace raf {
 	class Application;

Modified: trunk/yake/yapp/raf/yakePrerequisites.h
===================================================================
--- trunk/yake/yapp/raf/yakePrerequisites.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/raf/yakePrerequisites.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -47,4 +47,5 @@
 } // namespace yake
 
 #endif
+//
 

Modified: trunk/yake/yapp/vehicle/yakeDotVehicle.h
===================================================================
--- trunk/yake/yapp/vehicle/yakeDotVehicle.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/vehicle/yakeDotVehicle.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -31,11 +31,12 @@
 #include &quot;yakeTemplates.h&quot;
 
 namespace yake {
-	namespace data {
-		namespace dom {
-			class INode;
-		}
-	}
+namespace data {
+namespace dom {
+    class INode;
+}
+}
+
 namespace vehicle {
 
 	class YAKE_VEH_API DotVehicleParser
@@ -50,24 +51,24 @@
 		YAKE_MEMBERSIGNAL(public,void(DotVehicleParser&amp;,const String&amp;),OnVehicleTpl);
 	private:
 		void parseVehicleTpl( const data::dom::INode&amp; n );
-		 void parseChassis( const data::dom::INode&amp; n );
-		  void parseBody( const data::dom::INode&amp; n );
-		  void parseShapeSet( const data::dom::INode&amp; n );
-		   void parseShape( const data::dom::INode&amp; n );
-		    void parseShapeBox( const data::dom::INode&amp; n, const String&amp; matId );
-		    void parseShapeSphere( const data::dom::INode&amp; n, const String&amp; matId );
-		   void parseMountPoint( const data::dom::INode&amp; n, VehicleTemplate::MountPointTpl* parentMtPt = 0 );
-		 void parseEngine( const data::dom::INode&amp; n );
-		  void parseRPM( vehicle::VehicleTemplate::CarEngineTpl&amp;, const data::dom::INode&amp; n );
-		  void parseGearBox( vehicle::VehicleTemplate::CarEngineTpl&amp;, const data::dom::INode&amp; n );
-		 //void parseAxle( const data::dom::INode&amp; n );
-		 void parseSteeringGroup( const data::dom::INode&amp; n );
-		 void parseWheel( const data::dom::INode&amp; n );
+		void parseChassis( const data::dom::INode&amp; n );
+		void parseBody( const data::dom::INode&amp; n );
+		void parseShapeSet( const data::dom::INode&amp; n );
+		void parseShape( const data::dom::INode&amp; n );
+		void parseShapeBox( const data::dom::INode&amp; n, const String&amp; matId );
+		void parseShapeSphere( const data::dom::INode&amp; n, const String&amp; matId );
+		void parseMountPoint( const data::dom::INode&amp; n, VehicleTemplate::MountPointTpl* parentMtPt = 0 );
+		void parseEngine( const data::dom::INode&amp; n );
+		void parseRPM( vehicle::VehicleTemplate::CarEngineTpl&amp;, const data::dom::INode&amp; n );
+		void parseGearBox( vehicle::VehicleTemplate::CarEngineTpl&amp;, const data::dom::INode&amp; n );
+		//void parseAxle( const data::dom::INode&amp; n );
+		void parseSteeringGroup( const data::dom::INode&amp; n );
+		void parseWheel( const data::dom::INode&amp; n );
 		void parseEngineTpl( const data::dom::INode&amp; n );
 
-		void parsePosition( const data::dom::INode&amp; n, Vector3&amp; ret );
-		void parseOrientation( const data::dom::INode&amp; n, Quaternion&amp; ret );
-		void parseDirection( const data::dom::INode&amp; n, Vector3&amp; ret );
+		void parsePosition( const data::dom::INode&amp; n, math::Vector3&amp; ret );
+		void parseOrientation( const data::dom::INode&amp; n, math::Quaternion&amp; ret );
+		void parseDirection( const data::dom::INode&amp; n, math::Vector3&amp; ret );
 
 		VehicleTemplate*	mpCurrVehTpl;
 	};
@@ -77,3 +78,4 @@
 
 
 #endif
+

Modified: trunk/yake/yapp/vehicle/yakeInterfaces.h
===================================================================
--- trunk/yake/yapp/vehicle/yakeInterfaces.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/vehicle/yakeInterfaces.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -28,7 +28,7 @@
 #define YAKE_VEHICLE_INTERFACES_H
 
 #include &lt;yapp/vehicle/yakePrerequisites.h&gt;
-#include &quot;yakeTemplates.h&quot;
+#include &lt;yapp/vehicle/yakeTemplates.h&gt;
 
 namespace yake {
 namespace vehicle {
@@ -66,8 +66,8 @@
 		virtual void setSteering( const uint32 sg, const real ) = 0;
 		virtual real getSteering( const uint32 sg ) const = 0;
 
-		virtual Vector3 getChassisPosition() const = 0;
-		virtual Quaternion getChassisOrientation() const = 0;
+		virtual math::Vector3 getChassisPosition() const = 0;
+		virtual math::Quaternion getChassisOrientation() const = 0;
 		virtual Movable* getChassisMovable() const = 0;
 
 		virtual void enableDebugGeometry(graphics::IWorld&amp;) = 0;
@@ -85,8 +85,11 @@
 
 		virtual void updateSimulation( real timeElapsed ) = 0;
 
-		virtual void setThrottle( real throttle ) = 0;
-		virtual real getThrottle() const = 0;
+		/** set input signal for an engine. That is throttle for a car
+		 * and voltage for electric motor.
+		 */
+		virtual void setInputSignal( real value ) = 0;
+		virtual real getInputSignal() const = 0;
 	};
 
 	/** Interface to a vehicle engine.
@@ -98,6 +101,15 @@
 		virtual ~ICarEngine() 
 		{}
 
+		virtual void setThrottle( real throttle ) = 0;
+		virtual real getThrottle() const = 0;
+
+		/** Inherited general engine interface. 
+		 * Implemented in terms of car engine.
+		 */
+		virtual void setInputSignal( real value ) { setThrottle( value ); }
+		virtual real getInputSignal() const { return getThrottle(); }
+
 		//virtual void setParameter( const String &amp; name, const String &amp; value );
 		virtual void setParamMinRPM( const real rpm ) = 0;
 		virtual void setParamMaxRPM( const real rpm ) = 0;
@@ -113,16 +125,31 @@
 		virtual real getDriveTorque() const = 0;
 	};
 
-	/** A thruster is a special kind of engine. It applies force to the vehicle
-		it's attached to at a specified offset, direction etc.
+	/** A thruster is a special kind of IEngine which applies force to the vehicle it's attached to at a specified offset, direction etc.
+		Thruster force is applied lineary Fmin + k_throttle*( Fmax - Fmin ).
 		@see MountedThruster
 		@see vehicle::IEngine
 	*/
 	class YAKE_VEH_API IThruster : public IEngine
 	{
+	public:
+	    virtual real getForce() const { return mForce; }
+
 	protected:
-		virtual ~IThruster();
-		IThruster();
+	    virtual void setForce( real force ) { mForce = force; }
+
+	protected:
+	    real	mForce; // cached force value
+	};
+
+	/** Simplest class of linear thruster. If mounted it just applies force and does no
+	 * additional calculations.
+	*/
+	class YAKE_VEH_API ILinearThruster : public IThruster
+	{
+	protected:
+		virtual ~ILinearThruster();
+		ILinearThruster();
 	public:
 		/** At least the following methods are inherited from vehicle::IEngine:
 
@@ -134,13 +161,12 @@
 		real getMinimumForce() const;
 		void setMaximumForce( real force );
 		real getMaximumForce() const;
-		real getForce() const;
+		virtual real getForce() const;
 	protected:
-		void setForce( real force );
+		virtual void setForce( real force );
 	private:
 		real	mMaxForce;
 		real	mMinForce;
-		real	mForce;
 	};
 
 	/** A thruster that can be attached to a mount point.
@@ -181,3 +207,4 @@
 
 
 #endif
+

Modified: trunk/yake/yapp/vehicle/yakeMountPoint.h
===================================================================
--- trunk/yake/yapp/vehicle/yakeMountPoint.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/vehicle/yakeMountPoint.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -27,7 +27,7 @@
 #ifndef YAKE_VEHICLE_MOUNTPOINT_H
 #define YAKE_VEHICLE_MOUNTPOINT_H
 
-#include &quot;yakePrerequisites.h&quot;
+#include &quot;yapp/vehicle/yakePrerequisites.h&quot;
 
 namespace yake {
 namespace vehicle {
@@ -72,20 +72,20 @@
 		virtual bool isSuitableFor( const Mountable* mountable ) const;
 		void attach( Mountable* mountable );
 		void detach( Mountable* mountable );
-		void setDirection( const Vector3&amp; dir );
-		Vector3 getDirection() const;
-		virtual void setOrientation( const Quaternion&amp; );
-		virtual Quaternion getOrientation() const;
-		virtual void setPosition(const Vector3&amp; rPosition );
-		virtual Vector3 getPosition() const;
-		Vector3 getDerivedPosition() const;
-		Quaternion getDerivedOrientation() const;
-		void lookAt(const Vector3&amp;);
+		void setDirection( const math::Vector3&amp; dir );
+		math::Vector3 getDirection() const;
+		virtual void setOrientation( const math::Quaternion&amp; );
+		virtual math::Quaternion getOrientation() const;
+		virtual void setPosition(const math::Vector3&amp; rPosition );
+		virtual math::Vector3 getPosition() const;
+		math::Vector3 getDerivedPosition() const;
+		math::Quaternion getDerivedOrientation() const;
+		void lookAt(const math::Vector3&amp;);
 	private:
 		typedef Deque&lt; Mountable* &gt; MountablePtrList;
 		MountablePtrList	mMountables;
-		Quaternion			mOrientation;
-		Vector3				mPosition;
+		math::Quaternion			mOrientation;
+		math::Vector3				mPosition;
 		typedef Deque&lt; std::pair&lt;MountPoint*,bool&gt; &gt; MountPointList;
 		MountPointList		mChildren;
 		MountPoint*			mParent;
@@ -97,3 +97,4 @@
 
 
 #endif
+

Modified: trunk/yake/yapp/vehicle/yakeNativeOde.h
===================================================================
--- trunk/yake/yapp/vehicle/yakeNativeOde.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/vehicle/yakeNativeOde.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -27,7 +27,7 @@
 #ifndef YAKE_VEHICLE_NATIVEODE_H
 #define YAKE_VEHICLE_NATIVEODE_H
 
-#include &quot;yakePrerequisites.h&quot;
+#include &lt;yapp/vehicle/yakePrerequisites.h&gt;
 
 namespace yake {
 namespace vehicle {
@@ -68,11 +68,11 @@
 	public:
 		GenericVehicleSystem();
 		~GenericVehicleSystem();
-		virtual IVehicle* create(const VehicleTemplate&amp;, physics::IWorld&amp; PWorld);
+		virtual IVehicle* create(const VehicleTemplate&amp;, physics::IWorld&amp; PWorld, model::Physical&amp; physModel);
 		virtual bool loadTemplates(const String&amp; fn);
 		virtual VehicleTemplate* getTemplate(const String&amp; tpl) const;
 		//virtual VehicleTemplate* cloneTemplate(const String&amp; tpl);
-		virtual IVehicle* create(const String&amp; tpl, physics::IWorld&amp; PWorld);
+		virtual IVehicle* create(const String&amp; tpl, physics::IWorld&amp; PWorld, model::Physical&amp; physModel);
 	private:
 		void _onVehicleTpl(DotVehicleParser&amp; parser, const String&amp; tplId);
 	private:
@@ -98,8 +98,8 @@
 		virtual IEnginePtrList getEngineInterfaces() const;
 		virtual IWheel* getWheelInterface(const String&amp; id) const;
 
-		virtual Vector3 getChassisPosition() const;
-		virtual Quaternion getChassisOrientation() const;
+		virtual math::Vector3 getChassisPosition() const;
+		virtual math::Quaternion getChassisOrientation() const;
 		virtual Movable* getChassisMovable() const;
 
 		virtual void setSteering( const uint32 sg, const real );
@@ -108,7 +108,7 @@
 		virtual void enableDebugGeometry(graphics::IWorld&amp;);
 		virtual void disableDebugGeometry();
 
-		void _create(const VehicleTemplate&amp;, physics::IWorld&amp; PWorld);
+		void _create(const VehicleTemplate&amp;, physics::IWorld&amp; PWorld, model::Physical&amp; physModel );
 
 		YAKE_MEMBERSIGNAL(private,void(real),UpdateEngineSimulation);
 		YAKE_MEMBERSIGNAL(private,void(void),ApplyThrusterToTargets);
@@ -205,10 +205,12 @@
 					const VehicleTemplate::WheelTpl&amp; tpl,
 					physics::IWorld&amp; PWorld );
 
-		virtual void setPosition(const Vector3&amp;) {}
-		virtual Vector3 getPosition() const;
-		virtual void setOrientation(const Quaternion&amp;) {}
-		virtual Quaternion getOrientation() const;
+		virtual void setPosition(const math::Vector3&amp;) {}
+		virtual math::Vector3 getPosition() const;
+		virtual math::Vector3 getDerivedPosition() const;
+		virtual void setOrientation(const math::Quaternion&amp;) {}
+		virtual math::Quaternion getOrientation() const;
+		virtual math::Quaternion getDerivedOrientation() const;
 
 		virtual real getRadius() const;
 
@@ -220,8 +222,8 @@
 
 		void _applyDriveTq( const real tq );
 	private:
-		void _applyTq( const Vector3 &amp; torque );
-		void _applyBrakeTq( const Vector3 &amp; torque );
+		void _applyTq( const math::Vector3 &amp; torque );
+		void _applyBrakeTq( const math::Vector3 &amp; torque );
 		void _applyMotor( real velocity, real fmax );
 
 		void _onPreStepInternal( const real dt );
@@ -230,12 +232,12 @@
 		physics::IActorPtr		mpChassis;
 		physics::IJointPtr		mpJoint;
 		physics::IActorPtr		mpWheel;
-		real					mRadius;
-		real					mTargetSteer;
-		real					mCurrSteer;
+		real				mRadius;
+		real				mTargetSteer;
+		real				mCurrSteer;
 		SignalConnection		mPreStepSigConn, mPostStepSigConn;
-		real					mBrakeRatio;
-		real					mSkid;
+		real				mBrakeRatio;
+		real				mSkid;
 	};
 #endif // YAKE_VEHICLE_USE_ODE
 	class GenericMountPoint : public MountPoint
@@ -248,17 +250,40 @@
 		//ThrusterPtrList		mThrusters; // references thruster engines (does NOT own them!)
 	};
 
+	/** In terms of control systems it is just a gain.
+	 * Output = input*K_gain; force = voltage*k.
+	 */
 	class GenericThruster : public IThruster
 	{
 	public:
-		GenericThruster();
+	    GenericThruster();
 
-		virtual void setThrottle( real throttle );
-		virtual real getThrottle() const;
+	    virtual void setInputSignal( real voltage );
+	    virtual real getInputSignal() const;
+
+	    virtual void updateSimulation( real timeElapsed );
+
+	    virtual void setGain( real gain );
+	    virtual real getGain() const;
+
+	private:
+	    real    mVoltage; // cached gain value
+
+	    /// gain coefficient is the only *real* characteristic of such device.
+	    real    mGain;
+	};
+
+	class GenericLinearThruster : public ILinearThruster
+	{
+	public:
+		GenericLinearThruster();
+
+		virtual void setInputSignal( real voltage );
+		virtual real getInputSignal() const;
 		virtual void updateSimulation( real timeElapsed );
 
 	private:
-		real	mThrottle;
+		real	mVoltage;
 	};
 	class GenericMountedThruster : public IMountedThruster
 	{
@@ -274,3 +299,4 @@
 
 
 #endif
+

Modified: trunk/yake/yapp/vehicle/yakeTemplates.h
===================================================================
--- trunk/yake/yapp/vehicle/yakeTemplates.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/vehicle/yakeTemplates.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -27,7 +27,7 @@
 #ifndef YAKE_VEHICLE_TEMPLATES_H
 #define YAKE_VEHICLE_TEMPLATES_H
 
-#include &quot;yakePrerequisites.h&quot;
+#include &quot;yapp/vehicle/yakePrerequisites.h&quot;
 
 namespace yake {
 namespace vehicle {
@@ -40,31 +40,31 @@
 		typedef AssocVector&lt; String, MountPointTpl &gt; MountPointTplList;
 		struct MountPointTpl
 		{
-			Vector3				mPosition;
-			Quaternion			mOrientation;
-			Vector3				mDirection;
-			bool				mUseDirection;
+			math::Vector3		mPosition;
+			math::Quaternion	mOrientation;
+			math::Vector3		mDirection;
+			bool			mUseDirection;
 			MountPointTplList	mChildren;
 			MountPointTpl(
-				const Vector3&amp; pos = Vector3::kZero,
-				const Quaternion rot = Quaternion::kIdentity) :
+				const math::Vector3&amp; pos = math::Vector3::kZero,
+				const math::Quaternion&amp; rot = math::Quaternion::kIdentity) :
 				mPosition(pos),
 				mOrientation(rot),
 				mUseDirection(false)
 			{}
 			MountPointTpl(
-				const Vector3&amp; pos,
-				const Vector3&amp; dir) :
+				const math::Vector3&amp; pos,
+				const math::Vector3&amp; dir) :
 				mPosition(pos),
 				mDirection(dir),
 				mUseDirection(true)
 			{}
 			MountPointTpl&amp; addMountPoint(
-				const Vector3&amp; pos = Vector3::kZero,
-				const Quaternion rot = Quaternion::kIdentity);
+				const math::Vector3&amp; pos = math::Vector3::kZero,
+				const math::Quaternion&amp; rot = math::Quaternion::kIdentity);
 			MountPointTpl&amp; addMountPoint(
-				const Vector3&amp; pos,
-				const Vector3&amp; dir);
+				const math::Vector3&amp; pos,
+				const math::Vector3&amp; dir);
 		};
 		enum GearMode
 		{
@@ -87,7 +87,9 @@
 		{
 			real				minForce;
 			real				maxForce;
+			real				gain;
 			String				mountPt;
+			String				type;
 			ThrusterTpl(real minF = 0., real maxF = 1., const String&amp; mtPt = &quot;&quot;) : minForce(minF), maxForce(maxF), mountPt(mtPt) {}
 		};
 		struct CarEngineTpl : public EngineTpl
@@ -117,36 +119,38 @@
 		typedef AssocVector&lt;String,EngineTpl*&gt; EngineTplList;
 
 		typedef Deque&lt;physics::IShape::Desc*&gt; ShapeTplList;
-
+		
 		struct ChassisTpl
 		{
-			Vector3			mPosition; // initial position
+			math::Vector3		mPosition; // initial position
 			real			mMass;
-			ShapeTplList	mChassisShapes;
+			ShapeTplList		mChassisShapes;
 			String			mGfxReference; // e.g. dotScene file
+			String			mPhysicsBody; // e.g. physical body loaded from .xode file
+			    
 			ChassisTpl() : 
-				mPosition(Vector3::kZero),
-				mMass(real(1.6))
+				mPosition(math::Vector3::kZero),
+				mMass(real(1.6)) // @todo FIXME magic number
 			{}
 		};
 
 		struct WheelTpl
 		{
 			uint32			mAxle;
-			Vector3			mPosition;
-			Quaternion		mOrientation;
+			math::Vector3		mPosition;
+			math::Quaternion	mOrientation;
 			uint32			mSteeringGroup;
 			real			mRadius;
 			real			mMass;
 			bool			mMassRelativeToChassis;
 			real			mSuspensionSpring;
 			real			mSuspensionDamping;
-			//String			mGfxReference; // e.g. dotScene file
-			//String			mGfxReferenceType; // e.g. &quot;dotscene&quot;
+			//String		mGfxReference; // e.g. dotScene file
+			//String		mGfxReferenceType; // e.g. &quot;dotscene&quot;
 			String			mMaterial;
 			WheelTpl(
-				const Vector3&amp; position = Vector3::kZero,
-				const Quaternion&amp; orientation = Quaternion::kIdentity,
+				const math::Vector3&amp; position = math::Vector3::kZero,
+				const math::Quaternion&amp; orientation = math::Quaternion::kIdentity,
 				const real radius = real(0.2),
 				const real mass = real(0.018),
 				const bool massRelativeToChassis = true,
@@ -175,9 +179,9 @@
 
 		ChassisTpl		mChassis;
 		MountPointTplList	mMountPoints;
-		EngineTplList	mEngines;
+		EngineTplList		mEngines;
 		uint32			mSteeringGroups;
-		WheelTplList	mWheels;
+		WheelTplList		mWheels;
 
 		VehicleTemplate() : mSteeringGroups(0)
 		{}
@@ -200,3 +204,4 @@
 
 
 #endif
+

Modified: trunk/yake/yapp/vehicle/yakeVehicle.h
===================================================================
--- trunk/yake/yapp/vehicle/yakeVehicle.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/vehicle/yakeVehicle.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -44,3 +44,4 @@
 #include &lt;yapp/vehicle/yakeVehicleSystem.h&gt;
 
 #endif
+

Modified: trunk/yake/yapp/vehicle/yakeVehicleSystem.h
===================================================================
--- trunk/yake/yapp/vehicle/yakeVehicleSystem.h	2006-03-19 17:10:16 UTC (rev 1301)
+++ trunk/yake/yapp/vehicle/yakeVehicleSystem.h	2006-03-19 17:54:00 UTC (rev 1302)
@@ -27,7 +27,7 @@
 #ifndef YAKE_VEHICLE_SYSTEM_H
 #define YAKE_VEHICLE_SYSTEM_H
 
-#include &quot;yakePrerequisites.h&quot;
+#include &lt;yapp/vehicle/yakePrerequisites.h&gt;
 
 namespace yake {
 namespace vehicle {
@@ -38,15 +38,15 @@
 		YAKE_DECLARE_REGISTRY_0(IVehicleSystem,String);
 	public:
 		virtual ~IVehicleSystem() {}
-		virtual IVehicle* create(const VehicleTemplate&amp;, physics::IWorld&amp; PWorld) = 0;
+		virtual IVehicle* create(const VehicleTemplate&amp;, physics::IWorld&amp; PWorld, model::Physical&amp; physModel ) = 0;
 		virtual bool loadTemplates(const String&amp; fn) = 0;
 		//virtual VehicleTemplate* cloneTemplate(const String&amp; tpl) = 0;
 		virtual VehicleTemplate* getTemplate(const String&amp; tpl) const = 0;
-		virtual IVehicle* create(const String&amp; tpl, physics::IWorld&amp; PWorld) = 0;
+		virtual IVehicle* create(const String&amp; tpl, physics::IWorld&amp; PWorld, model::Physical&amp; physModel) = 0;
 	};
 
 } // namespace vehicle
 } // namespace yake
 
+#endif
 
-#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000371.html">[Yake-svn] r1301 - in trunk/yake/common/bin: debug release
</A></li>
	<LI>Next message: <A HREF="000373.html">[Yake-svn] r1303 - in trunk/yake/src/yapp/samples: . physics physics/paging_terrain
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#372">[ date ]</a>
              <a href="thread.html#372">[ thread ]</a>
              <a href="subject.html#372">[ subject ]</a>
              <a href="author.html#372">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yake-svn">More information about the Yake-svn
mailing list</a><br>
</body></html>
