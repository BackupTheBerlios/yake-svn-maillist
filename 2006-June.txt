From codeandroid at berlios.de  Fri Jun  9 19:01:01 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Fri, 9 Jun 2006 19:01:01 +0200
Subject: [Yake-svn] r1327 - trunk/yake/src/yake/samples/base/registry
Message-ID: <200606091701.k59H119A009505@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-09 19:00:57 +0200 (Fri, 09 Jun 2006)
New Revision: 1327

Modified:
   trunk/yake/src/yake/samples/base/registry/yakeUnitTest.cpp
Log:
cleanup

Modified: trunk/yake/src/yake/samples/base/registry/yakeUnitTest.cpp
===================================================================
--- trunk/yake/src/yake/samples/base/registry/yakeUnitTest.cpp	2006-04-25 20:12:43 UTC (rev 1326)
+++ trunk/yake/src/yake/samples/base/registry/yakeUnitTest.cpp	2006-06-09 17:00:57 UTC (rev 1327)
@@ -1,110 +1,89 @@
-//****************************************************************************
-//**
-//**    UNITTEST.CPP
-//**    Unit test
-//**
-//****************************************************************************
-
-//============================================================================
-//    IMPLEMENTATION HEADERS
-//============================================================================
 // Yake
 #include <yake/base/yake.h>
 #include <yake/base/templates/yakeRegistry.h>
 
-//============================================================================
-//    INTERFACE STRUCTURES / UTILITY CLASSES
-//============================================================================
-using namespace yake::base;
-using namespace yake::base::templates;
+using namespace yake;
+using namespace yake::templates;
 
-namespace yake
-{
-namespace testsuite
-{
+namespace yake {
+namespace testsuite {
 	
-struct INetworkDriver
-{
-	// Destructor.
-	virtual ~INetworkDriver() {}
+	struct INetworkDriver
+	{
+		YAKE_DECLARE_REGISTRY_0( INetworkDriver, String )
 
-	// Resolve host.
-	virtual const String resolveHost() const = 0;
+		// Destructor.
+		virtual ~INetworkDriver() {}
 
-YAKE_DECLARE_REGISTRY_0( INetworkDriver, String )
-};
+		// Resolve host.
+		virtual const String resolveHost() const = 0;
+	};
 
-YAKE_IMPLEMENT_REGISTRY( INetworkDriver )
+	YAKE_IMPLEMENT_REGISTRY( INetworkDriver )
 
 
-namespace win32
-{
+namespace win32 {
 
-class NetworkDriver : public INetworkDriver
-{		
-YAKE_DECLARE_CLASS( yake::testsuite::win32::NetworkDriver )
-// Class
-public:
-	// Destructor.
-	virtual ~NetworkDriver() {}
+	class NetworkDriver : public INetworkDriver
+	{		
+	public:
+		YAKE_DECLARE_CONCRETE( NetworkDriver, "win32" )
 
-// Methods
-public:
-	// Resolve host.
-	const String resolveHost() const
-	{
-		return String( "Hello, its me - the win32 implementation :)" );
-	}
+		virtual ~NetworkDriver() {}
 
-YAKE_DECLARE_CONCRETE( NetworkDriver, "win32" )
-};
+		virtual const String resolveHost() const
+		{
+			return String( "Hello, its me - the win32 implementation :)" );
+		}
+	};
 
-YAKE_REGISTER_CONCRETE( NetworkDriver )
+	YAKE_REGISTER_CONCRETE( NetworkDriver )
 
-}
-namespace Linux
-{
+} // namespace win32
 
-class NetworkDriver : public INetworkDriver
-{
+namespace Linux {
 
-YAKE_DECLARE_CLASS( yake::testsuite::linux::NetworkDriver )
-// Class
-public:
-	// Destructor.
-	virtual ~NetworkDriver() {}
-
-// Methods
-public:
-	// Resolve host.
-	const String resolveHost() const
+	class NetworkDriver : public INetworkDriver
 	{
-		return String( "Hello, its me - the Linux implementation ;)" );
-	}
+	public:
+		YAKE_DECLARE_CONCRETE( NetworkDriver, "linux" )
 
-YAKE_DECLARE_CONCRETE( NetworkDriver, "linux" )
-};
+		virtual ~NetworkDriver() {}
 
-YAKE_REGISTER_CONCRETE( NetworkDriver )
 
-} // linux
+		virtual const String resolveHost() const
+		{
+			return String( "Hello, its me - the Linux implementation ;)" );
+		}
+	};
 
-} // testsuite
-} // yake
+	YAKE_REGISTER_CONCRETE( NetworkDriver )
 
+} // namespace linux
+
+} // namespace testsuite
+} // namespace yake
+
 //============================================================================
 //    IMPLEMENTATION FUNCTIONS
 //============================================================================
 int main()
 {
 	using namespace yake;
-	using namespace yake::base;
 	using namespace yake::testsuite;
 
+	// Create a 'default' driver. (Can be 'Win32' or 'linux', whatever is registered first (or at all)).
 	SharedPtr< INetworkDriver > pNetDriver = create_default< INetworkDriver >();
-
 	std::cout << pNetDriver->resolveHost();
 
+	// Explicitely create the 'Win32' driver.
+	SharedPtr< INetworkDriver > pWin32NetDriver = create< INetworkDriver >("win32");
+	std::cout << pWin32NetDriver->resolveHost();
+
+	// Explicitely create the 'Linux' driver.
+	SharedPtr< INetworkDriver > pLinuxNetDriver = create< INetworkDriver >("linux");
+	std::cout << pLinuxNetDriver->resolveHost();
+
 	// Wait for a keystroke (in debug builds only).
 #if defined( YAKE_DEBUG_BUILD )
 	std::cout << std::endl << "Waiting for you...";



From codeandroid at berlios.de  Fri Jun  9 23:47:40 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Fri, 9 Jun 2006 23:47:40 +0200
Subject: [Yake-svn] r1328 - in trunk/yake: scripts/msvc8 scripts/msvc8/plugins/graphics scripts/msvc8/samples/model src/yake src/yake/loader src/yake/model src/yake/plugins/graphicsOgre src/yake/samples src/yake/samples/model src/yake/samples/model/dotScene yake yake/base yake/base/templates yake/graphics yake/loader yake/model yake/physics yake/plugins/graphicsOgre yake/plugins/physicsODE yake/samples yake/samples/model yake/samples/model/dotScene yake/samples/net/common yapp/model
Message-ID: <200606092147.k59LleQs024949@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-09 23:47:29 +0200 (Fri, 09 Jun 2006)
New Revision: 1328

Added:
   trunk/yake/scripts/msvc8/loader.vcproj
   trunk/yake/scripts/msvc8/model.vcproj
   trunk/yake/scripts/msvc8/samples/model/sampleDotScene.vcproj
   trunk/yake/src/yake/loader/
   trunk/yake/src/yake/loader/pch.cpp
   trunk/yake/src/yake/loader/yakeDotScene.cpp
   trunk/yake/src/yake/model/
   trunk/yake/src/yake/model/pch.cpp
   trunk/yake/src/yake/model/yakeComponentCreatorManager.cpp
   trunk/yake/src/yake/model/yakeGraphical.cpp
   trunk/yake/src/yake/model/yakeGraphicalCreator.cpp
   trunk/yake/src/yake/model/yakeGraphicalDotSceneLoader.cpp
   trunk/yake/src/yake/model/yakeModel.cpp
   trunk/yake/src/yake/model/yakeModelComponentContainer.cpp
   trunk/yake/src/yake/model/yakeModelLinkContainer.cpp
   trunk/yake/src/yake/model/yakeModelManager.cpp
   trunk/yake/src/yake/model/yakePhysical.cpp
   trunk/yake/src/yake/samples/model/
   trunk/yake/src/yake/samples/model/dotScene/
   trunk/yake/src/yake/samples/model/dotScene/demo.cpp
   trunk/yake/src/yake/samples/model/dotScene/pch.cpp
   trunk/yake/yake/loader/
   trunk/yake/yake/loader/loader.h
   trunk/yake/yake/loader/pch.h
   trunk/yake/yake/loader/prerequisites.h
   trunk/yake/yake/loader/yakeDotScene.h
   trunk/yake/yake/model/
   trunk/yake/yake/model/model.h
   trunk/yake/yake/model/model_component.h
   trunk/yake/yake/model/model_graphical_dotscene_loader.h
   trunk/yake/yake/model/model_link.h
   trunk/yake/yake/model/pch.h
   trunk/yake/yake/model/prerequisites.h
   trunk/yake/yake/samples/model/
   trunk/yake/yake/samples/model/dotScene/
   trunk/yake/yake/samples/model/dotScene/pch.h
   trunk/yake/yake/samples/net/common/common.h
   trunk/yake/yake/samples/net/common/commonEvents.h
   trunk/yake/yake/samples/net/common/config.h
Modified:
   trunk/yake/scripts/msvc8/plugins/graphics/graphicsOgre.vcproj
   trunk/yake/scripts/msvc8/yake.sln
   trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreNode.cpp
   trunk/yake/yake/base/templates/yakeVector.h
   trunk/yake/yake/base/yakePrerequisites.h
   trunk/yake/yake/base/yakeString.h
   trunk/yake/yake/graphics/yakeGraphicalWorld.h
   trunk/yake/yake/physics/yakePhysicsJoint.h
   trunk/yake/yake/plugins/graphicsOgre/graphicsOgreNode.h
   trunk/yake/yake/plugins/graphicsOgre/yakeGraphicsWorld.h
   trunk/yake/yake/plugins/physicsODE/OdeJoint.h
   trunk/yake/yapp/model/yakePhysicalDataImporter.h
Log:
new model component (+demo),
new loader component,
added more network component headers,
small updates for physics and graphics components

Added: trunk/yake/scripts/msvc8/loader.vcproj
===================================================================
--- trunk/yake/scripts/msvc8/loader.vcproj	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/scripts/msvc8/loader.vcproj	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,244 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="loader"
+	ProjectGUID="{2E5A589E-41FE-4BE9-80A0-1F8570944486}"
+	RootNamespace="yake"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../common/bin/$(ConfigurationName)"
+			IntermediateDirectory="../../common/obj/$(ConfigurationName)/$(ProjectName)"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../;../../dependencies;../../dependencies/boost;../../dependencies/ttl"
+				PreprocessorDefinitions="_STLP_DEBUG;WIN32;_DEBUG;_CONSOLE;YAKE_LOADER_EXPORTS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="yake/loader/pch.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="base.lib physics.lib graphics.lib data.lib"
+				OutputFile="$(OutDir)/$(ProjectName).dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../common/lib/$(ConfigurationName);../../dependencies/lib"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
+				SubSystem="1"
+				ImportLibrary="../../common/lib/$(ConfigurationName)/$(ProjectName).lib"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../common/bin/$(ConfigurationName)"
+			IntermediateDirectory="../../common/obj/$(ConfigurationName)/$(ProjectName)"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../;../../dependencies;../../dependencies/boost;../../dependencies/ttl"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;YAKE_LOADER_EXPORTS"
+				RuntimeLibrary="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="yake/loader/pch.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="base.lib physics.lib graphics.lib data.lib"
+				OutputFile="$(OutDir)/$(ProjectName).dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../common/lib/$(ConfigurationName);../../dependencies/lib"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="../../common/lib/$(ConfigurationName)/$(ProjectName).lib"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="src"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{FD0981FD-1055-4c31-93CE-DD7EF8377D29}"
+			>
+			<File
+				RelativePath="..\..\src\yake\loader\pch.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\..\src\yake\loader\yakeDotScene.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="inc"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{62C72BAD-1F45-4104-ACDC-A3CF4D7E9A3F}"
+			>
+			<File
+				RelativePath="..\..\yake\loader\loader.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\yake\loader\pch.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\yake\loader\prerequisites.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\yake\loader\yakeDotScene.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>

Added: trunk/yake/scripts/msvc8/model.vcproj
===================================================================
--- trunk/yake/scripts/msvc8/model.vcproj	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/scripts/msvc8/model.vcproj	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,284 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="model"
+	ProjectGUID="{6BB1D3EF-8836-4D23-BE24-340D310D9913}"
+	RootNamespace="yake"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../common/bin/$(ConfigurationName)"
+			IntermediateDirectory="../../common/obj/$(ConfigurationName)/$(ProjectName)"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../;../../dependencies;../../dependencies/boost;../../dependencies/ttl"
+				PreprocessorDefinitions="_STLP_DEBUG;WIN32;_DEBUG;_CONSOLE;YAKE_MODEL_EXPORTS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="yake/model/pch.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="base.lib physics.lib graphics.lib data.lib"
+				OutputFile="$(OutDir)/$(ProjectName).dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../common/lib/$(ConfigurationName);../../dependencies/lib"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
+				SubSystem="1"
+				ImportLibrary="../../common/lib/$(ConfigurationName)/$(ProjectName).lib"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../common/bin/$(ConfigurationName)"
+			IntermediateDirectory="../../common/obj/$(ConfigurationName)/$(ProjectName)"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../;../../dependencies;../../dependencies/boost;../../dependencies/ttl"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;YAKE_MODEL_EXPORTS"
+				RuntimeLibrary="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="yake/model/pch.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="base.lib physics.lib graphics.lib data.lib"
+				OutputFile="$(OutDir)/$(ProjectName).dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../common/lib/$(ConfigurationName);../../dependencies/lib"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="../../common/lib/$(ConfigurationName)/$(ProjectName).lib"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="src"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{AD0230C1-DFA5-4a98-A098-E87F6CFD8BD3}"
+			>
+			<File
+				RelativePath="..\..\src\yake\model\pch.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\..\src\yake\model\yakeComponentCreatorManager.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\yake\model\yakeGraphical.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\yake\model\yakeGraphicalCreator.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\yake\model\yakeGraphicalDotSceneLoader.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\yake\model\yakeModel.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\yake\model\yakeModelComponentContainer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\yake\model\yakeModelLinkContainer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\yake\model\yakeModelManager.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\yake\model\yakePhysical.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="inc"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{5A8F8C34-9894-44d8-8EF5-14379EB5AF7D}"
+			>
+			<File
+				RelativePath="..\..\yake\model\model.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\yake\model\model_component.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\yake\model\model_graphical_dotscene_loader.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\yake\model\model_link.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\yake\model\pch.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\yake\model\prerequisites.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>

Modified: trunk/yake/scripts/msvc8/plugins/graphics/graphicsOgre.vcproj
===================================================================
--- trunk/yake/scripts/msvc8/plugins/graphics/graphicsOgre.vcproj	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/scripts/msvc8/plugins/graphics/graphicsOgre.vcproj	2006-06-09 21:47:29 UTC (rev 1328)
@@ -284,6 +284,7 @@
 					>
 					<FileConfiguration
 						Name="Debug|Win32"
+						ExcludedFromBuild="true"
 						>
 						<Tool
 							Name="VCCLCompilerTool"

Added: trunk/yake/scripts/msvc8/samples/model/sampleDotScene.vcproj
===================================================================
--- trunk/yake/scripts/msvc8/samples/model/sampleDotScene.vcproj	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/scripts/msvc8/samples/model/sampleDotScene.vcproj	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,224 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="sampleModelDotScene"
+	ProjectGUID="{920E5CA3-620C-43C3-986C-5A6F9397F6DA}"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../../../common/bin/debug"
+			IntermediateDirectory="../../../../common/obj/debug/$(ProjectName)"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../../;../../../../dependencies/boost/;../../../../dependencies/ttl/"
+				PreprocessorDefinitions="_STLP_DEBUG;WIN32;_DEBUG;_CONSOLE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="yake/samples/model/dotScene/pch.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="base.lib graphics.lib physics.lib audio.lib data.lib input.lib yapp.lib scripting.lib"
+				OutputFile="$(OutDir)/$(ProjectName).exe"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../../common/lib/debug;../../../../dependencies/lib"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../../../common/bin/release"
+			IntermediateDirectory="../../../../common/obj/release/$(ProjectName)"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../../;../../../../dependencies/boost/;../../../../dependencies/ttl/"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				RuntimeLibrary="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="yake/samples/model/dotScene/pch.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="base.lib graphics.lib physics.lib audio.lib data.lib input.lib yapp.lib scripting.lib"
+				OutputFile="$(OutDir)/$(ProjectName).exe"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../../common/lib/release;../../../../dependencies/lib"
+				GenerateDebugInformation="false"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="inc"
+			>
+			<File
+				RelativePath="..\..\..\..\yake\samples\model\dotScene\pch.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="src"
+			>
+			<File
+				RelativePath="..\..\..\..\src\yake\samples\model\dotScene\demo.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\src\yake\samples\model\dotScene\pch.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>

Modified: trunk/yake/scripts/msvc8/yake.sln
===================================================================
--- trunk/yake/scripts/msvc8/yake.sln	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/scripts/msvc8/yake.sln	2006-06-09 21:47:29 UTC (rev 1328)
@@ -128,6 +128,12 @@
 		{2F5124AA-56BD-4909-811A-E79901978C86} = {2F5124AA-56BD-4909-811A-E79901978C86}
 	EndProjectSection
 EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "model", "model.vcproj", "{6BB1D3EF-8836-4D23-BE24-340D310D9913}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sampleModelDotScene", "samples\model\sampleDotScene.vcproj", "{920E5CA3-620C-43C3-986C-5A6F9397F6DA}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "loader", "loader.vcproj", "{2E5A589E-41FE-4BE9-80A0-1F8570944486}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Win32 = Debug|Win32
@@ -244,6 +250,18 @@
 		{6FC81A1C-0463-45EB-94F9-F7D084E3C169}.Debug|Win32.Build.0 = Debug|Win32
 		{6FC81A1C-0463-45EB-94F9-F7D084E3C169}.Release|Win32.ActiveCfg = Release|Win32
 		{6FC81A1C-0463-45EB-94F9-F7D084E3C169}.Release|Win32.Build.0 = Release|Win32
+		{6BB1D3EF-8836-4D23-BE24-340D310D9913}.Debug|Win32.ActiveCfg = Debug|Win32
+		{6BB1D3EF-8836-4D23-BE24-340D310D9913}.Debug|Win32.Build.0 = Debug|Win32
+		{6BB1D3EF-8836-4D23-BE24-340D310D9913}.Release|Win32.ActiveCfg = Release|Win32
+		{6BB1D3EF-8836-4D23-BE24-340D310D9913}.Release|Win32.Build.0 = Release|Win32
+		{920E5CA3-620C-43C3-986C-5A6F9397F6DA}.Debug|Win32.ActiveCfg = Debug|Win32
+		{920E5CA3-620C-43C3-986C-5A6F9397F6DA}.Debug|Win32.Build.0 = Debug|Win32
+		{920E5CA3-620C-43C3-986C-5A6F9397F6DA}.Release|Win32.ActiveCfg = Release|Win32
+		{920E5CA3-620C-43C3-986C-5A6F9397F6DA}.Release|Win32.Build.0 = Release|Win32
+		{2E5A589E-41FE-4BE9-80A0-1F8570944486}.Debug|Win32.ActiveCfg = Debug|Win32
+		{2E5A589E-41FE-4BE9-80A0-1F8570944486}.Debug|Win32.Build.0 = Debug|Win32
+		{2E5A589E-41FE-4BE9-80A0-1F8570944486}.Release|Win32.ActiveCfg = Release|Win32
+		{2E5A589E-41FE-4BE9-80A0-1F8570944486}.Release|Win32.Build.0 = Release|Win32
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE

Added: trunk/yake/src/yake/loader/pch.cpp
===================================================================
--- trunk/yake/src/yake/loader/pch.cpp	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/src/yake/loader/pch.cpp	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,27 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/loader/pch.h"

Added: trunk/yake/src/yake/loader/yakeDotScene.cpp
===================================================================
--- trunk/yake/src/yake/loader/yakeDotScene.cpp	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/src/yake/loader/yakeDotScene.cpp	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,416 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright  2004 The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+
+#include <yake/loader/pch.h>
+#include <yake/loader/loader.h>
+
+namespace yake {
+namespace data {
+namespace parser {
+namespace dotscene {
+
+	const String DotSceneParser::ROOT_NODE_NAME = "root_node";
+	
+	//------------------------------------------------------
+	void DotSceneParser::reset()
+	{
+		//FIXME state is more that just doc node
+		mDocNode.reset();
+	}
+
+	//------------------------------------------------------
+	bool DotSceneParser::load( const SharedPtr<dom::INode>& docNode )
+	{
+		YAKE_LOG( "DotSceneParser::load()" );
+		
+		YAKE_ASSERT( docNode.get() );
+		
+		if (!docNode.get())
+			return false;
+		
+		mDocNode = docNode;
+		
+		YAKE_LOG( "DotSceneParser: parsing scene..." );
+		
+		readScene( mDocNode );
+
+		return true;
+	}
+
+	//------------------------------------------------------
+	void DotSceneParser::readScene( const SharedPtr<dom::INode>& pNode )
+	{
+		//const String name = pNode->getAttributeValueAs<String>( "name" );
+		//YAKE_LOG( "DotSceneParser: readScene() [" + name + "]" );
+		
+		YAKE_ASSERT( pNode );
+		
+		SharedPtr<dom::INode> pNodes = pNode->getNodeByName("nodes");
+		YAKE_LOG( "DotSceneParser: scene: found nodes = " + String( pNodes.get() ? "yes" : "no" ) );
+		
+		if ( pNodes.get() )
+			readNodes( pNodes, _T("") );
+	}
+
+	//------------------------------------------------------
+	void DotSceneParser::readNodes( const SharedPtr<dom::INode>& pNodes, const String& path )
+	{
+		YAKE_LOG( "DotSceneParser: readNodes()" );
+		YAKE_ASSERT( pNodes );
+		
+		const dom::NodeList& nodes = pNodes->getNodes();
+		for( dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it )
+		{
+			readNode( (*it), ROOT_NODE_NAME, path );
+		}
+	}
+
+	String appendToPath(const String& path, const String& name)
+	{
+		return (path.empty() ? name : (path + _T("/") + name));
+	}
+	//------------------------------------------------------
+	void DotSceneParser::readNode( const SharedPtr<dom::INode>& pNode, const String& parentNodeName, const String& path )
+	{
+		String nodeName = pNode->getAttributeValueAs<String>( "name" );
+		
+		YAKE_LOG( "DotSceneParser: readNode() [name=" + nodeName + "]" );
+		YAKE_ASSERT( pNode );
+		
+		if ( nodeName.empty() )
+			nodeName = uniqueName::create( nodeName );
+		
+		NodeDesc currentSceneNode;
+		
+		currentSceneNode.name = nodeName;
+		currentSceneNode.parentNodeName = parentNodeName;
+		currentSceneNode.path = appendToPath(path, nodeName);
+		
+		// Implementing top-bottom parsing. So we have to read full info about the top-most node 
+		// and then descend to lower levels "root---->children". 
+		// That's why XML nodes for scene nodes should be saved at first. XML nodes for all entities, cameras,
+		// lights, etc. of the current scene node should also be saved and be parsed after the current node.
+		// Saved XML nodes for child scene nodes are parsed in the last turn.
+		dom::NodeList childNodes;
+		dom::NodeList attachedObjects; // for entities, cameras, lights, etc.
+		
+		const dom::NodeList& nodes = pNode->getNodes();
+		for ( dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it )
+		{
+			String tag = StringUtil::toLowerCase((*it)->getName());
+
+			const SharedPtr<dom::INode> & pChild = (*it);
+			if (tag == "position")
+			{
+				readPosition( pChild, currentSceneNode.transform.position );
+			}
+			else if (tag == "rotation")
+			{
+				readRotation( pChild, currentSceneNode.transform.rotation );
+			}
+			else if (tag == "scale")
+			{
+				readScale( pChild, currentSceneNode.transform.scale );
+			}
+			else if (tag == "node" )
+				childNodes.push_back( *it );
+			else if (	tag == "light" ||
+						tag == "entity" ||
+						tag == "camera" )
+				attachedObjects.push_back( *it );
+		}
+		
+		// Now firing signal as new node was parsed
+		mSigNode( currentSceneNode );
+		// And placing it to the map
+		mSNDescriptions[ nodeName ] = currentSceneNode;
+		
+		// Now it's time to read attached objects
+		for ( dom::NodeList::const_iterator it = attachedObjects.begin(); it != attachedObjects.end(); ++it )
+		{
+			String tag = StringUtil::toLowerCase((*it)->getName());
+
+			const SharedPtr<dom::INode>& pChild = (*it);
+			if ( tag == "entity" )
+			{
+				readEntity( pChild, nodeName, currentSceneNode.path );
+			}
+			else if ( tag == "camera" )
+			{
+				readCamera( pChild, nodeName, currentSceneNode.path );
+			}
+			else if ( tag == "light" )
+			{
+				readLight( pChild, nodeName, currentSceneNode.path );
+			}
+		}
+		
+		// Next, reading child scene nodes
+		// descending the node tree...
+		for ( dom::NodeList::const_iterator it = childNodes.begin(); it != childNodes.end(); ++it )
+		{
+		  readNode( *it, nodeName, currentSceneNode.path );
+		}
+	}
+
+	//------------------------------------------------------
+	void DotSceneParser::readEntity( const SharedPtr<dom::INode>& pNode, const String& parentNodeName, const String& path )
+	{
+		YAKE_ASSERT( pNode );
+		
+		EntityDesc desc;
+		
+		String name = (pNode->getAttributeValueAs<String>("name"));
+		
+		desc.name = name;
+		desc.parentNodeName = parentNodeName;
+		desc.path = appendToPath(path, name);
+		
+		YAKE_LOG( "DotSceneParser: readEntity() [name = " + name + "]" );
+		
+		desc.meshFile = pNode->getAttributeValueAs<String>( "meshFile" );
+		
+		String castsShadows = StringUtil::toLowerCase(pNode->getAttributeValueAs<String>("castsShadow"));
+		desc.castsShadows = castsShadows == "yes" || castsShadows == "true" || castsShadows == "1";
+
+		// Entity description ready. Fire!
+		mSigEntity( desc );
+		
+		// Storing...
+		mEntityDescriptions[ name ] = desc;
+	}
+	
+	//------------------------------------------------------
+	void DotSceneParser::readVector( const SharedPtr<dom::INode>& pNode, math::Vector3& rVec )
+	{
+		YAKE_ASSERT( pNode );
+		rVec.x = StringUtil::parseReal( pNode->getAttributeValueAs<String>("x") );
+		rVec.y = StringUtil::parseReal( pNode->getAttributeValueAs<String>("y") );
+		rVec.z = StringUtil::parseReal( pNode->getAttributeValueAs<String>("z") );
+	}
+
+	//------------------------------------------------------
+	void DotSceneParser::readPosition( const SharedPtr<dom::INode> & pNode, math::Vector3 & position )
+	{
+		readVector( pNode, position );
+	}
+
+	//------------------------------------------------------
+	void DotSceneParser::readScale( const SharedPtr<dom::INode>& pNode, math::Vector3& rScale )
+	{
+		readVector( pNode, rScale );
+	}
+	
+	//------------------------------------------------------
+	void DotSceneParser::readRotation( const SharedPtr<dom::INode>& pNode, math::Quaternion& rotation )
+	{
+		YAKE_ASSERT( pNode );
+		if ( pNode->getAttributeValueAs<String>("qx") != "" )
+		{
+			rotation.x = StringUtil::parseReal( pNode->getAttributeValueAs<String>("qx") );
+			rotation.y = StringUtil::parseReal( pNode->getAttributeValueAs<String>("qy") );
+			rotation.z = StringUtil::parseReal( pNode->getAttributeValueAs<String>("qz") );
+			rotation.w = StringUtil::parseReal( pNode->getAttributeValueAs<String>("qw") );
+		}
+		else if ( pNode->getAttributeValueAs<String>("axisX") != "" )
+		{
+			math::Vector3 axis;
+			axis.x = StringUtil::parseReal( pNode->getAttributeValueAs<String>("axisX") );
+			axis.y = StringUtil::parseReal( pNode->getAttributeValueAs<String>("axisY") );
+			axis.z = StringUtil::parseReal( pNode->getAttributeValueAs<String>("axisZ") );
+			rotation.FromAxes( &axis );
+		}
+		else if ( pNode->getAttributeValueAs<String>("angleX") != "" )
+		{
+			math::Vector3 axis;
+			axis.x = StringUtil::parseReal( pNode->getAttributeValueAs<String>("angleX") );
+			axis.y = StringUtil::parseReal( pNode->getAttributeValueAs<String>("angleY") );
+			axis.z = StringUtil::parseReal( pNode->getAttributeValueAs<String>("angleZ") );
+			real angle = StringUtil::parseReal( pNode->getAttributeValueAs<String>("angle") );
+			rotation.FromAngleAxis( angle, axis );
+		}
+	}
+	//------------------------------------------------------
+	void DotSceneParser::readColour( const SharedPtr<dom::INode>& pNode, math::Color& colour )
+	{
+		YAKE_ASSERT( pNode );
+		
+		String r = pNode->getAttributeValueAs<String>("r");
+		String g = pNode->getAttributeValueAs<String>("g");
+		String b = pNode->getAttributeValueAs<String>("b");
+		
+		//YAKE_LOG( "DotSceneParser: readColour: r=" + r + ", g=" + g + ", b=" + b );
+		
+		colour.r = StringUtil::parseReal( r );
+		colour.g = StringUtil::parseReal( g );
+		colour.b = StringUtil::parseReal( b );
+	}
+
+	//------------------------------------------------------
+	void DotSceneParser::readLightRange( const SharedPtr<dom::INode>& pNode, LightDesc& desc )
+	{
+		YAKE_ASSERT( pNode );
+		
+		desc.range.inner = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "inner" ) );
+		desc.range.outer = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "outer" ) );
+		desc.range.falloff = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "falloff" ) );
+	}
+
+	//------------------------------------------------------
+	void DotSceneParser::readLightAttenuation( const SharedPtr<dom::INode>& pNode, LightDesc& desc )
+	{
+		YAKE_ASSERT( pNode );
+		
+		desc.attenuation.range = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "range" ) );
+		desc.attenuation.constant = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "constant" ) );
+		desc.attenuation.linear = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "linear" ) );
+		desc.attenuation.quadratic = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "quadratic" ) );
+	}
+	
+	//------------------------------------------------------
+	void DotSceneParser::readLight( const SharedPtr<dom::INode>& pNode, const String& parentNodeName, const String& path )
+	{
+		String name = pNode->getAttributeValueAs<String>( "name" );
+
+		LightDesc desc;
+		
+		desc.name = name;
+		desc.parentNodeName = parentNodeName;
+		desc.path = appendToPath(path, name);
+		
+		YAKE_LOG( "DotSceneParser: readLight() [name=" + name + "]" );
+		YAKE_ASSERT( pNode );
+		
+		String lightType = pNode->getAttributeValueAs<String>( "type" );
+		String castsShadows = pNode->getAttributeValueAs<String>( "castShadows" );
+		desc.castsShadows = castsShadows == "yes" || castsShadows == "true" || castsShadows == "1";
+				
+		desc.type = graphics::ILight::LT_POINT;
+		
+		if ( lightType == "spot" )
+			desc.type = graphics::ILight::LT_SPOT;
+		else if ( lightType == "directional" )
+			desc.type = graphics::ILight::LT_DIRECTIONAL;
+		
+		const dom::NodeList& nodes = pNode->getNodes();
+		for ( dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it )
+		{
+			String childNodeName = (*it)->getName();
+			
+			//YAKE_LOG( "DotSceneParser: node child: " + StringUtil::toLowerCase( childNodeName ) );
+
+			const SharedPtr<dom::INode>& pChild = *it;
+			
+			if ( childNodeName == "normal" )
+				readVector( pChild, desc.normal );
+			else if ( childNodeName == "colourDiffuse" )
+				readColour( pChild, desc.diffuseColor );
+			else if ( childNodeName == "colourSpecular" )
+				readColour( pChild, desc.specularColor );
+			else if ( childNodeName == "lightRange" )
+				readLightRange( pChild, desc );
+			else if ( childNodeName == "lightAttenuation" )
+				readLightAttenuation( pChild, desc );
+			else
+				YAKE_LOG_ERROR(String("DotSceneParser: Unhandled node child '") + childNodeName + _T("'"));
+		}
+		
+		// Light description ready. Fire!
+		mSigLight( desc );
+		
+		// Store
+		mLightDescriptions[ name ] = desc;
+	}
+	
+	//------------------------------------------------------
+	void DotSceneParser::readCameraClipping( const SharedPtr<dom::INode>& pNode, CameraDesc& desc )
+	{
+		YAKE_ASSERT( pNode );
+		
+		desc.clipping.nearClip = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "near" ) );
+		desc.clipping.farClip = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "far" ) );
+	}
+	
+	//------------------------------------------------------
+	void DotSceneParser::readCamera( const SharedPtr<dom::INode>& pNode, const String& parentNodeName, const String& path )
+	{
+		String name = pNode->getAttributeValueAs<String>( "name" );
+
+		CameraDesc desc;
+		
+		desc.name = name;
+		desc.parentNodeName = parentNodeName;
+		desc.path = appendToPath(path, name);
+		
+		YAKE_LOG( "DotSceneParser: readCamera() [name=" + name + "]" );
+		YAKE_ASSERT( pNode );
+		
+		String projectionType = pNode->getAttributeValueAs<String>( "projectionType" );
+				
+		desc.projectionType = graphics::ICamera::PT_PERSPECTIVE;
+		
+		if ( projectionType == "orthographic" )
+			desc.projectionType = graphics::ICamera::PT_ORTHOGRAPHIC;
+		
+		desc.fov = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "fov" ) );
+		
+		// Reading aspect ratio
+		String aspectRatio = pNode->getAttributeValueAs<String>( "aspectRatio" );
+		// default value is 1.333 ( 640/480, 800/600, etc... )
+		desc.aspectRatio =
+				aspectRatio == "" ? 1.333 : StringUtil::parseReal( aspectRatio );
+		
+		const dom::NodeList& nodes = pNode->getNodes();
+		for ( dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it )
+		{
+			String childNodeName = (*it)->getName();
+			
+			//YAKE_LOG( "DotSceneParser: node child: " + StringUtil::toLowerCase( childNodeName ) );
+
+			const SharedPtr<dom::INode>& pChild = *it;
+			
+			if ( childNodeName == "normal" )
+				readVector( pChild, desc.normal );
+			else if ( childNodeName == "clipping" )
+				readCameraClipping( pChild, desc );
+			else if ( childNodeName == "trackTarget" )
+				desc.trackTargetName = pChild->getAttributeValueAs<String>( "nodeName" );
+			else
+				YAKE_LOG_ERROR(String("DotSceneParser: Unhandled node child '") + childNodeName + _T("'"));
+		}
+		
+		// Camera description ready. Fire!
+		mSigCamera( desc );
+		
+		// Store
+		mCameraDescriptions[ name ] = desc;
+	}
+
+} // dotscene
+} // parser
+} // data
+} // yake

Added: trunk/yake/src/yake/model/pch.cpp
===================================================================
--- trunk/yake/src/yake/model/pch.cpp	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/src/yake/model/pch.cpp	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,27 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"

Added: trunk/yake/src/yake/model/yakeComponentCreatorManager.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeComponentCreatorManager.cpp	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/src/yake/model/yakeComponentCreatorManager.cpp	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,78 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"
+#include "yake/model/prerequisites.h"
+#include "yake/model/model.h"
+
+namespace yake {
+namespace model {
+
+	YAKE_IMPLEMENT_REGISTRY(ComponentCreator)
+
+	ComponentCreatorManager::ComponentCreatorManager()
+	{
+	}
+	ComponentCreatorManager::~ComponentCreatorManager()
+	{
+	}
+	ModelComponent* ComponentCreatorManager::create(const String& type, const ComponentCreationContext& ctx, const StringMap& params)
+	{
+		YAKE_ASSERT( !type.empty() )(type)(params).debug("Invalid type!");
+		if (type.empty())
+			return 0;
+
+		ComponentCreator* theCreator = 0;
+		{
+			TypeCreatorMap::const_iterator it = creators_.find( type );
+			if (it == creators_.end())
+			{
+				SharedPtr<ComponentCreator> creator;
+				try {
+					creator = templates::create<ComponentCreator>( type );
+				}
+				catch (...)
+				{
+					YAKE_LOG_ERROR("Unregistered ComponentCreator type!");
+				}
+				YAKE_ASSERT( creator.get() )(type)(params).debug("Failed to create component creator! Probably it has not been registered/loaded.");
+				if (!creator.get())
+					return 0;
+				creators_.insert( std::make_pair(type,creator) );
+				theCreator = creator.get();
+			}
+			else
+				theCreator = it->second.get();
+		}
+		YAKE_ASSERT( theCreator );
+		ModelComponent* c = theCreator->create(ctx,params);
+		YAKE_ASSERT( c )(type)(params).debug("Failed to create component!");
+
+		return c;
+	}
+
+} // namespace model
+} // namespace yake

Added: trunk/yake/src/yake/model/yakeGraphical.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeGraphical.cpp	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/src/yake/model/yakeGraphical.cpp	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,118 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"
+#include "yake/model/prerequisites.h"
+#include "yake/model/model.h"
+
+namespace yake {
+namespace model {
+
+	Graphical::Graphical()
+	{
+	}
+	Graphical::~Graphical()
+	{
+		/*
+		for (TagNodeMap::iterator itN = nodes_.begin(); itN != nodes_.end(); ++itN)
+		{
+			if (itN->second.owned_)
+				delete itN->second.p_;
+		}
+
+		for (TagEntityMap::iterator itE = entities_.begin(); itE != entities_.end(); ++itE)
+		{
+			if (itE->second.owned_)
+				delete itE->second.p_;
+		}
+
+		for (TagLightMap::iterator itL = lights_.begin(); itL != lights_.end(); ++itL)
+		{
+			if (itL->second.owned_)
+				delete itL->second.p_;
+		}
+		*/
+	}
+	/*
+	ModelComponent* Graphical::clone() const
+	{
+		Graphical* cloned = new Graphical();
+
+		// nodes
+		ConstVectorIterator<TagNodeMap> itN( nodes_ );
+		while (itN.hasMoreElements())
+		{
+			const TagNodeMap::value_type& vt = itN.getNextRef();
+			graphics::ISceneNode* clonedNode = vt.second->deepClone();
+			cloned->addSceneNode( clonedNode, vt.first );
+		}
+
+		//@todo lights etc
+
+		return cloned;
+	}
+	*/
+	void Graphical::addSceneNode(graphics::ISceneNode* node, const String& xpath, const bool owned)
+	{
+		YAKE_LOG(String("Graphical::addSceneNode(") + xpath + _T(")"));
+		this->_add(node,nodes_,xpath,owned);
+	}
+	void Graphical::addEntity(graphics::IEntity* ent, const String& xpath, const bool owned)
+	{
+		YAKE_LOG(String("Graphical::addEntity(") + xpath + _T(")"));
+		this->_add(ent,entities_,xpath,owned);
+	}
+	void Graphical::addLight(graphics::ILight* light, const String& xpath, const bool owned)
+	{
+		YAKE_LOG(String("Graphical::addLight(") + xpath + _T(")"));
+		this->_add(light,lights_,xpath,owned);
+	}
+	graphics::ISceneNode* Graphical::getSceneNode(const String& xpath) const
+	{
+		return this->_get(nodes_,xpath);
+	}
+	graphics::IEntity* Graphical::getEntity(const String& xpath) const
+	{
+		return this->_get(entities_,xpath);
+	}
+	graphics::ILight* Graphical::getLight(const String& xpath) const
+	{
+		return this->_get(lights_,xpath);
+	}
+	void Graphical::translate(const Vector3& d)
+	{
+		ConstVectorIterator<TagNodeMap> itN( nodes_ );
+		while (itN.hasMoreElements())
+		{
+			const TagNodeMap::value_type& vt = itN.getNextRef();
+			//if (vt.second.owned_)
+			if (!vt.second.p_->getParent())
+				vt.second.p_->translate( d );
+		}
+	}
+
+} // namespace model
+} // namespace yake

Added: trunk/yake/src/yake/model/yakeGraphicalCreator.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeGraphicalCreator.cpp	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/src/yake/model/yakeGraphicalCreator.cpp	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,88 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"
+#include "yake/model/prerequisites.h"
+#include "yake/model/model.h"
+#include "yake/model/model_graphical_dotscene_loader.h"
+
+namespace yake {
+namespace model {
+
+	YAKE_REGISTER_CONCRETE(GraphicalFromDotSceneCreator)
+
+	ModelComponent* GraphicalFromDotSceneCreator::create(const ComponentCreationContext& ctx, const StringMap& params)
+	{
+		// Verify validity of creation context
+		graphics::IWorld* pGWorld = ctx.gworld_;
+		YAKE_ASSERT( pGWorld );
+		if (!pGWorld)
+			return 0;
+
+		// Extract parameters
+
+		StringMap::const_iterator itParam = params.find("file");
+		YAKE_ASSERT(itParam != params.end()).debug("Missing parameter 'file'.");
+		if (itParam == params.end())
+			return 0;
+		const String fn = itParam->second;
+
+		itParam = params.find("name");
+		YAKE_ASSERT(itParam != params.end()).debug("Missing parameter 'name'.");
+		if (itParam == params.end())
+			return 0;
+		const String name = itParam->second;
+
+		// Read dotscene file into DOM
+
+		yake::data::dom::xml::XmlSerializer ser;
+		ser.parse( fn, false );
+		YAKE_ASSERT( ser.getDocumentNode() )( fn ).error("Could not parse dotScene document!");
+
+		// Parse DOM and create graphical objects
+
+		yake::data::parser::dotscene::DotSceneParserV1 dsp;
+
+		Graphical* pGraphical = new Graphical();
+
+		DotSceneListener dotSceneListener( *pGraphical, name.empty() ? _T("") : (name + _T("/")) );
+		dotSceneListener.reset( pGWorld );
+
+		dsp.subscribeToNodeSignal( Bind1( &DotSceneListener::processSceneNode, &dotSceneListener ) );
+		dsp.subscribeToEntitySignal( Bind1( &DotSceneListener::processEntity, &dotSceneListener ) );
+		dsp.subscribeToCameraSignal( Bind1( &DotSceneListener::processCamera, &dotSceneListener ) );
+		dsp.subscribeToLightSignal( Bind1( &DotSceneListener::processLight, &dotSceneListener ) );
+
+		if (!dsp.load( ser.getDocumentNode() ))
+		{
+			YAKE_SAFE_DELETE( pGraphical );
+		}
+
+		return pGraphical;
+	}
+
+} // namespace model
+} // namespace yake

Added: trunk/yake/src/yake/model/yakeGraphicalDotSceneLoader.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeGraphicalDotSceneLoader.cpp	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/src/yake/model/yakeGraphicalDotSceneLoader.cpp	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,231 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"
+#include "yake/model/prerequisites.h"
+#include "yake/model/model.h"
+#include "yake/model/model_graphical_dotscene_loader.h"
+
+namespace yake {
+namespace model {
+
+	//-----------------------------------------------------
+	void DotSceneListener::processSceneNode( const SceneNodeDesc& desc )
+	{
+		const String fullName = mNamePrefix + desc.path;
+		const String fullParentNodeName = mNamePrefix + desc.parentNodeName;
+		YAKE_LOG( "Processing scene node " + desc.name + " (" + fullName + ") with parent node " + desc.parentNodeName + " (" + fullParentNodeName + ")" );
+
+		// create scene node
+		graphics::ISceneNode* pSN = mGWorld->createSceneNode( fullName );
+
+		// add to parent node (if necessary)
+		graphics::ISceneNode* parentSN = 0;
+		if ( desc.parentNodeName != yake::data::parser::dotscene::DotSceneParserV1::ROOT_NODE_NAME )
+		{
+			parentSN = mSceneNodes[ desc.parentNodeName ];
+			parentSN->addChildNode( pSN );
+		}
+
+		// set properties
+		pSN->setName( fullName );
+		pSN->setPosition( desc.transform.position );
+		pSN->setOrientation( desc.transform.rotation );
+		pSN->setScale( desc.transform.scale );
+
+		mSceneNodes[ desc.name ] = pSN;
+
+		// Register with Model object
+		mOwner.addSceneNode( pSN, desc.path, parentSN ? false : true );
+
+		// look if this node is tracked
+		// TODO current scheme allows node to be tracked by only one target
+		TrackerMap::iterator end = mTrackersTargets.end();
+		for( TrackerMap::iterator trackRecord = mTrackersTargets.begin(); trackRecord != end; ++trackRecord )
+		{
+			if ( trackRecord->second == desc.name )
+			{
+				YAKE_LOG( "Setting track target for camera " + trackRecord->first + " ..." );
+
+				CameraInfo info = mCameras[ trackRecord->first ];
+
+				YAKE_LOG( "Camera info found. Acquiring camera..." );
+
+				graphics::ICamera* tracker = info.camera;
+
+				YAKE_LOG( "Got camera. Setting orientation..." );
+
+				tracker->lookAt( pSN->getPosition( graphics::ISceneNode::TS_WORLD ) );
+
+				YAKE_LOG( "Orientation was set up..." );
+
+				// cleaning up
+				mTrackersTargets.erase( trackRecord );
+				break;
+			}
+		}
+	}
+
+	//-----------------------------------------------------
+	void DotSceneListener::processEntity( const EntityDesc& desc )
+	{
+		const String fullName = mNamePrefix + desc.name;
+		const String fullParentNodeName = mNamePrefix + desc.parentNodeName;
+		YAKE_LOG( "Processing entity " + desc.name + " (" + fullName + ") with parent node " + desc.parentNodeName + " (" + fullParentNodeName + ")" );
+
+		// create entity
+		graphics::IEntity* pEntity = mGWorld->createEntity( desc.meshFile );
+		YAKE_ASSERT( pEntity );
+
+		// lookup scene node
+		bool parented = false;
+		if ( desc.parentNodeName != yake::data::parser::dotscene::DotSceneParserV1::ROOT_NODE_NAME )
+		{
+			graphics::ISceneNode* parentSN = mSceneNodes[ desc.parentNodeName ];
+			YAKE_ASSERT( parentSN );
+			parentSN->attachEntity( pEntity );
+			parented = true;
+		}
+
+		// configure entity
+		pEntity->setCastsShadow( desc.castsShadows );
+
+		// Register with Model object
+		mOwner.addEntity( pEntity, desc.path, !parented );
+
+		// store entity meta info
+		EntityInfo info;
+
+		info.entity = pEntity;
+		info.parentSceneNode = desc.parentNodeName;
+
+		mEntities[ desc.name ] = info;
+	}
+
+	//-----------------------------------------------------
+	void DotSceneListener::processCamera( const CameraDesc& desc )
+	{
+		YAKE_LOG( "Processing camera " + desc.name + " with parent node " + desc.parentNodeName );
+
+		graphics::ICamera* pCamera = mGWorld->createCamera();
+
+		if ( desc.parentNodeName != yake::data::parser::dotscene::DotSceneParserV1::ROOT_NODE_NAME )
+		{
+			graphics::ISceneNode* parentSN = mSceneNodes[ desc.parentNodeName ];
+
+			parentSN->attachCamera( pCamera );
+		}
+
+		pCamera->setName( desc.name );
+		pCamera->setFOV( Math::DegreesToRadians( desc.fov ) );
+		pCamera->setAspectRatio( desc.aspectRatio );
+		pCamera->setProjectionType( desc.projectionType );
+		pCamera->setNearClipDistance( desc.clipping.nearClip );
+		pCamera->setFarClipDistance( desc.clipping.farClip );
+
+		//	pCamera->setDirection( desc.normal );
+
+		pCamera->setPosition( Vector3() );
+		pCamera->setOrientation( Quaternion::kIdentity );
+
+
+		if ( desc.trackTargetName != "" )
+		{
+			YAKE_LOG( "Saving tracking record for camera " + desc.name + " ... " );
+
+			mTrackersTargets.insert( TrackerMap::value_type( desc.name, desc.trackTargetName ) );
+		}
+
+		CameraInfo info;
+
+		info.camera = pCamera;
+		info.parentSceneNode = desc.parentNodeName;
+
+		mCameras[ desc.name ] = info;
+	}
+
+	//-----------------------------------------------------
+	void DotSceneListener::processLight( const LightDesc& desc )
+	{
+		const String fullName = mNamePrefix + desc.name;
+		const String fullParentNodeName = mNamePrefix + desc.parentNodeName;
+		YAKE_LOG( "Processing light " + desc.name + " (" + fullName + ") with parent node " + desc.parentNodeName + " (" + fullParentNodeName + ")" );
+
+		// create light
+		graphics::ILight* pLight = mGWorld->createLight();
+
+		// lookup parent scene node
+		bool parented = false;
+		if ( desc.parentNodeName != yake::data::parser::dotscene::DotSceneParserV1::ROOT_NODE_NAME )
+		{
+			graphics::ISceneNode* parentSN = mSceneNodes[ desc.parentNodeName ];
+			YAKE_ASSERT( parentSN );
+
+			parentSN->attachLight( pLight );
+			parented = true;
+		}
+
+		// register with Model
+		mOwner.addLight( pLight, desc.path, !parented );
+
+		// configure light
+		pLight->setName( desc.name );
+		pLight->setType( desc.type );
+		pLight->setCastsShadows( desc.castsShadows );
+
+		if ( desc.castsShadows )
+		{
+			YAKE_LOG( "  light casts shadows" );
+		}
+		else
+		{
+			YAKE_LOG( "  light doesn't cast shadows" );
+		}
+
+		pLight->setDiffuseColour( desc.diffuseColor );
+		pLight->setSpecularColour( desc.specularColor );
+		pLight->setAttenuation( desc.attenuation.range,
+			desc.attenuation.constant,
+			desc.attenuation.linear,
+			desc.attenuation.quadratic );
+
+		if ( desc.type == graphics::ILight::LT_SPOT )
+			pLight->setSpotlightRange( desc.range.inner, desc.range.outer, desc.range.falloff );
+
+		if ( desc.type != graphics::ILight::LT_POINT )
+			pLight->setDirection( desc.normal );
+
+		// store light meta info
+		LightInfo info;
+
+		info.light = pLight;
+		info.parentSceneNode = desc.parentNodeName;
+
+		mLights[ desc.name ] = info;
+	}
+
+} // namespace model
+} // namespace yake

Added: trunk/yake/src/yake/model/yakeModel.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeModel.cpp	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/src/yake/model/yakeModel.cpp	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,69 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"
+#include "yake/model/prerequisites.h"
+#include "yake/model/model.h"
+
+namespace yake {
+namespace model {
+
+	Model::Model() : name_(_T("")), internalName_(uniqueName::create(_T("yake.model_")))
+	{}
+	void Model::setName(const String& name)
+	{
+		name_ = name;
+	}
+	const String& Model::getName() const
+	{
+		return name_; 
+	}
+	void Model::addComponent(ModelComponent* c, const ComponentTag& tag)
+	{
+		components_.addComponent(c,tag);
+	}
+	ModelComponent* Model::getComponentByTag(const ComponentTag& tag) const
+	{
+		return components_.getComponentByTag(tag);
+	}
+	/*
+	Model* Model::clone() const
+	{
+		Model* cloned = new Model();
+		YAKE_ASSERT( cloned );
+
+		// clone name
+		cloned->name_ = name_ + "_copy";
+
+		// clone components
+		ModelComponentContainer::_cloneComponents(*cloned);
+
+		return cloned;
+	}
+	*/
+
+} // namespace model
+} // namespace yake

Added: trunk/yake/src/yake/model/yakeModelComponentContainer.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeModelComponentContainer.cpp	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/src/yake/model/yakeModelComponentContainer.cpp	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,108 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"
+#include "yake/model/prerequisites.h"
+#include "yake/model/model.h"
+
+namespace yake {
+namespace model {
+	bool operator==(const SharedPtr<ModelComponent>& lhs, const ModelComponent* rhs)
+	{
+		return (lhs.get() == rhs);
+	}
+	ModelComponentContainer::ModelComponentContainer()
+	{
+	}
+	/*
+	void ModelComponentContainer::_cloneComponents(Model& cloned) const
+	{
+		// clone components
+		typedef std::map<const ModelComponent*,SharedPtr<ModelComponent> > ClonedMap;
+		ClonedMap clonedMap;
+
+		ConstVectorIterator<ModelComponentList> itC(components_);
+		while (itC.hasMoreElements())
+		{
+			const ModelComponent* comp = itC.getNext().get();
+			SharedPtr<ModelComponent> clonedComp( comp->clone() );
+			clonedMap[ comp ] = clonedComp;
+			cloned.components_.push_back( clonedComp );
+		}
+
+		// clone tags
+		ConstVectorIterator<TagModelComponentMap> itCM(tag2components_);
+		while (itCM.hasMoreElements())
+		{
+			const TagModelComponentMap::value_type& cm = itCM.getNext();
+			ClonedMap::const_iterator it = clonedMap.find( cm.second.get() );
+			if (it != clonedMap.end())
+				cloned.tag2components_[ cm.first ] = it->second;
+		}
+	}
+	*/
+	void ModelComponentContainer::addComponent(ModelComponent* c)
+	{
+		YAKE_ASSERT( c );
+#ifdef YAKE_DEBUG_BUILD
+		YAKE_ASSERT( components_.end() == std::find(components_.begin(),components_.end(),c) );
+#endif
+		components_.push_back( SharedPtr<ModelComponent>(c) );
+	}
+	void ModelComponentContainer::addComponent(ModelComponent* c, const ComponentTag& tag)
+	{
+		YAKE_ASSERT( c );
+		YAKE_ASSERT( !tag.empty() )(tag);
+
+		SharedPtr<ModelComponent> ptr(c);
+		components_.push_back( ptr );
+#ifdef YAKE_DEBUG_BUILD
+		YAKE_ASSERT( tag2components_.end() == tag2components_.find(tag) );
+#endif
+		tag2components_[ tag ] = ptr;
+	}
+	ModelComponent* ModelComponentContainer::getComponentByTag(const ComponentTag& tag) const
+	{
+		TagModelComponentMap::const_iterator it = tag2components_.find(tag);
+		return ((it == tag2components_.end()) ? 0 : it->second.get());
+	}
+	ModelComponent* ModelComponentContainer::getComponentByIndex(const size_t idx) const
+	{
+		YAKE_ASSERT( !this->empty() );
+		YAKE_ASSERT( idx < components_.size() );
+		return components_[ idx ].get();
+	}
+	size_t ModelComponentContainer::numComponents() const
+	{
+		return components_.size();
+	}
+	bool ModelComponentContainer::empty() const
+	{
+		return components_.empty();
+	}
+
+} // namespace model
+} // namespace yake

Added: trunk/yake/src/yake/model/yakeModelLinkContainer.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeModelLinkContainer.cpp	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/src/yake/model/yakeModelLinkContainer.cpp	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,52 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"
+#include "yake/model/prerequisites.h"
+#include "yake/model/model.h"
+
+namespace yake {
+namespace model {
+
+	ModelLinkContainer::ModelLinkContainer()
+	{
+	}
+	ModelLinkContainer::~ModelLinkContainer()
+	{
+		this->destroyAllModelLinks();
+	}
+	void ModelLinkContainer::destroyAllModelLinks()
+	{
+	}
+	void ModelLinkContainer::addModelLink(ModelLink*)
+	{
+	}
+	void ModelLinkContainer::removeModelLink(ModelLink*)
+	{
+	}
+
+} // namespace model
+} // namespace yake

Added: trunk/yake/src/yake/model/yakeModelManager.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeModelManager.cpp	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/src/yake/model/yakeModelManager.cpp	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,98 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"
+#include "yake/model/prerequisites.h"
+#include "yake/model/model.h"
+
+namespace yake {
+namespace model {
+
+	ModelManager::ModelManager()
+	{
+	}
+	ModelManager::~ModelManager()
+	{
+	}
+	namespace detail {
+		void extractParams(const String& params, StringMap& out)
+		{
+			StringVector singles = split<String>(params,";");
+			ConstVectorIterator<StringVector> it( singles );
+			while (it.hasMoreElements())
+			{
+				const String s = it.getNext();
+				StringVector keyValuePair = split<String>( s, "=" );
+				out[ keyValuePair.front() ] = (keyValuePair.size() == 1) ? "" : keyValuePair.back();
+			}
+		}
+	} // namespace detail
+	/// graphics/dotScene:name=gfx;file=bla.scene|physics/dotXODE...
+	Model* ModelManager::createModel(const String& def)
+	{
+		Vector<String> defComponents = split<String>(def, "|");
+		YAKE_ASSERT(!defComponents.empty());
+		if (defComponents.empty())
+			return 0;
+		Model* m = new Model();
+		models_.push_back( SharedPtr<Model>(m) );
+		ConstVectorIterator<Vector<String> > itDef( defComponents );
+		while (itDef.hasMoreElements())
+		{
+			const String& defC = itDef.getNextRef();
+
+			// Split e.g. "gfx=graphics/dotScene:file=blah.scene" into "gfx" and "file=graphics/dotScene:blah.scene"
+			Vector<String> defTypeRest = split<String>( defC, ":" );
+			YAKE_ASSERT( defTypeRest.size() == 2 );
+
+			const String type = defTypeRest.front(); // e.g. "graphics/dotScene"
+
+			StringMap params;
+			detail::extractParams( defTypeRest.back(), params );
+
+			StringMap::const_iterator itParam = params.find("name");
+			YAKE_ASSERT( itParam != params.end() ).debug("No property 'name' for component!");
+			if (itParam == params.end())
+				continue;
+			const String name = itParam->second;
+
+			YAKE_ASSERT( m->getComponentByTag(name) == 0 ).debug("Components with duplicate tags are not allowed within the same model!");
+
+			m->addComponent( creatorMgr_.create( type, ctx_, params ), name );
+		}
+		return m;
+	}
+	void ModelManager::setCreationContext_GraphicalWorld(graphics::IWorld* w)
+	{
+		ctx_.gworld_ = w;
+	}
+	void ModelManager::setCreationContext_PhysicalWorld(physics::IWorld* w)
+	{
+		ctx_.pworld_ = w;
+	}
+
+} // namespace model
+} // namespace yake

Added: trunk/yake/src/yake/model/yakePhysical.cpp
===================================================================
--- trunk/yake/src/yake/model/yakePhysical.cpp	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/src/yake/model/yakePhysical.cpp	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,79 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"
+#include "yake/model/prerequisites.h"
+#include "yake/model/model.h"
+
+namespace yake {
+namespace model {
+
+	Physical::Physical()
+	{
+	}
+	Physical::~Physical()
+	{
+		for (TagActorMap::iterator itA = actors_.begin(); itA != actors_.end(); ++itA)
+		{
+			physics::IActor* obj = itA->second.p_;
+			obj->getCreator()->destroyActor(obj);
+		}
+		for (TagJointMap::iterator itJ = joints_.begin(); itJ != joints_.end(); ++itJ)
+		{
+			physics::IJoint* obj = itJ->second.p_;
+			obj->getCreator()->destroyJoint(obj);
+		}
+	}
+	void Physical::addActor(physics::IActor* actor, const String& xpath)
+	{
+		YAKE_LOG(String("Physical::addActor(") + xpath + _T(")"));
+		this->_add<physics::IActor>(actor,actors_,xpath);
+	}
+	void Physical::addJoint(physics::IJoint* joint, const String& xpath)
+	{
+		YAKE_LOG(String("Physical::addJoint(") + xpath + _T(")"));
+		this->_add<physics::IJoint>(joint,joints_,xpath);
+	}
+	void Physical::addBody(physics::IBody* body, const String& xpath)
+	{
+		YAKE_LOG(String("Physical::addBody(") + xpath + _T(")"));
+		this->_add<physics::IBody>(body,bodies_,xpath);
+	}
+	physics::IActor* Physical::getActor(const yake::String& xpath) const
+	{
+		return this->_get(actors_,xpath);
+	}
+	physics::IJoint* Physical::getJoint(const yake::String& xpath) const
+	{
+		return this->_get(joints_,xpath);
+	}
+	physics::IBody* Physical::getBody(const yake::String& xpath) const
+	{
+		return this->_get(bodies_,xpath);
+	}
+
+} // namespace model
+} // namespace yake

Modified: trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreNode.cpp
===================================================================
--- trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreNode.cpp	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/src/yake/plugins/graphicsOgre/graphicsOgreNode.cpp	2006-06-09 21:47:29 UTC (rev 1328)
@@ -280,9 +280,12 @@
 		try {
 			mSceneNode->getAttachedObject( pCam->getCamera_()->getName() );
 		}
-		catch (...)
+		catch (Ogre::Exception& e)
 		{
-			mSceneNode->attachObject( pCam->getCamera_() );
+			if (e.getNumber() == Ogre::Exception::ERR_ITEM_NOT_FOUND)
+				mSceneNode->attachObject( pCam->getCamera_() );
+			else
+				YAKE_LOG(String("Ogre Exception: ") + e.getFullDescription());
 		}
 		mCameras.push_back( pCamera );
 	}
@@ -300,8 +303,12 @@
 		try {
 			mSceneNode->getAttachedObject( pL->getLight_()->getName() );
 		}
-		catch (...)
+		catch (Ogre::Exception& e)
 		{
+			if (e.getNumber() != Ogre::Exception::ERR_ITEM_NOT_FOUND)
+			{
+				YAKE_EXCEPT(String("Caught OGRE exception: ") + e.getFullDescription().c_str());
+			}
 			mSceneNode->attachObject( pL->getLight_() );
 		}
 		mLights.push_back( pLight );
@@ -320,9 +327,12 @@
 		try {
 			mSceneNode->getAttachedObject( pE->getEntity_()->getName() );
 		}
-		catch (...)
+		catch (Ogre::Exception& e)
 		{
-			mSceneNode->attachObject( pE->getEntity_() );
+			if (e.getNumber() == Ogre::Exception::ERR_ITEM_NOT_FOUND)
+				mSceneNode->attachObject( pE->getEntity_() );
+			else
+				YAKE_LOG(String("Ogre Exception: ") + e.getFullDescription());
 		}
 		mEntities.push_back( pEntity );
 	}
@@ -520,6 +530,13 @@
 
 		mParticleSystems.erase( victim );
 	}
+
+	//------------------------------------------------------
+	ISceneNode* OgreNode::getParent() const
+	{ 
+		return (mWorld.isRoot(mParentNode) ? 0 : mParentNode); 
+	}
+
 }
 }
 }

Added: trunk/yake/src/yake/samples/model/dotScene/demo.cpp
===================================================================
--- trunk/yake/src/yake/samples/model/dotScene/demo.cpp	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/src/yake/samples/model/dotScene/demo.cpp	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,194 @@
+//****************************************************************************
+//**
+//**    Sample
+//**
+//**	Simpler than simple sample! Beware!
+//**	It's WIP towards a real sample :)
+//**
+//**	When running, press ESC to exit.
+//**
+//****************************************************************************
+
+#include <yake/samples/model/dotScene/pch.h>
+#include <yake/model/model.h>
+
+#pragma warning( disable: 4305 ) // truncation from 'double' to 'float'
+
+using namespace yake;
+
+class TheApp : public yake::exapp::ExampleApplication
+{
+private:
+	typedef std::pair<graphics::IViewport*,graphics::ICamera*> ViewportCameraPair;
+	Vector<ViewportCameraPair >			mVPs;
+	SharedPtr< graphics::IWorld >		mGWorld;
+
+public:
+	TheApp() : ExampleApplication(
+					true /*graphics*/,
+					false /*physics*/,
+					false /*scripting*/,
+					true /*input*/,
+					false /*script bindings*/,
+					false /*audio*/)
+	{
+	}
+	void onKey(const yake::input::KeyboardEvent & e)
+	{
+		std::cout << "Key pressed: " << e.keyCode << "\n";
+		
+		if (e.keyCode == input::KC_ESCAPE)
+			requestShutdown();
+	}
+	void onMB(uint8 btn)
+	{
+		std::cout << "MB: " << static_cast<int>(btn) << std::endl;
+	}
+	int createCameraViewportPair( real sx, real sy, real w, real h, int z )
+	{
+		graphics::ICamera* pC = mGWorld->createCamera();
+		YAKE_ASSERT( pC );
+		pC->setNearClipDistance( 1. );
+        // incase infinite far distance is not supported
+        pC->setFarClipDistance(100000);
+
+		mVPs.push_back( ViewportCameraPair(mGWorld->createViewport( pC ), pC) );
+		size_t idx = mVPs.size()-1;
+		YAKE_ASSERT( mVPs[idx].first );
+		mVPs[idx].first->setDimensions( sx, sy, w, h );
+		mVPs[idx].first->setZ( z );
+		return static_cast<int>(idx);
+	}
+	void setupScene()
+	{
+		// Floor plane
+		graphics::IEntity* ent = mGWorld->createEntity("plane_1x1.mesh");
+		YAKE_ASSERT( ent );
+		graphics::ISceneNode* node = mGWorld->createSceneNode("sn_plane");
+		YAKE_ASSERT( node );
+		node->attachEntity( ent );
+		node->setScale( Vector3(1000,1,1000) );
+		ent->setMaterial("Examples/BumpyMetal");
+		ent->setCastsShadow(false);
+	}
+
+	virtual void run()
+	{
+		// setup event input generators
+		mKeyboardEventGenerator.subscribeToKeyDown( Bind1( &TheApp::onKey, this ) );
+		mMouseEventGenerator.subscribeToMouseButtonDown( Bind1( &TheApp::onMB, this ) );
+
+		// graphics
+		mGWorld = getGraphicsSystem().createWorld();
+		YAKE_ASSERT( mGWorld );
+
+		//NOTE: Make sure you create a camera before calling mGWorld->setShadowsEnabled(true)
+		// when using "ogre3d" and the terrain scene manager with modulated texture shadows.
+		// The first camera created will be used as the primary camera by the scene manager
+		// and it crashes wildly if it's a texture shadow camera!
+
+		createCameraViewportPair( 0.0, 0.0, 1, 1, 10 );
+		//createCameraViewportPair( 0.0, 0.0, 0.5, 0.5, 10 );
+		//createCameraViewportPair( 0.5, 0.0, 0.5, 0.5, 11 );
+		//createCameraViewportPair( 0.0, 0.5, 0.5, 0.5, 12 );
+		//createCameraViewportPair( 0.5, 0.5, 0.5, 0.5, 13 );
+
+		if (mVPs[0].second)
+		{
+			mVPs[0].second->translate( Vector3(0,100,700) );
+			mVPs[0].second->pitch(-10);
+		}
+		if (mVPs.size() > 1 && mVPs[1].second)
+			mVPs[1].second->setPosition( Vector3(0,2,-80) );
+		if (mVPs.size() > 2 && mVPs[2].second)
+		{
+			mVPs[2].second->translate( Vector3(0,15,30) );
+			mVPs[2].second->pitch(-30);
+		}
+		if (mVPs.size() > 3 && mVPs[3].second)
+		{
+			mVPs[3].second->setPosition( Vector3(0,50,0) );
+			mVPs[3].second->pitch(-90);
+		}
+
+		// scene
+		setupScene();
+
+		//mGWorld->setShadowsEnabled( true );
+		model::ModelManager modelMgr;
+		modelMgr.setCreationContext_GraphicalWorld( mGWorld.get() );
+
+		model::Model* m = modelMgr.createModel("graphics/dotScene:name=gfx1;file=../../media/samples/dotScene/DotScene1.scene");
+		YAKE_ASSERT( m );
+
+		m = modelMgr.createModel("graphics/dotScene:name=gfx2;file=../../media/samples/dotScene/DotScene1.scene");
+		YAKE_ASSERT( m );
+		((model::Graphical*)m->getComponentByTag("gfx2"))->translate(Vector3(40,20,0));
+
+		// main loop
+		real lastTime = native::getTime();
+		while (!shutdownRequested())
+		{
+			// timing
+			real time = native::getTime();
+			real timeElapsed = time-lastTime;//timer->getSeconds();
+			lastTime = time;
+
+			// handle input
+			getInputSystem().update();
+			mMouseEventGenerator.update();
+			mKeyboardEventGenerator.update();
+
+			//
+			YAKE_ASSERT( getKeyboard() );
+			if (getKeyboard())
+			{
+				static unsigned iCam = 0;
+				real distance = real(-200. * timeElapsed);
+				if (getKeyboard()->isKeyDown(input::KC_LEFT))
+					mVPs[iCam].second->translate( Vector3(distance, 0, 0) );
+				if (getKeyboard()->isKeyDown(input::KC_RIGHT))
+					mVPs[iCam].second->translate( Vector3(-distance, 0, 0) );
+				if (getKeyboard()->isKeyDown(input::KC_UP))
+					mVPs[iCam].second->translate( Vector3(0, 0, distance) );
+				if (getKeyboard()->isKeyDown(input::KC_DOWN))
+					mVPs[iCam].second->translate( Vector3(0, 0, -distance) );
+			}
+
+			// render the scene
+			if (!shutdownRequested())
+				mGWorld->render( timeElapsed );
+		}
+
+		mGWorld.reset();
+	}
+};
+
+//============================================================================
+//    IMPLEMENTATION FUNCTIONS
+//============================================================================
+
+int main()
+{
+	try
+	{
+		std::cout << std::endl << "A simple demo :) provided for YAKE by Stephan Kaiser" << std::endl;
+		TheApp theApp;
+		theApp.initialise();
+		theApp.run();
+	}
+	catch ( const yake::Exception& e )
+	{
+		std::cout << std::endl << e.what() << std::endl;
+	}
+	catch (...)
+	{
+		std::cout << std::endl << "-----------------" << std::endl << "UNHANDLED EXCEPTION" << std::endl;
+	}
+#if defined( YAKE_DEBUG_BUILD )
+	std::cout << std::endl << "Waiting for you...";
+	std::cin.get();
+#endif
+
+	return 0;
+}

Added: trunk/yake/src/yake/samples/model/dotScene/pch.cpp
===================================================================
--- trunk/yake/src/yake/samples/model/dotScene/pch.cpp	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/src/yake/samples/model/dotScene/pch.cpp	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1 @@
+#include <yake/samples/model/dotScene/pch.h>

Modified: trunk/yake/yake/base/templates/yakeVector.h
===================================================================
--- trunk/yake/yake/base/templates/yakeVector.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/base/templates/yakeVector.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -260,6 +260,11 @@
 		{
 			return *mCurrent++;
 		}
+		/** Returns the next element in the collection, and advances to the next. */
+		const typename T::value_type& getNextRef(void)
+		{
+			return *mCurrent++;
+		}
 		/** Returns the next element in the collection, without advancing to the next. */
 		typename T::value_type peekNext(void)
 		{

Modified: trunk/yake/yake/base/yakePrerequisites.h
===================================================================
--- trunk/yake/yake/base/yakePrerequisites.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/base/yakePrerequisites.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -85,6 +85,7 @@
 #	define YAKE_BASE_API DLLIMPORT
 #endif
 
+#define _T(X) X
 
 #if defined(_DEBUG) || defined(DEBUG)
 #	define YAKE_DEBUG

Modified: trunk/yake/yake/base/yakeString.h
===================================================================
--- trunk/yake/yake/base/yakeString.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/base/yakeString.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -143,6 +143,17 @@
 	private:
 		StringMap m_map;
 	};
+	inline std::ostream& operator << (std::ostream& out, const StringMap& rhs)
+	{
+		out << "StringMap(";
+		for (StringMap::const_iterator it = rhs.begin(); it != rhs.end(); ++it)
+		{
+			out << ((it == rhs.begin()) ? "" : ";") 
+				<< it->first << "=" << it->second;
+		}
+		out << ")";
+		return out;
+	}
 
 #undef YAKE_BASE_STRING
 

Modified: trunk/yake/yake/graphics/yakeGraphicalWorld.h
===================================================================
--- trunk/yake/yake/graphics/yakeGraphicalWorld.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/graphics/yakeGraphicalWorld.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -309,6 +309,8 @@
 
 		virtual void setInheritScale( bool inherit ) = 0;
 
+		virtual ISceneNode* getParent() const = 0;
+
 		/** Returns a list of all child scene nodes of this scene node.
 		*/
 		virtual void getChildren( SceneNodePtrList& ret, bool bRecursive = false ) const = 0;
@@ -385,6 +387,9 @@
 			@param relativeTo TransformSpace to use for the rotation.
 		*/
 		virtual void rotate( const math::Quaternion& rDelta, const TransformSpace relativeTo = TS_PARENT ) = 0;
+
+		//virtual ISceneNode* shallowClone() const = 0;
+		//virtual ISceneNode* deepClone() const = 0;
 	};
 
 	/** Viewport abstract interface.

Added: trunk/yake/yake/loader/loader.h
===================================================================
--- trunk/yake/yake/loader/loader.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/loader/loader.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,33 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#ifndef YAKE_LOADER_H
+#define YAKE_LOADER_H
+
+#include "yake/loader/prerequisites.h"
+#include "yake/loader/yakeDotScene.h"
+
+#endif

Added: trunk/yake/yake/loader/pch.h
===================================================================
--- trunk/yake/yake/loader/pch.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/loader/pch.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,33 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#ifndef YAKE_LOADER_PCH_H
+#define YAKE_LOADER_PCH_H
+
+#include <yake/base/yake.h>
+#include <yake/data/yakeData.h>
+
+#endif

Added: trunk/yake/yake/loader/prerequisites.h
===================================================================
--- trunk/yake/yake/loader/prerequisites.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/loader/prerequisites.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,40 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#ifndef YAKE_LOADER_PREREQUISITES_H
+#define YAKE_LOADER_PREREQUISITES_H
+
+#if defined(YAKE_LOADER_EXPORTS)
+#	define YAKE_LOADER_API DLLEXPORT
+#else
+#	define YAKE_LOADER_API DLLIMPORT
+#endif
+
+#if (YAKE_PLATFORM == PLATFORM_WIN32) && !defined(YAKE_LOADER_EXPORTS)
+#pragma comment(lib,"loader.lib")
+#endif
+
+#endif

Added: trunk/yake/yake/loader/yakeDotScene.h
===================================================================
--- trunk/yake/yake/loader/yakeDotScene.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/loader/yakeDotScene.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,224 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright  2004 The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#ifndef YAKE_DATA_DOTSCENE_H
+#define YAKE_DATA_DOTSCENE_H
+
+#include <yake/loader/prerequisites.h>
+#include <yake/data/yakeData.h>
+#include <yake/graphics/yakeGraphics.h>
+
+#pragma warning(disable: 4244)
+
+namespace yake {
+namespace data {
+namespace parser {
+namespace dotscene {
+
+	/** DotSceneParser base class providing default implementation for DOM parsing of dotScene files.
+	* \todo read environment, external references ..
+	*/
+	class YAKE_LOADER_API DotSceneParser
+	{
+	public:
+		
+		struct Desc
+		{
+			String		name;
+			String		id;
+			String		parentNodeName;
+			String		path;
+		};
+		
+		struct Transform
+		{
+			math::Vector3		position;
+			math::Quaternion	rotation;
+			math::Vector3		scale; 
+		};
+		
+		struct NodeDesc : public Desc
+		{
+			Transform	transform;
+		};
+		
+		struct EntityDesc : public Desc
+		{
+			String		meshFile;
+			String		materialFile;
+			bool		castsShadows;
+			bool		isStatic;
+		};
+		
+		struct CameraDesc : public Desc
+		{
+			real					fov;
+			real					aspectRatio;
+			graphics::ICamera::ProjectionType	projectionType;
+			String					trackTargetName;
+			math::Vector3				normal;
+			
+			struct Clipping
+			{
+				real nearClip;
+				real farClip;
+			} clipping;
+		};
+		
+		struct LightDesc : public Desc
+		{
+			graphics::ILight::LightType	type;
+			bool				visible;
+			bool				castsShadows;
+			math::Color			diffuseColor;
+			math::Color			specularColor;
+			math::Vector3			normal;
+			
+			struct Range
+			{
+				real inner;
+				real outer;
+				real falloff;
+			} range;
+			
+			struct Attenuation
+			{
+				real range;
+				real constant;
+				real linear;
+				real quadratic;
+			}							attenuation;
+			
+			LightDesc() : visible( true ), castsShadows( false )
+			{}
+		};
+		
+		typedef AssocVector< String, NodeDesc > SceneNodeDescMap;
+		typedef AssocVector< String, EntityDesc > EntityDescMap;
+		typedef AssocVector< String, CameraDesc > CameraDescMap;
+		typedef AssocVector< String, LightDesc > LightDescMap;
+
+		static const String ROOT_NODE_NAME;
+		
+		virtual ~DotSceneParser() {}
+
+		String getName() const
+		{ return "yake.data.dotScene"; }
+
+		virtual Version getVersion() const = 0;
+
+		/** Build graphics scene from DOM!
+			\param file 
+			\return 
+		*/
+		virtual bool load(	const SharedPtr<dom::INode>& docNode );
+
+		/** Prepare for next run of load/store.
+		*/
+		virtual void reset();
+		
+		const SceneNodeDescMap& getSceneNodeDescriptions() { return mSNDescriptions; }
+		const EntityDescMap& getEntityDescriptions() { return mEntityDescriptions; }
+		const CameraDescMap& getCameraDescriptions() { return mCameraDescriptions; }
+		const LightDescMap& getLightDescriptions() { return mLightDescriptions; }
+		
+		typedef SignalX< void(const NodeDesc) > NodeSignal;
+		typedef SignalX< void(const EntityDesc) > EntitySignal;
+		typedef SignalX< void(const CameraDesc) > CameraSignal;
+		typedef SignalX< void(const LightDesc) > LightSignal;
+		
+		
+		SignalConnection subscribeToNodeSignal( const NodeSignal::slot_type& slot )
+		{ return mSigNode.connect(slot); } 
+		
+		SignalConnection subscribeToEntitySignal( const EntitySignal::slot_type& slot )
+		{ return mSigEntity.connect(slot); } 
+	
+		SignalConnection subscribeToCameraSignal( const CameraSignal::slot_type& slot )
+		{ return mSigCamera.connect(slot); } 
+	
+		SignalConnection subscribeToLightSignal( const LightSignal::slot_type& slot )
+		{ return mSigLight.connect(slot); } 
+		
+	private:
+		NodeSignal		mSigNode;
+		EntitySignal	mSigEntity;
+		CameraSignal	mSigCamera;
+		LightSignal		mSigLight;
+
+	protected:
+		/// Default implementations for common functions
+
+		virtual void readScene( const SharedPtr<dom::INode>& pNode );
+		
+		virtual void readNodes( const SharedPtr<dom::INode>& pNodes, const String& path );
+		
+		virtual void readNode( const SharedPtr<dom::INode>& pNode, const String& parentNodeName, const String& path );
+		virtual void readEntity( const SharedPtr<dom::INode>& pNode, const String& parentNodeName, const String& path );
+		
+		virtual void readRotation( const SharedPtr<dom::INode>& pNode, math::Quaternion& rotation );
+		virtual void readPosition( const SharedPtr<dom::INode>& pNode, math::Vector3& position );
+		virtual void readScale( const SharedPtr<dom::INode>& pNode, math::Vector3& rScale );
+		virtual void readVector( const SharedPtr<dom::INode>& pNode, math::Vector3& rVec );
+		
+		virtual void readLight( const SharedPtr<dom::INode>& pNode, const String& parentNodeName, const String& path );
+		
+		virtual void readColour( const SharedPtr<dom::INode>& pNode, math::Color& colour );
+		virtual void readLightRange( const SharedPtr<dom::INode>& pNode, LightDesc& );
+		virtual void readLightAttenuation( const SharedPtr<dom::INode>& pNode, LightDesc& );
+		
+		virtual void readCamera( const SharedPtr<dom::INode>& pNode, const String& parentNodeName, const String& path );
+		
+		virtual void readCameraClipping( const SharedPtr<dom::INode>& pNode, CameraDesc& );
+
+	private:
+		SharedPtr<dom::INode>	mDocNode;
+
+		SceneNodeDescMap		mSNDescriptions;
+		EntityDescMap			mEntityDescriptions;
+		CameraDescMap			mCameraDescriptions;
+		LightDescMap			mLightDescriptions;
+		
+		
+	};
+
+	class YAKE_LOADER_API DotSceneParserV1 : public DotSceneParser
+	{
+		YAKE_DECLARE_CLASS( DotSceneParserV1 );
+	public:
+		virtual Version getVersion() const
+		{ return Version( 0, 1, 2 ); }
+	};
+
+	///HACK It is here for backwards compatibility
+	typedef DotSceneParserV1 DotSceneSerializerV1;
+
+} // dotscene
+} // parser
+} // data
+} // yake
+
+#endif

Added: trunk/yake/yake/model/model.h
===================================================================
--- trunk/yake/yake/model/model.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/model/model.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,171 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#ifndef YAKE_MODEL_H
+#define YAKE_MODEL_H
+
+#ifndef YAKE_MODEL_INCLUDE_LOADERS
+//@todo enable #	define YAKE_MODEL_INCLUDE_LOADERS 1
+#endif
+
+#include "yake/model/prerequisites.h"
+#include "yake/model/model_link.h"
+#include "yake/model/model_component.h"
+#if YAKE_MODEL_INCLUDE_LOADERS == 1
+#	include "yake/model/loader/loader_xode.h"
+#	include "yake/model/loader/loader_dotscene.h"
+#endif
+
+namespace yake {
+namespace model {
+	///@todo move out!!!
+	struct CentralController
+	{
+		// parameters: frame (int32), timeElapsed/dt (real)
+		typedef Signal2<void(const uint32, const real)> PhysicsUpdateSignal;
+		typedef Signal2<void(const uint32, const real)> GraphicsUpdateSignal;
+		SignalConnection subscribeToPhysicsUpdate(const PhysicsUpdateSignal::slot_type&); 
+		SignalConnection subscribeToGraphicsUpdate(const PhysicsUpdateSignal::slot_type&);
+	};
+
+	template<typename T>
+	struct Clonable
+	{
+		virtual ~Clonable() {}
+		virtual T* clone() const = 0;
+	};
+
+	struct YAKE_MODEL_API Model
+	{
+		Model();
+		//virtual ~Model() {} //@todo virtual?
+
+		// basic properties
+		void setName(const String&);
+		const String& getName() const;
+
+		// component management
+		void addComponent(ModelComponent*);
+		void addComponent(ModelComponent*, const ComponentTag&);
+		ModelComponent* removeComponent(ModelComponent*);
+		ModelComponent* getComponentByTag(const ComponentTag&) const;
+		ModelComponent* getComponentByIndex(const size_t) const;
+		size_t numComponents() const;
+
+		// link management
+		void addLink(ModelLink*);
+		void removeLink(ModelLink*);
+		void destroyAllLinks();
+
+		// signal
+
+		// helpers (for convencience only)
+		/** For convenience! This function creates a ModelMovableLink between
+			source and target movable objects. Both position and rotation
+			are marked for updates.
+			@Remarks This function is optimized to cache the created links
+				for each source. That means that for each source there's
+				only ever a single link (instead of having one for each
+				pair of source/target objects).
+		*/
+		ModelMovableLink* createLink(Movable*,Movable*,const String& linkType = "yake.movable");
+		ModelMovableLink* createDirectLink(Movable*,Movable*); // uses "yake.movable"
+		ModelMovableLink* createWorldSpaceLink(Movable*,Movable*); // uses "yake.movable_world"
+
+		//Model* clone() const;
+	private:
+		Model(const Model&);
+		Model& operator=(const Model&);
+	private:
+		String					name_;
+		String					internalName_;
+
+		typedef AssocVector< Movable*, ModelMovableLink* > MovableLinkMap;
+		MovableLinkMap			movableLinkMap_;
+
+		ModelLinkContainer		links_;
+		ModelComponentContainer	components_;
+	};
+	struct YAKE_MODEL_API ModelManager
+	{
+	public:
+		ModelManager();
+		~ModelManager();
+
+		Model* createModel(const String&);
+
+		void setCreationContext_GraphicalWorld(graphics::IWorld*);
+		void setCreationContext_PhysicalWorld(physics::IWorld*);
+	private:
+		ModelManager(const ModelManager&);
+		ModelManager& operator=(const ModelManager&);
+	private:
+		ComponentCreatorManager		creatorMgr_;
+		ComponentCreationContext	ctx_;
+
+		typedef Vector<SharedPtr<Model> > ModelList;
+		ModelList					models_;
+	};
+	/**@todo Move into private impl file. */
+	struct ModelTemplate : public ModelComponentContainer
+	{
+		ModelTemplate();
+		~ModelTemplate();
+
+		/// Example 1: from=physical:"p_mine":actor:"mineActor" to=graphical:"g_mine":scenenode:"mine_root"
+		/// Example 2: from=physical:"p_mine":shape:"mineActor/sphere1" to=graphical:"g_mine":scenenode:"mine_root"
+		/// Example params for ModelMovableLink: "position,orientation"
+		void addLink(const String& from, const String& to, const String& params);
+
+		/// Clones model (including components) and recreates links for the cloned model.
+		Model* createInstance(const String& name) const;
+	private:
+		ModelTemplate(const ModelTemplate&);
+		ModelTemplate& operator=(const ModelTemplate&);
+	private:
+		struct link_t
+		{
+			String	fromComponentType_;
+			String	fromComponentName_;
+			String	fromElementType_;
+			String	fromElementName_;
+			String	toComponentType_;
+			String	toComponentName_;
+			String	toElementType_;
+			String	toElementName_;
+		};
+		typedef std::deque<link_t> LinkList;
+		LinkList	links_;
+
+		Model*		modelWithoutLinks_;
+	private:
+		void _createLinks(Model&);
+	};
+
+} // namespace model
+} // namespace yake
+
+#endif

Added: trunk/yake/yake/model/model_component.h
===================================================================
--- trunk/yake/yake/model/model_component.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/model/model_component.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,222 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#ifndef YAKE_MODEL_COMPONENT_H
+#define YAKE_MODEL_COMPONENT_H
+
+#include "yake/model/prerequisites.h"
+
+namespace yake {
+namespace model {
+
+	struct YAKE_MODEL_API ModelComponent //: public Clonable<ModelComponent>
+	{
+		ModelComponent() {}
+		virtual ~ModelComponent() {}
+	private:
+		ModelComponent(const ModelComponent&);
+		ModelComponent& operator=(const ModelComponent&);
+	};
+	typedef SharedPtr<ModelComponent> ModelComponentSharedPtr;
+	typedef std::deque<ModelComponentSharedPtr> ModelComponentList;
+	typedef std::string ComponentTag;
+	struct YAKE_MODEL_API ModelComponentContainer
+	{
+		ModelComponentContainer();
+		void addComponent(ModelComponent*);
+		void addComponent(ModelComponent*, const ComponentTag&);
+		ModelComponent* getComponentByTag(const ComponentTag&) const;
+		ModelComponent* getComponentByIndex(const size_t) const;
+		size_t numComponents() const;
+		bool empty() const;
+	private:
+		ModelComponentContainer(const ModelComponentContainer&);
+		ModelComponentContainer& operator=(const ModelComponentContainer&);
+	protected:
+		//void _cloneComponents(Model& cloned) const;
+	protected:
+		ModelComponentList		components_;
+		typedef std::map<ComponentTag,ModelComponentSharedPtr> TagModelComponentMap;
+		TagModelComponentMap	tag2components_;
+	};
+
+	////@todo move out:
+
+	struct YAKE_MODEL_API Physical : public ModelComponent
+	{
+	private:
+		Physical(const Physical&);
+		Physical& operator=(const Physical&);
+	public:
+		//@todo register factory?
+		Physical();
+		virtual ~Physical();
+
+		void addActor(physics::IActor*, const String&);
+		void addBody(physics::IBody*, const String&);
+		void addJoint(physics::IJoint*, const String&);
+
+		physics::IActor* getActor(const String&) const;
+		physics::IBody* getBody(const String&) const;
+		physics::IJoint* getJoint(const String&) const;
+
+		//getShape(const String&,const String&)
+
+		//void setPosition(const Vector3&);
+		//void setOrientation(const Quaternion&);
+		//void translate(const Vector3&);
+		//void rotate(const Quaternion&);
+	private:
+		template<typename T>
+		struct EntryT
+		{
+			typedef T* pointer;
+			pointer	p_;
+			EntryT(pointer p) : p_(p)
+			{}
+		};
+		typedef AssocVector<String,EntryT<physics::IActor> > TagActorMap;
+		typedef AssocVector<String,EntryT<physics::IBody> > TagBodyMap;
+		typedef AssocVector<String,EntryT<physics::IJoint> > TagJointMap;
+		TagActorMap		actors_;
+		TagBodyMap		bodies_;
+		TagJointMap		joints_;
+
+		template<typename T>
+		void _add(T* obj,AssocVector<String,EntryT<T> >& ctr, const String& xpath)
+		{
+			YAKE_ASSERT( obj );
+			YAKE_ASSERT( !xpath.empty() );
+#ifdef YAKE_DEBUG_BUILD
+			YAKE_ASSERT( ctr.end() == ctr.find(xpath) )(xpath).debug(_T("Item with this xpath already exists!"));
+#endif
+			ctr.insert( std::make_pair( xpath, EntryT<T>(obj) ) );
+		}
+		template<typename T>
+		T* _get(const AssocVector<String,EntryT<T> >& ctr, const String& xpath) const
+		{
+			typename AssocVector<String,EntryT<T> >::const_iterator it = ctr.find( xpath );
+			return ((it != ctr.end()) ? it->second.p_ : 0);
+		}
+	};
+	struct YAKE_MODEL_API Graphical : public ModelComponent
+	{
+		Graphical();
+		virtual ~Graphical();
+		//@todo register factory?
+
+		//virtual ModelComponent* clone() const;
+
+		void addSceneNode(graphics::ISceneNode*, const String& xpath, const bool owned = true);
+		void addEntity(graphics::IEntity*, const String& xpath, const bool owned = true);
+		void addLight(graphics::ILight*, const String& xpath, const bool owned = true);
+		//void addCamera()
+
+		graphics::ISceneNode* getSceneNode(const String& xpath) const;
+		graphics::IEntity* getEntity(const String& xpath) const;
+		graphics::ILight* getLight(const String& xpath) const;
+
+		//void setPosition(const Vector3&);
+		//void setOrientation(const Quaternion&);
+
+		///! translates root nodes only!
+		void translate(const Vector3&);
+		//void rotate(const Quaternion&);
+	private:
+		Graphical(const Graphical&);
+		Graphical& operator=(const Graphical&);
+	private:
+		template<typename T>
+		struct EntryT
+		{
+			typedef T* pointer;
+			pointer	p_;
+			bool	owned_;
+			EntryT(pointer p, const bool owned) : p_(p), owned_(owned)
+			{}
+		};
+		typedef AssocVector<String,EntryT<graphics::ISceneNode> > TagNodeMap;
+		typedef AssocVector<String,EntryT<graphics::IEntity> > TagEntityMap;
+		typedef AssocVector<String,EntryT<graphics::ILight> > TagLightMap;
+		TagNodeMap		nodes_;
+		TagEntityMap	entities_;
+		TagLightMap		lights_;
+		template<typename T>
+		void _add(T* obj,AssocVector<String,EntryT<T> >& ctr, const String& xpath, const bool owned)
+		{
+			YAKE_ASSERT( obj );
+			YAKE_ASSERT( !xpath.empty() );
+#ifdef YAKE_DEBUG_BUILD
+			YAKE_ASSERT( ctr.end() == ctr.find(xpath) )(xpath).debug(_T("Item with this xpath already exists!"));
+#endif
+			ctr.insert( std::make_pair( xpath, EntryT<T>(obj,owned) ) );
+		}
+		template<typename T>
+		T* _get(const AssocVector<String,EntryT<T> >& ctr, const String& xpath) const
+		{
+			typename AssocVector<String,EntryT<T> >::const_iterator it = ctr.find( xpath );
+			return ((it != ctr.end()) ? it->second.p_ : 0);
+		}
+	};
+	//@todo move into private header
+	struct ComponentCreationContext
+	{
+		graphics::IWorld*	gworld_;
+		physics::IWorld*	pworld_;
+		ComponentCreationContext() : gworld_(0), pworld_(0)
+		{}
+	};
+	struct YAKE_MODEL_API ComponentCreator
+	{
+		YAKE_DECLARE_REGISTRY_0(ComponentCreator, String);
+		virtual ~ComponentCreator() {}
+
+		virtual ModelComponent* create(const ComponentCreationContext& ctx, const StringMap& params) = 0;
+	};
+	struct GraphicalFromDotSceneCreator : public ComponentCreator
+	{
+		YAKE_DECLARE_CONCRETE(GraphicalFromDotSceneCreator,"graphics/dotScene");
+
+		virtual ModelComponent* create(const ComponentCreationContext& ctx, const StringMap& params);
+	};
+	struct YAKE_MODEL_API ComponentCreatorManager
+	{
+		ComponentCreatorManager();
+		~ComponentCreatorManager();
+
+		ModelComponent* create(const String& type, const ComponentCreationContext& ctx, const StringMap& params);
+	private:
+		ComponentCreatorManager(const ComponentCreatorManager&);
+		ComponentCreatorManager& operator=(const ComponentCreatorManager);
+	private:
+		typedef AssocVector<String,SharedPtr<ComponentCreator> > TypeCreatorMap;
+		TypeCreatorMap	creators_;
+	};
+
+} // namespace model
+} // namespace yake
+
+#endif

Added: trunk/yake/yake/model/model_graphical_dotscene_loader.h
===================================================================
--- trunk/yake/yake/model/model_graphical_dotscene_loader.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/model/model_graphical_dotscene_loader.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,112 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright  2004 The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+
+#ifndef YAPP_MODEL_GRAPHICAL_DOTSCENE_LOADER_H
+#define YAPP_MODEL_GRAPHICAL_DOTSCENE_LOADER_H
+
+#include <yake/model/prerequisites.h>
+#include <yake/graphics/yakeGraphicsSystem.h>
+#include <yake/loader/yakeDotScene.h>
+
+namespace yake {
+namespace model {
+
+    /** Class implements DotSceneParser's listener. Creates graphical objects and places
+     * them in model::Graphical object.
+     */
+    class YAKE_MODEL_API DotSceneListener
+    {
+	public:
+	    DotSceneListener( Graphical& owner, const String& namePrefix = _T("") ) :
+		  mOwner(owner), mNamePrefix(namePrefix)
+	    {}
+
+	    virtual ~DotSceneListener() {}		
+
+	    typedef yake::data::parser::dotscene::DotSceneParser::NodeDesc SceneNodeDesc;
+	    typedef yake::data::parser::dotscene::DotSceneParser::EntityDesc EntityDesc;
+	    typedef yake::data::parser::dotscene::DotSceneParser::CameraDesc CameraDesc;
+	    typedef yake::data::parser::dotscene::DotSceneParser::LightDesc LightDesc;
+
+	    virtual void processSceneNode( const SceneNodeDesc& );
+	    virtual void processEntity( const EntityDesc& );
+	    virtual void processCamera( const CameraDesc& );
+	    virtual void processLight( const LightDesc& );
+
+	    void reset( graphics::IWorld* graphicsWorld )
+	    {
+			mSceneNodes.clear();
+			mEntities.clear();
+			mCameras.clear();
+			mLights.clear();
+
+			mGWorld = graphicsWorld;
+	    }
+
+	    struct EntityInfo
+	    {
+			graphics::IEntity*	entity;
+			String		parentSceneNode;
+	    };
+
+	    struct CameraInfo
+	    {
+			graphics::ICamera*	camera;
+			String		parentSceneNode;
+	    };
+
+	    struct LightInfo
+	    {
+			graphics::ILight*	light;
+			String		parentSceneNode;
+	    };
+
+	    typedef AssocVector< String, graphics::ISceneNode* > SceneNodeMap;
+	    typedef AssocVector< String, EntityInfo > EntityMap;
+	    typedef AssocVector< String, CameraInfo > CameraMap;
+	    typedef AssocVector< String, LightInfo > LightMap;
+
+	    typedef std::map< String, String > TrackerMap;
+	    TrackerMap		mTrackersTargets;
+
+	    SceneNodeMap	mSceneNodes;
+	    EntityMap		mEntities;
+	    CameraMap		mCameras;
+	    LightMap		mLights;
+
+	    graphics::IWorld*	mGWorld;
+
+	    Graphical&		mOwner;
+		String			mNamePrefix;
+    };
+
+
+} // model
+} // yake
+
+#endif 
+

Added: trunk/yake/yake/model/model_link.h
===================================================================
--- trunk/yake/yake/model/model_link.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/model/model_link.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,119 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#ifndef YAKE_MODEL_LINK_H
+#define YAKE_MODEL_LINK_H
+
+#include "yake/model/prerequisites.h"
+
+namespace yake {
+namespace model {
+
+	struct YAKE_MODEL_API ModelLink
+	{
+		virtual ~ModelLink() {}
+		YAKE_DECLARE_REGISTRY_0( ModelLink, ::yake::String );
+	};
+	struct YAKE_MODEL_API ModelLinkContainer
+	{
+		ModelLinkContainer();
+		virtual ~ModelLinkContainer();
+		void addModelLink(ModelLink*);
+		void removeModelLink(ModelLink*);
+		void destroyAllModelLinks();
+	private:
+		ModelLinkContainer(const ModelLinkContainer&);
+		ModelLinkContainer& operator=(const ModelLinkContainer&);
+	protected:
+		//void _cloneLinks(ModelLinkContainer& cloned) const;
+	protected:
+		typedef std::deque<ModelLink*> ModelLinkList;
+		ModelLinkList	links_;
+	};
+	template<typename Arg0Type>
+	struct Updatable
+	{
+		virtual ~Updatable() {}
+		virtual void update(const Arg0Type) = 0;
+	};
+	struct YAKE_MODEL_API ModelMovableLink : public ModelLink, public Updatable<real>
+	{
+	public:
+		typedef Signal1< void(const Vector3&) > PositionSignal;
+		typedef Signal1< void(const Quaternion&) > OrientationSignal;
+
+		SignalConnection subscribeToPositionChanged( const PositionSignal::slot_type& slot );
+		SignalConnection subscribeToOrientationChanged( const OrientationSignal::slot_type& slot );
+		SignalConnection subscribeToPositionChanged( Movable* pMovable );
+		SignalConnection subscribeToOrientationChanged( Movable* pMovable );
+
+	protected:
+		ModelMovableLink();
+	protected:
+		PositionSignal		mPositionSignal;
+		OrientationSignal	mOrientationSignal;
+
+		Vector3				mLastPosition;
+		Quaternion			mLastOrientation;
+	};
+	/** A link controller designed to forward position and/or orientation to
+		to other clients using signals. Factory item id is "yake.movable".
+		@Remarks A controller only fires signals when the values have changed!
+	*/
+	struct ModelMovableDirectLink : public ModelMovableLink
+	{
+	public:
+		YAKE_DECLARE_CONCRETE( ModelMovableDirectLink, "yake.movable" );
+
+		ModelMovableDirectLink();
+		virtual void update( const real timeElapsed );
+	};
+	/** A link controller designed to forward absolute (world space) position and/or orientation to
+		to other clients using signals. Factory item id is "yake.movable".
+		@Remarks A controller only fires signals when the values have changed!
+	*/
+	struct ModelMovableWorldLink : public ModelMovableLink
+	{
+	public:
+		YAKE_DECLARE_CONCRETE( ModelMovableWorldLink, "yake.movable_world" ); // world coordinate system
+
+		ModelMovableWorldLink();
+		virtual void update( const real timeElapsed );
+	};
+	struct ModelMovableLink_decoupled : public ModelMovableLink
+	{
+	public:
+		YAKE_DECLARE_CONCRETE( ModelMovableWorldLink, "yake.movable.decoupled" );
+
+		ModelMovableLink_decoupled();
+		virtual void update( const real timeElapsed );
+		//@todo add history/interpolation specific code
+	};
+
+} // namespace model
+} // namespace yake
+
+#endif

Added: trunk/yake/yake/model/pch.h
===================================================================
--- trunk/yake/yake/model/pch.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/model/pch.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,32 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#ifndef YAKE_MODEL_PCH_H
+#define YAKE_MODEL_PCH_H
+
+#include "yake/base/yake.h"
+
+#endif

Added: trunk/yake/yake/model/prerequisites.h
===================================================================
--- trunk/yake/yake/model/prerequisites.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/model/prerequisites.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,53 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#ifndef YAKE_MODEL_PREREQUISITES_H
+#define YAKE_MODEL_PREREQUISITES_H
+
+#if defined(YAKE_MODEL_EXPORTS)
+#	define YAKE_MODEL_API DLLEXPORT
+#else
+#	define YAKE_MODEL_API DLLIMPORT
+#endif
+
+#if (YAKE_PLATFORM == PLATFORM_WIN32) && !defined(YAKE_MODEL_EXPORTS)
+#pragma comment(lib,"model.lib")
+#endif
+
+#include "yake/physics/yakePhysics.h"
+#include "yake/graphics/yakeGraphics.h"
+
+namespace yake {
+namespace model {
+
+	struct ModelComponent;
+	struct ModelComponentContainer;
+	struct Model;
+
+} // namespace model
+} // namespace yake
+
+#endif

Modified: trunk/yake/yake/physics/yakePhysicsJoint.h
===================================================================
--- trunk/yake/yake/physics/yakePhysicsJoint.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/physics/yakePhysicsJoint.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -69,6 +69,7 @@
 	};
 	typedef Deque<Limit> LimitList;
 
+	class IWorld;
 	class IActor;
 	class IAngularMotor;
 	class YAKE_PHYSICS_API IJoint
@@ -185,6 +186,8 @@
 	public:
 		virtual ~IJoint() {}
 
+		virtual IWorld* getCreator() const = 0;
+
 		YAKE_MEMBERSIGNAL_PUREINTERFACE( public, void(void), OnBreaking )
 	public:
 

Modified: trunk/yake/yake/plugins/graphicsOgre/graphicsOgreNode.h
===================================================================
--- trunk/yake/yake/plugins/graphicsOgre/graphicsOgreNode.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/plugins/graphicsOgre/graphicsOgreNode.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -80,6 +80,8 @@
 		virtual void detach( IParticleSystem* pPS );
 		virtual void detach( ISceneNode* pNode );
 
+		virtual ISceneNode* getParent() const;
+
 		Ogre::SceneNode* getSceneNode_() const
 		{ return mSceneNode; }
 		void _setParent( OgreNode* );

Modified: trunk/yake/yake/plugins/graphicsOgre/yakeGraphicsWorld.h
===================================================================
--- trunk/yake/yake/plugins/graphicsOgre/yakeGraphicsWorld.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/plugins/graphicsOgre/yakeGraphicsWorld.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -102,6 +102,11 @@
 		Ogre::SceneManager* getSceneMgr() const;
 		OgreCore* getCore() const
 		{ return msCore; }
+
+		inline bool isRoot(OgreNode* node) const
+		{
+			return (node == mRootNode);
+		}
 	private:
 		static OgreCore*		msCore;
 		typedef AssocVector< String, Ogre::MeshPtr > ProcMeshMap;

Modified: trunk/yake/yake/plugins/physicsODE/OdeJoint.h
===================================================================
--- trunk/yake/yake/plugins/physicsODE/OdeJoint.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/plugins/physicsODE/OdeJoint.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -44,6 +44,9 @@
 		public:
 			virtual ~OdeJoint();
 
+			virtual IWorld* getCreator() const
+			{ return mWorld; }
+
 			/** Attach joint to bodies. If one of the bodies is 0, then attach
 			 * to static environment.
 			 */

Added: trunk/yake/yake/samples/model/dotScene/pch.h
===================================================================
--- trunk/yake/yake/samples/model/dotScene/pch.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/samples/model/dotScene/pch.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,14 @@
+//============================================================================
+//    IMPLEMENTATION HEADERS
+//============================================================================
+// STL
+#include <iostream>
+// Yake
+#include <yake/base/yake.h>
+#include <yake/base/yakeLog.h>
+#include <yake/base/yakeLibrary.h>
+#include <yake/scripting/yakeScriptingSystem.h>
+#include <yake/graphics/yakeGraphicsSystem.h>
+
+#include <yake/samples/common/yakeExampleApplication.h>
+#include <yake/data/yakeData.h>

Added: trunk/yake/yake/samples/net/common/common.h
===================================================================
--- trunk/yake/yake/samples/net/common/common.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/samples/net/common/common.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,45 @@
+#ifndef TEST_COMMON_H
+#define TEST_COMMON_H
+
+#include <conio.h>
+#include <cassert>
+#include <iostream>
+#include <sstream>
+#include <boost/thread/mutex.hpp>
+#include "config.h"
+
+#define COUTLN(X) \
+{ \
+	std::stringstream ss; \
+	ss << X << "\n"; \
+	std::cout << ss.str(); \
+}
+
+template<typename T>
+struct safe_var
+{
+	safe_var(const T& v = T()) : value_(v)
+	{}
+	void set(const T& v)
+	{
+		boost::mutex::scoped_lock lck(mtx_);
+		value_ = v;
+	}
+	T getCopy() const
+	{
+		boost::mutex::scoped_lock lck(mtx_);
+		return value_;
+	}
+	safe_var& operator = (const safe_var& rhs)
+	{
+		if (this == &rhs)
+			return *this;
+		set( rhs.getCopy() );
+		return *this;
+	}
+private:
+	T						value_;
+	mutable boost::mutex	mtx_;
+};
+
+#endif

Added: trunk/yake/yake/samples/net/common/commonEvents.h
===================================================================
--- trunk/yake/yake/samples/net/common/commonEvents.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/samples/net/common/commonEvents.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,149 @@
+#ifndef TEST_COMMONEVENTS_H
+#define TEST_COMMONEVENTS_H
+
+#include <map>
+
+const net::ChannelId CHANNELID_CONTROL = 0;
+const net::ChannelId CHANNELID_SIMCTRL = 1;
+const net::ChannelId CHANNELID_SIMUPD  = 2;
+
+//---
+/*
+// pull in types
+typedef net::INetEventConnection::CreateEventFn CreateEventFn;
+typedef net::INetEventConnection::DestroyEventFn DestroyEventFn;
+
+// event pool
+struct EventPool
+{
+	EventPool();
+	~EventPool();
+	void register_class(const net::NetEvent::id_type id, const CreateEventFn&, const DestroyEventFn&);
+	{
+		classes_.insert( std::make_pair( id, ClassEntry(createFn,destroyFn) ) );
+	}
+	net::NetEvent* create(const net::NetEvent::id_type);
+	void destroy(net::NetEvent*);
+	void lookup(const net::NetEvent::id_type id, CreateEventFn&, DestroyEventFn&);
+private:
+	typedef std::deque<net::NetEvent*> EventList;
+	struct ClassEntry
+	{
+		CreateEventFn	createFn_;
+		DestroyEventFn	destroyFn_;
+		EventList		avail_;
+		EventList		taken_;
+	};
+	typedef std::map<net::NetEvent::id_type,ClassEntry> ClassMap; //<= perfect candidate for AssocVector
+	ClassMap		classes_;
+};
+
+// event registrator for use with pooled events and event connections
+template<typename evt_type>
+bool s_registerEvent(const EventPool& evtpool,
+							const net::IEventConnection& conn,
+							const net::NetEvent::id_type id,
+							const net::NetEvent::Direction dir)
+{
+	CreateEventFn createFn = boost::bind(&EventPool::create,&evtpool,_1);
+	DestroyEventFn destroyFn = boost::bind(&EventPool::destroy,&evtpool,_1);;
+	conn.registerEvent(id,dir,ce.createFn,ce.destroyFn);
+}
+*/
+//---
+
+#define DECLARE_EVENT(CLASS,IDVALUE) \
+public: \
+static net::NetEvent* create(net::NetEvent::id_type id) \
+{ CLASS* p = new CLASS(); p->setId(id); return p; } \
+static void destroy(net::NetEvent* p) { delete p; } \
+static const net::NetEvent::id_type ID = IDVALUE; \
+CLASS() : net::NetEvent(ID) \
+{}
+
+struct version_t
+{
+	net::uint8 ver[3];
+	version_t(const net::uint8 maj = 0, const net::uint8 min = 0, const net::uint8 b = 0)
+	{
+		ver[0] = maj;
+		ver[1] = min;
+		ver[2] = b;
+	}
+};
+inline net::obitstream& operator << (net::obitstream& out, const version_t& rhs)
+{
+	out.write( rhs.ver[0], 8 );
+	out.write( rhs.ver[1], 8  );
+	out.write( rhs.ver[2], 8  );
+	return out;
+}
+inline net::ibitstream& operator >> (net::ibitstream& in, version_t& rhs)
+{
+	in.read( rhs.ver[0], 8 );
+	in.read( rhs.ver[1], 8 );
+	in.read( rhs.ver[2], 8 );
+	return in;
+}
+
+struct c2sEvtJoinReq : public net::NetEvent
+{
+	DECLARE_EVENT( c2sEvtJoinReq, 1 );
+	virtual bool pack(net::obitstream& out) const
+	{
+		out << version;;
+		return true;
+	}
+	virtual bool unpack(net::ibitstream& in)
+	{
+		in >> version;
+		return true;
+	}
+	version_t	version;
+};
+struct s2cEvtJoinReqReply : public net::NetEvent
+{
+	DECLARE_EVENT( s2cEvtJoinReqReply, 2 );
+	virtual bool pack(net::obitstream& out) const
+	{
+		out.write( accepted );
+		return true;
+	}
+	virtual bool unpack(net::ibitstream& in)
+	{
+		in.read( accepted );
+		return true;
+	}
+	bool accepted;
+};
+struct s2cEvtClassTable : public net::NetEvent
+{
+	DECLARE_EVENT( s2cEvtClassTable, 10 );
+	virtual bool pack(net::obitstream& out) const
+	{
+		//out << globalClassIds_;
+		return true;
+	}
+	virtual bool unpack(net::ibitstream& in)
+	{
+		//in >> globalClassIds_;
+		return true;
+	}
+	//uint8 numClassIdBits_;
+	std::map<std::string,net::uint16> globalClassIds_;
+};
+struct c2sEvtSimOk : public net::NetEvent
+{
+	DECLARE_EVENT( c2sEvtSimOk, 11 );
+	virtual bool pack(net::obitstream& out) const
+	{
+		return true;
+	}
+	virtual bool unpack(net::ibitstream& in)
+	{
+		return true;
+	}
+};
+
+
+#endif
\ No newline at end of file

Added: trunk/yake/yake/samples/net/common/config.h
===================================================================
--- trunk/yake/yake/samples/net/common/config.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yake/samples/net/common/config.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -0,0 +1,8 @@
+#ifndef YAKE_NET_SAMPLES_CONFIG_H
+#define YAKE_NET_SAMPLES_CONFIG_H
+
+
+#define NET_STRESS_TEST_LEVEL 1
+
+
+#endif
\ No newline at end of file

Modified: trunk/yake/yapp/model/yakePhysicalDataImporter.h
===================================================================
--- trunk/yake/yapp/model/yakePhysicalDataImporter.h	2006-06-09 17:00:57 UTC (rev 1327)
+++ trunk/yake/yapp/model/yakePhysicalDataImporter.h	2006-06-09 21:47:29 UTC (rev 1328)
@@ -61,10 +61,8 @@
 
 	    IJoint* getJointByName( const String& name )
 	    {
-		if ( joints_.find( name ) != joints_.end() )
-		    return joints_[ name ].joint_;
-		else
-		    return NULL;
+			JointMap::const_iterator it = joints_.find( name );
+			return (it == joints_.end()) ? 0 : it->second.joint_;
 	    }
 
 	protected:



From codeandroid at berlios.de  Fri Jun  9 23:48:36 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Fri, 9 Jun 2006 23:48:36 +0200
Subject: [Yake-svn] r1329 - in trunk/yake/common/bin: debug release
Message-ID: <200606092148.k59LmaF6025006@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-09 23:48:35 +0200 (Fri, 09 Jun 2006)
New Revision: 1329

Modified:
   trunk/yake/common/bin/debug/yake.graphics.ogre_plugins.cfg
   trunk/yake/common/bin/release/yake.graphics.ogre_plugins.cfg
Log:
disabled D3D7 renderer plugin

Modified: trunk/yake/common/bin/debug/yake.graphics.ogre_plugins.cfg
===================================================================
--- trunk/yake/common/bin/debug/yake.graphics.ogre_plugins.cfg	2006-06-09 21:47:29 UTC (rev 1328)
+++ trunk/yake/common/bin/debug/yake.graphics.ogre_plugins.cfg	2006-06-09 21:48:35 UTC (rev 1329)
@@ -1,6 +1,6 @@
 PluginFolder=OgrePlugins
 Plugin=RenderSystem_Direct3D9.dll
-Plugin=RenderSystem_Direct3D7.dll
+#Plugin=RenderSystem_Direct3D7.dll
 Plugin=RenderSystem_GL.dll
 Plugin=Plugin_OctreeSceneManager.dll
 Plugin=Plugin_ParticleFX.dll

Modified: trunk/yake/common/bin/release/yake.graphics.ogre_plugins.cfg
===================================================================
--- trunk/yake/common/bin/release/yake.graphics.ogre_plugins.cfg	2006-06-09 21:47:29 UTC (rev 1328)
+++ trunk/yake/common/bin/release/yake.graphics.ogre_plugins.cfg	2006-06-09 21:48:35 UTC (rev 1329)
@@ -1,6 +1,6 @@
 PluginFolder=OgrePlugins
 Plugin=RenderSystem_Direct3D9.dll
-Plugin=RenderSystem_Direct3D7.dll
+#Plugin=RenderSystem_Direct3D7.dll
 Plugin=RenderSystem_GL.dll
 Plugin=Plugin_OctreeSceneManager.dll
 Plugin=Plugin_ParticleFX.dll



From codeandroid at berlios.de  Sat Jun 10 00:03:42 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Sat, 10 Jun 2006 00:03:42 +0200
Subject: [Yake-svn] r1330 - in trunk/yake: src/yake/plugins/physicsODE yake/plugins/physicsODE
Message-ID: <200606092203.k59M3gd0026295@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-10 00:03:41 +0200 (Sat, 10 Jun 2006)
New Revision: 1330

Modified:
   trunk/yake/src/yake/plugins/physicsODE/OdeJoint.cpp
   trunk/yake/yake/plugins/physicsODE/OdeJoint.h
Log:
fix

Modified: trunk/yake/src/yake/plugins/physicsODE/OdeJoint.cpp
===================================================================
--- trunk/yake/src/yake/plugins/physicsODE/OdeJoint.cpp	2006-06-09 21:48:35 UTC (rev 1329)
+++ trunk/yake/src/yake/plugins/physicsODE/OdeJoint.cpp	2006-06-09 22:03:41 UTC (rev 1330)
@@ -51,6 +51,12 @@
 	}
 	
 	//-----------------------------------------------------
+	IWorld* OdeJoint::getCreator() const
+	{
+		return mWorld; 
+	}
+
+	//-----------------------------------------------------
 	void OdeJoint::attach( IBody* pBody1, IBody* pBody2 )
 	{
 		YAKE_ASSERT( pBody1 != 0 || pBody2 != 0 ).error( "both bodies are ZERO in joint attach function!" );

Modified: trunk/yake/yake/plugins/physicsODE/OdeJoint.h
===================================================================
--- trunk/yake/yake/plugins/physicsODE/OdeJoint.h	2006-06-09 21:48:35 UTC (rev 1329)
+++ trunk/yake/yake/plugins/physicsODE/OdeJoint.h	2006-06-09 22:03:41 UTC (rev 1330)
@@ -44,8 +44,7 @@
 		public:
 			virtual ~OdeJoint();
 
-			virtual IWorld* getCreator() const
-			{ return mWorld; }
+			virtual IWorld* getCreator() const;
 
 			/** Attach joint to bodies. If one of the bodies is 0, then attach
 			 * to static environment.



From codeandroid at berlios.de  Mon Jun 12 23:23:50 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Mon, 12 Jun 2006 23:23:50 +0200
Subject: [Yake-svn] r1331 - trunk/yake/scripts/msvc8/plugins/physics
Message-ID: <200606122123.k5CLNohX023094@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-12 23:23:50 +0200 (Mon, 12 Jun 2006)
New Revision: 1331

Modified:
   trunk/yake/scripts/msvc8/plugins/physics/physicsODE.vcproj
Log:
now using ode 0.6

Modified: trunk/yake/scripts/msvc8/plugins/physics/physicsODE.vcproj
===================================================================
--- trunk/yake/scripts/msvc8/plugins/physics/physicsODE.vcproj	2006-06-09 22:03:41 UTC (rev 1330)
+++ trunk/yake/scripts/msvc8/plugins/physics/physicsODE.vcproj	2006-06-12 21:23:50 UTC (rev 1331)
@@ -63,10 +63,10 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="oded.lib physics.lib"
+				AdditionalDependencies="ode.lib physics.lib"
 				OutputFile="$(OutDir)/$(ProjectName).dll"
 				LinkIncremental="2"
-				AdditionalLibraryDirectories="../../../../common/lib/debug;../../../../dependencies/ode/lib;../../../../dependencies/lib"
+				AdditionalLibraryDirectories="../../../../common/lib/debug;../../../../dependencies/ode/lib/debugdll;../../../../dependencies/lib"
 				ModuleDefinitionFile=""
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
@@ -148,7 +148,7 @@
 				AdditionalDependencies="ode.lib physics.lib"
 				OutputFile="$(OutDir)/$(ProjectName).dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="../../../../common/lib/release;../../../../dependencies/ode/lib;../../../../dependencies/lib"
+				AdditionalLibraryDirectories="../../../../common/lib/release;../../../../dependencies/ode/lib/releasedll;../../../../dependencies/lib"
 				GenerateDebugInformation="false"
 				SubSystem="2"
 				OptimizeReferences="2"



From codeandroid at berlios.de  Mon Jun 12 23:25:29 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Mon, 12 Jun 2006 23:25:29 +0200
Subject: [Yake-svn] r1332 - trunk/yake/src/yake/plugins/physicsODE
Message-ID: <200606122125.k5CLPTRK023297@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-12 23:25:29 +0200 (Mon, 12 Jun 2006)
New Revision: 1332

Modified:
   trunk/yake/src/yake/plugins/physicsODE/OdeShapes.cpp
Log:
now using ode 0.6

Modified: trunk/yake/src/yake/plugins/physicsODE/OdeShapes.cpp
===================================================================
--- trunk/yake/src/yake/plugins/physicsODE/OdeShapes.cpp	2006-06-12 21:23:50 UTC (rev 1331)
+++ trunk/yake/src/yake/plugins/physicsODE/OdeShapes.cpp	2006-06-12 21:25:29 UTC (rev 1332)
@@ -367,7 +367,7 @@
 		YAKE_ASSERT( radius > 0 ).error( "Radius should be invalid!" );
 		YAKE_ASSERT( length > 0 ).error( "Length should be positive!" );
 
-		mOdeGeom = new dCCylinder( mOdeSpace->id(), static_cast<dReal>( radius ), static_cast<dReal>( length ) );
+		mOdeGeom = new dCapsule( mOdeSpace->id(), static_cast<dReal>( radius ), static_cast<dReal>( length ) );
 
 		mOdeGeomID = mOdeGeom->id();
 



From codeandroid at berlios.de  Mon Jun 12 23:26:14 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Mon, 12 Jun 2006 23:26:14 +0200
Subject: [Yake-svn] r1333 - trunk/yake/src/yake/samples/model/dotScene
Message-ID: <200606122126.k5CLQEhE023409@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-12 23:26:14 +0200 (Mon, 12 Jun 2006)
New Revision: 1333

Modified:
   trunk/yake/src/yake/samples/model/dotScene/demo.cpp
Log:
added physics and dotLink support

Modified: trunk/yake/src/yake/samples/model/dotScene/demo.cpp
===================================================================
--- trunk/yake/src/yake/samples/model/dotScene/demo.cpp	2006-06-12 21:25:29 UTC (rev 1332)
+++ trunk/yake/src/yake/samples/model/dotScene/demo.cpp	2006-06-12 21:26:14 UTC (rev 1333)
@@ -16,17 +16,18 @@
 
 using namespace yake;
 
-class TheApp : public yake::exapp::ExampleApplication
+class TheApp : public yake::exapp::ExampleApplication, public yake::model::CentralControllerBase
 {
 private:
 	typedef std::pair<graphics::IViewport*,graphics::ICamera*> ViewportCameraPair;
 	Vector<ViewportCameraPair >			mVPs;
 	SharedPtr< graphics::IWorld >		mGWorld;
+	SharedPtr< physics::IWorld >		mPWorld;
 
 public:
 	TheApp() : ExampleApplication(
 					true /*graphics*/,
-					false /*physics*/,
+					true /*physics*/,
 					false /*scripting*/,
 					true /*input*/,
 					false /*script bindings*/,
@@ -78,6 +79,11 @@
 		mKeyboardEventGenerator.subscribeToKeyDown( Bind1( &TheApp::onKey, this ) );
 		mMouseEventGenerator.subscribeToMouseButtonDown( Bind1( &TheApp::onMB, this ) );
 
+		// physics
+		mPWorld = getPhysicsSystem().createWorld();
+		YAKE_ASSERT( mPWorld );
+		mPWorld->setGlobalGravity( Vector3(0,-1,0) );
+
 		// graphics
 		mGWorld = getGraphicsSystem().createWorld();
 		YAKE_ASSERT( mGWorld );
@@ -117,13 +123,19 @@
 		//mGWorld->setShadowsEnabled( true );
 		model::ModelManager modelMgr;
 		modelMgr.setCreationContext_GraphicalWorld( mGWorld.get() );
+		modelMgr.setCreationContext_PhysicalWorld( mPWorld.get() );
+		modelMgr.setCreationContext_CentralController( this );
 
-		model::Model* m = modelMgr.createModel("graphics/dotScene:name=gfx1;file=../../media/samples/dotScene/DotScene1.scene");
+		model::Model* m = modelMgr.createModel("m1","graphics/dotScene:name=gfx;file=../../media/samples/dotScene/DotScene1.scene");
 		YAKE_ASSERT( m );
+		((model::Graphical*)m->getComponentByTag("gfx"))->translate(Vector3(40,20,0));
 
-		m = modelMgr.createModel("graphics/dotScene:name=gfx2;file=../../media/samples/dotScene/DotScene1.scene");
+		m = modelMgr.createModel("m2",
+			"graphics/dotScene:name=baseGraphical;file=../../media/samples/dotLink/DynTest/DotScene1.scene"
+			"|physics/dotXODE:name=basePhysical;file=../../media/samples/dotLink/DynTest/DotScene1.xode"
+			"|model/dotLink:file=../../media/samples/dotLink/DynTest/DotScene1.link"
+			);
 		YAKE_ASSERT( m );
-		((model::Graphical*)m->getComponentByTag("gfx2"))->translate(Vector3(40,20,0));
 
 		// main loop
 		real lastTime = native::getTime();
@@ -155,12 +167,21 @@
 					mVPs[iCam].second->translate( Vector3(0, 0, -distance) );
 			}
 
-			// render the scene
+			// run sim & render the scene
 			if (!shutdownRequested())
+			{
+				mPWorld->step( timeElapsed );
+				triggerPhysicsUpdateSignal(0,timeElapsed);
+				triggerGraphicsUpdateSignal(0,timeElapsed);
+
 				mGWorld->render( timeElapsed );
+			}
 		}
 
+		modelMgr.clear();
+
 		mGWorld.reset();
+		mPWorld.reset();
 	}
 };
 



From codeandroid at berlios.de  Mon Jun 12 23:27:16 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Mon, 12 Jun 2006 23:27:16 +0200
Subject: [Yake-svn] r1334 - in trunk/yake/src/yake: loader model
Message-ID: <200606122127.k5CLRGD2023521@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-12 23:27:15 +0200 (Mon, 12 Jun 2006)
New Revision: 1334

Added:
   trunk/yake/src/yake/loader/yakeXODEParser.cpp
   trunk/yake/src/yake/model/yakeDotLinkLoader.cpp
   trunk/yake/src/yake/model/yakeLinkCreator.cpp
   trunk/yake/src/yake/model/yakeModelLink.cpp
   trunk/yake/src/yake/model/yakeModelMovableLink.cpp
   trunk/yake/src/yake/model/yakePhysicalCreator.cpp
   trunk/yake/src/yake/model/yakeXODEListener.cpp
Modified:
   trunk/yake/src/yake/model/yakeComponentCreatorManager.cpp
   trunk/yake/src/yake/model/yakeGraphical.cpp
   trunk/yake/src/yake/model/yakeGraphicalCreator.cpp
   trunk/yake/src/yake/model/yakeModel.cpp
   trunk/yake/src/yake/model/yakeModelManager.cpp
   trunk/yake/src/yake/model/yakePhysical.cpp
Log:
added physics/XODE and model/dotLink support

Added: trunk/yake/src/yake/loader/yakeXODEParser.cpp
===================================================================
--- trunk/yake/src/yake/loader/yakeXODEParser.cpp	2006-06-12 21:26:14 UTC (rev 1333)
+++ trunk/yake/src/yake/loader/yakeXODEParser.cpp	2006-06-12 21:27:15 UTC (rev 1334)
@@ -0,0 +1,1169 @@
+/*
+	 ------------------------------------------------------------------------------------
+	 This file is part of YAKE
+	 Copyright	2004 The YAKE Team
+	 For the latest information visit http://www.yake.org 
+	 ------------------------------------------------------------------------------------
+	 This program is free software; you can redistribute it and/or modify it under
+	 the terms of the GNU Lesser General Public License as published by the Free Software
+	 Foundation; either version 2 of the License, or (at your option) any later
+	 version.
+ 
+	 This program is distributed in the hope that it will be useful, but WITHOUT
+	 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+	 FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+ 
+	 You should have received a copy of the GNU Lesser General Public License along with
+	 this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+	 Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+	 http://www.gnu.org/copyleft/lesser.txt.
+	 ------------------------------------------------------------------------------------
+	 If you are interested in another license model contact the Yake Team via
+	 E-Mail: team at yake.org.
+	 For more information see the LICENSE file in the root directory of the
+	 source code distribution.
+	 ------------------------------------------------------------------------------------
+*/
+#include <yake/loader/pch.h>
+#include <yake/loader/loader.h>
+
+namespace yake {
+namespace data {
+namespace parser {
+namespace xode {
+    using namespace physics;
+
+    //------------------------------------------------------
+    XODEParser::XODEParser() 
+    {}
+
+    //------------------------------------------------------
+    bool XODEParser::load( const NodeSharedPtr docNode )
+    {
+		YAKE_LOG( "XODE: load()" );
+
+		YAKE_ASSERT( docNode.get() );
+
+		mDocNode = docNode;
+
+		YAKE_LOG( "*******************" );
+		YAKE_LOG( "* Parsing xode... *" );
+		YAKE_LOG( "*******************" );
+
+		readXODE( mDocNode );
+
+		return true;
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readXODE( const NodeSharedPtr pNode )
+    {
+		YAKE_ASSERT( pNode );
+
+		const String name = pNode->getAttributeValueAs<String>( "name" );
+		YAKE_LOG( "XODE: parsing " + name );
+
+		// Assuming single world in .xode
+		NodeSharedPtr pWorldNode = pNode->getNodeByName( "world" );
+		YAKE_ASSERT( pWorldNode );
+
+		YAKE_LOG( "XODE: finding world ... " + String( pWorldNode.get() ? "Yes!" : "No :(" ) );
+
+		readWorld( pWorldNode );
+
+		// parse completed. Firing signal!
+		sigParseEnded_();
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readWorld( const NodeSharedPtr pWorldNode )
+    {
+	// Assuming single space in <world>
+	NodeSharedPtr pSpaceNode = pWorldNode->getNodeByName( "space" );
+	YAKE_ASSERT( pSpaceNode );
+
+	YAKE_LOG( "XODE: finding space... " + String( pSpaceNode.get() ? "Yes!" : "No :(" ) );
+
+	readSpace( pSpaceNode, "world" );
+    }
+
+    //------------------------------------------------------
+    void XODEParser::reset()
+    {
+	//TODO is this really needed?
+	mDocNode.reset();
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readSpace( const NodeSharedPtr pSpaceNode, const String& parent )
+    {
+	YAKE_LOG( "XODE: reading space ..." );
+
+	const dom::NodeList& nodes = pSpaceNode->getNodes();
+	for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
+	{
+	    String nodeName =
+		yake::StringUtil::toLowerCase( (*it)->getName() );
+
+	    if ( nodeName == "body" )
+	    {
+		readBody( *it, parent );
+	    }
+	    else if ( nodeName == "geom" )
+	    {
+		readGeom( *it, parent );
+	    }
+	    else if ( nodeName == "bodygroup" )
+	    {
+		//TODO bodygroup reading here
+		YAKE_LOG( "XODE: Bodygroup is not yet implemented in parser" ); 
+	    }
+	    else if ( nodeName == "joint" )
+	    {
+		readJoint( *it, parent );
+	    }
+	}
+    }
+
+    /// Utility functor for use with std::find_if
+    //------------------------------------------------------
+    class NodeHunter : public std::unary_function<XODEParser::NodeSharedPtr&,bool>
+    {
+	public:
+	    NodeHunter( const String& rNodeName ) : nodeName_( rNodeName )
+	    {}
+
+	    bool operator()( const XODEParser::NodeSharedPtr& pNode )
+	    {
+		return pNode->getName() == nodeName_;
+	    }
+
+	private:
+	    String nodeName_;
+    };
+
+    //------------------------------------------------------
+    void XODEParser::readVector3( const NodeSharedPtr pVecNode, math::Vector3& rVec )
+    {
+	real x = StringUtil::parseReal( pVecNode->getAttributeValueAs<String>( "x" ) );
+	real y = StringUtil::parseReal( pVecNode->getAttributeValueAs<String>( "y" ) );
+	real z = StringUtil::parseReal( pVecNode->getAttributeValueAs<String>( "z" ) );
+
+	rVec = math::Vector3( x, y, z );
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readScale( const NodeSharedPtr pScaleNode, math::Vector3& rScale )
+    {
+	readVector3( pScaleNode, rScale );
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readPosition( const NodeSharedPtr pPosNode, math::Vector3& rPos )
+    {
+	readVector3( pPosNode, rPos );
+    }
+
+    //------------------------------------------------------
+    /**
+     * Reads quaternion from pQuatNode to rQuat
+     * Ignores aformat attribute
+     * @param pQuatNode
+     * @param rQuat
+     */
+    void XODEParser::readQuaternion( const NodeSharedPtr pQuatNode, math::Quaternion& rQuat )
+    {
+	real x = StringUtil::parseReal( pQuatNode->getAttributeValueAs<String>( "x" ) );
+	real y = StringUtil::parseReal( pQuatNode->getAttributeValueAs<String>( "y" ) );
+	real z = StringUtil::parseReal( pQuatNode->getAttributeValueAs<String>( "z" ) );
+	real w = StringUtil::parseReal( pQuatNode->getAttributeValueAs<String>( "w" ) );
+
+	rQuat = math::Quaternion( w, x, y, z );
+    }
+
+    //------------------------------------------------------
+    /**
+     *	Reads angle and axis x, y, z attributes and spawns quaternion with them in rRot
+     * @param pRotNode
+     * @param rRot
+     */
+    void XODEParser::readAxisAngleRot( const NodeSharedPtr pRotNode, math::Quaternion& rRot )
+    {
+	real x = StringUtil::parseReal( pRotNode->getAttributeValueAs<String>( "x" ) );
+	real y = StringUtil::parseReal( pRotNode->getAttributeValueAs<String>( "y" ) );
+	real z = StringUtil::parseReal( pRotNode->getAttributeValueAs<String>( "z" ) );
+	real angle = StringUtil::parseReal( pRotNode->getAttributeValueAs<String>( "angle" ) );
+
+	rRot.FromAngleAxis( angle, math::Vector3( x, y, z ) );
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readRotation( const NodeSharedPtr pRotNode, math::Quaternion& rRot )
+    {
+	const dom::NodeList& nodes = pRotNode->getNodes();
+
+	for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
+	{
+	    String nodeName = StringUtil::toLowerCase( (*it)->getName() );
+
+	    if ( nodeName == "quaternion" )
+	    {
+		readQuaternion( *it, rRot );
+	    }
+	    else if ( nodeName == "euler" )
+	    {
+		YAKE_ASSERT( false ).error( "euler is NYI" );
+	    }
+	    else if ( nodeName == "axisangle" )
+	    {
+		readAxisAngleRot( *it, rRot );
+	    }
+	}
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readTransform( const NodeSharedPtr pTransformNode, Transform& rTrans )
+    {
+	const dom::NodeList& nodes = pTransformNode->getNodes();
+
+	for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
+	{
+	    String nodeName =
+		StringUtil::toLowerCase( (*it)->getName() );
+
+	    if ( nodeName == "position" )
+	    {
+		readPosition( *it, rTrans.position_ );
+	    }
+	    else if ( nodeName == "rotation" )
+	    {
+		readRotation( *it, rTrans.rotation_ );
+	    }
+	    else if ( nodeName == "scale" )
+	    {
+		readScale( *it, rTrans.scale_ );
+	    }
+	    else if ( nodeName == "matrix4f" )
+	    {
+		YAKE_ASSERT( false ).error( "matrix4f is NYI" );
+	    }
+	}
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readMassShape( const NodeSharedPtr pMShapeNode, const String& parent,
+	    const Transform& rParentTransform )
+    {
+	real density = 0; //default ...
+
+	// if density is provided...
+	String strDensity = pMShapeNode->getAttributeValueAs<String>( "density" );
+	if ( !strDensity.empty() ) 
+	{
+	    density = StringUtil::parseReal( strDensity );
+	    YAKE_LOG( "XODE: reading mass_shape with density = " + strDensity + " " );
+	}
+
+	const dom::NodeList& nodes = pMShapeNode->getNodes();
+	for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it)
+	{
+	    String nodeName = StringUtil::toLowerCase( (*it)->getName() );
+
+	    YAKE_LOG( "XODE: reading mass_shape that is " + nodeName + " " );
+
+	    IBody::MassDesc* physicsMassDesc = NULL;
+
+	    if ( nodeName == "cylinder" )
+	    {
+		real radius, length;
+		readCylinder( *it, radius, length );
+
+		physicsMassDesc = new IBody::CylinderMassDesc( radius, length, density,
+			rParentTransform.position_,
+			IBody::QT_DENSITY );
+	    }
+	    else if ( nodeName == "sphere" )
+	    {
+		real radius; readSphere( *it, radius );
+
+		physicsMassDesc = new IBody::SphereMassDesc(radius, density,
+			rParentTransform.position_,
+			IBody::QT_DENSITY );
+	    }
+	    else if ( nodeName == "box" )
+	    {
+		real sX, sY, sZ;
+		readBox( *it, sX, sY, sZ );
+
+		physicsMassDesc = new IBody::BoxMassDesc( sX, sY, sZ, density,
+			rParentTransform.position_,
+			IBody::QT_DENSITY );
+	    }
+	    else if ( nodeName == "cappedCylinder" )
+	    {
+		real radius, length;
+		readCappedCylinder( *it, radius, length );
+
+		physicsMassDesc = new IBody::CapsuleMassDesc( radius, length, density,
+			rParentTransform.position_,
+			IBody::QT_DENSITY );
+	    }
+
+	    if ( physicsMassDesc != NULL )
+	    {
+
+		MassDesc desc;
+		desc.mass_.reset( physicsMassDesc );
+		desc.parentName_ = parent;
+
+		// TODO set the other mass params!
+		// parent name, etc.
+		sigMass_( desc );
+		// TODO needed?? massDescriptions_[ name ] = desc;
+	    }
+	}
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readMassAdjust( const NodeSharedPtr pMAdjustNode, const String& parent )
+    {
+	real total = StringUtil::parseReal( pMAdjustNode->getAttributeValueAs<String>( "total" ) );
+
+	YAKE_LOG_INFORMATION( "XODE: read mass adjust - " + pMAdjustNode->getAttributeValueAs<String>( "total" ) );
+
+	MassDesc desc;
+	desc.parentName_ = parent;
+	desc.mass_.reset( new IBody::MassDesc( total, math::Vector3::kZero, IBody::QT_MASS ) );
+
+	sigMass_( desc );
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readMass( const NodeSharedPtr pMassNode, const String& parent, const Transform& rParentTransform )
+    {
+	const dom::NodeList& nodes = pMassNode->getNodes();
+
+	// Seek transform
+	Transform massTransform;
+
+	NodeHunter hunter( "transform" );
+	NodeListIter iTrans =
+	    std::find_if<NodeListIter,NodeHunter>( nodes.begin(), nodes.end(), hunter );
+
+	if ( iTrans != nodes.end() )
+	{
+	    readTransform( *iTrans, massTransform );
+	}
+
+	if ( !rParentTransform.isIdentity() )
+	{
+	    massTransform = massTransform.getDerivedTransform( rParentTransform );
+	}
+
+	for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it)
+	{
+	    String nodeName =
+		StringUtil::toLowerCase( (*it)->getName() );
+
+	    if ( nodeName == "mass_shape" )
+	    {
+		readMassShape( *it, parent, massTransform );
+	    }
+	    else if ( nodeName == "adjust" )
+	    {
+		readMassAdjust( *it, parent );
+	    }
+	    else if ( nodeName == "mass" )
+	    {
+		readMass( *it, parent, massTransform );
+	    }
+	}
+
+    }
+
+    //------------------------------------------------------
+    // This method is called on any unknown extension
+    void XODEParser::readExtension( const NodeSharedPtr, 
+	    const String& parent, 
+	    const Transform& parentTransformIfAny )
+    {
+	// this virtual method should be overriden by any parser that wants to parse xode extensions
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readBody( const NodeSharedPtr pBodyNode, const String& parent )
+    {
+	const String name = pBodyNode->getAttributeValueAs<String>( "name" );
+	YAKE_LOG( "XODE: reading body " + name );
+
+	// Setting up body description...
+	BodyDesc desc;
+	desc.name_ = name;
+	desc.parentName_ = parent;
+
+	const dom::NodeList& nodes = pBodyNode->getNodes();
+
+	// Seek transform
+	NodeHunter hunter( "transform" );
+	NodeListIter iTrans =
+	    std::find_if<NodeListIter,NodeHunter>( nodes.begin(), nodes.end(), hunter );
+
+	Transform bodyTransform;
+	if ( iTrans != nodes.end() )
+	{
+	    YAKE_LOG( "XODE: body " + name + " has transform " );
+
+	    readTransform( *iTrans, bodyTransform );
+
+	    if ( !bodyTransform.isIdentity() )
+	    {
+		desc.transform_ = bodyTransform;
+	    }
+	}
+
+	// fire signal!
+	sigBody_( desc );
+	// TODO add to collection?
+
+	for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
+	{
+	    String nodeName = StringUtil::toLowerCase( (*it)->getName() );
+
+	    YAKE_LOG( "XODE: body " + name + " has node #" + nodeName );
+
+	    if ( nodeName == "geom" )
+	    {
+		readGeom( *it, name, bodyTransform );
+	    }
+	    else if ( nodeName == "mass" )
+	    {
+		readMass( *it, name, bodyTransform );
+	    }
+	    else if ( nodeName == "joint" )
+	    {
+		readJoint( *it, name, bodyTransform );
+	    }
+	    else if ( nodeName == "ext" )
+	    {
+		readExtension( *it, name, bodyTransform );
+	    }
+	}
+    }
+
+    //------------------------------------------------------
+    /**
+     *	 Searches for <ext name="material"> node, parses it, creates material and returns ptr to created material
+     * If no node, returns NULL
+     * @param pNode - node to search
+     */
+    void XODEParser::readMaterialExt( const NodeSharedPtr pNode, const String& parent )
+    {
+	YAKE_LOG( "XODE: entered readMaterialExt..." );
+
+	const dom::NodeList& nodes = pNode->getNodes();
+
+	// Looking for ext
+	// TODO maybe we need some advanced searching here?
+	// like finding all ext nodes or finding <ext name="material">?
+	// For now finding ext would be enough
+	NodeHunter hunter( "ext" );
+	NodeListIter iExt =
+	    std::find_if<NodeListIter,NodeHunter>( nodes.begin(), nodes.end(), hunter );
+
+	if ( iExt == nodes.end() )
+	{
+	    YAKE_LOG( "XODE: didn't find extension... " );
+	    return;
+	}
+
+	YAKE_LOG( "XODE: found extension... processing... :) " );
+
+	if ( (*iExt)->getAttributeValueAs<String>( "name" ) != "material" )
+	{
+	    YAKE_LOG( "XODE: extension is not material" );
+	}
+
+	YAKE_LOG( "XODE: the extension IS material! Parsing..." );
+
+	const dom::NodeList& extNodes = (*iExt)->getNodes();
+	//HACK assuming first node is "params"
+	NodeSharedPtr pParamsNode = *extNodes.begin();
+
+	// parsing
+	IMaterial::Desc desc;
+
+	String strFriction = pParamsNode->getAttributeValueAs<String>( "friction" );
+	String strRestitution = pParamsNode->getAttributeValueAs<String>( "bouncecoeff" );
+	String strSoftness = pParamsNode->getAttributeValueAs<String>( "soften" );
+
+	YAKE_LOG( "XODE: read friction = " + strFriction );
+	YAKE_LOG( "XODE: read restitution = " + strRestitution );
+	YAKE_LOG( "XODE: read softness = " + strSoftness );
+
+	desc.mFriction = StringUtil::parseReal( strFriction );
+	desc.mRestitution = StringUtil::parseReal( strRestitution );
+	desc.mSoftness = StringUtil::parseReal( strSoftness );
+
+	//TODO fill in all other description params!
+	// parent name, etc
+	MaterialDesc matDesc;
+	matDesc.name_ = parent + "material"; // TODO make something totally yake::Unique here?
+	matDesc.material_ = desc;
+	matDesc.parentName_ = parent;
+
+	sigMaterial_( matDesc );
+    }
+
+    //------------------------------------------------------
+    /**
+     * Reads geom xode node
+     * No folded bodies, geoms, spaces processed.
+     * @param pGeomNode
+     * @param pParentObject
+     */
+    void XODEParser::readGeom(	const NodeSharedPtr pGeomNode, const String& parent, 
+	    const Transform& rParentTransform, bool absoluteTransform )
+    {
+	const String name = pGeomNode->getAttributeValueAs<String>( "name" );
+	YAKE_LOG( "XODE: reading geom " + name );
+
+	const dom::NodeList& nodes = pGeomNode->getNodes();
+
+	// Looking for transform
+	NodeHunter hunter( "transform" );
+	NodeListIter iTrans =
+	    std::find_if<NodeListIter,NodeHunter>( nodes.begin(), nodes.end(), hunter );
+
+	Transform geomTransform;
+
+	if ( iTrans != nodes.end() )
+	{
+	    YAKE_LOG( "XODE: readGeom() [" + name + "] : geom has transform " );
+
+	    readTransform( *iTrans, geomTransform );
+	}
+
+	// if transform is absolute, we need to provide derived transform
+	if ( absoluteTransform )
+	    geomTransform = geomTransform.getDerivedTransform( rParentTransform );
+
+	YAKE_LOG( "XODE: scanning other geom properties..." );
+
+	for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
+	{
+	    String nodeName = StringUtil::toLowerCase( (*it)->getName() );
+
+	    YAKE_LOG( "XODE: geom [" + name + "] has node #" + nodeName );
+
+	    IShape::Desc* shapeDesc = NULL;
+
+	    if ( nodeName == "geom" )
+	    {
+		// reading folded geom -> absolute transform is provided
+		// parent ( actor ) remains the same
+		readGeom( *it, parent, geomTransform, true );
+	    }
+	    if ( nodeName == "box" )
+	    {
+		real sizeX, sizeY, sizeZ;
+		readBox( *it, sizeX, sizeY, sizeZ );
+
+		sizeX *= rParentTransform.scale_.x;
+		sizeY *= rParentTransform.scale_.y;
+		sizeZ *= rParentTransform.scale_.z;
+
+		String strSizeX; strSizeX << sizeX;
+		String strSizeY; strSizeY << sizeY;
+		String strSizeZ; strSizeZ << sizeZ;
+
+		YAKE_LOG( "XODE: box with sizes: " + strSizeX + ", " + strSizeY + ", " + strSizeZ );
+
+		shapeDesc = new IShape::BoxDesc( math::Vector3( sizeX, sizeY, sizeZ ), "",
+			geomTransform.position_, geomTransform.rotation_ );
+	    }
+	    else if ( nodeName == "cappedCylinder" )
+	    {
+		real radius, length;
+		readCappedCylinder( *it, radius, length );
+
+		real scale = ( rParentTransform.scale_.x
+			+ rParentTransform.scale_.y
+			+ rParentTransform.scale_.z ) /3;
+
+		radius *= scale;
+		length *= scale;
+
+		shapeDesc = new IShape::CapsuleDesc( length,
+			radius,
+			"",
+			geomTransform.position_,
+			geomTransform.rotation_ );
+	    }
+	    else if ( nodeName == "cone" )
+	    {
+		real radius, length;
+		readCone( *it, radius, length );
+
+		real scale = ( rParentTransform.scale_.x
+			+ rParentTransform.scale_.y
+			+ rParentTransform.scale_.z ) /3;
+
+		radius *= scale;
+		length *= scale;
+
+		YAKE_ASSERT( false ).error( "NOT implemented in Yake" ); //TODO
+	    }
+	    else if ( nodeName == "cylinder" )
+	    {
+		real radius, length;
+		readCylinder( *it, radius, length );
+
+		real scale = ( rParentTransform.scale_.x
+			+ rParentTransform.scale_.y
+			+ rParentTransform.scale_.z ) /3;
+
+		radius *= scale;
+		length *= scale;
+
+		shapeDesc = new IShape::CapsuleDesc( length,
+			radius,
+			"",
+			geomTransform.position_,
+			geomTransform.rotation_ );
+	    }
+	    else if ( nodeName == "plane" )
+	    {
+		real a, b, c, d;
+		readPlane( *it, a, b, c, d );
+		shapeDesc = new IShape::PlaneDesc( math::Vector3( a, b, c ),
+			d,
+			"",
+			geomTransform.position_,
+			geomTransform.rotation_ );
+	    }
+	    else if ( nodeName == "ray" )
+	    {
+		real length;
+		readRay( *it, length );
+
+		real scale = ( rParentTransform.scale_.x
+			+ rParentTransform.scale_.y
+			+ rParentTransform.scale_.z ) /3;
+
+		length *= scale;
+
+		YAKE_ASSERT( false ).error( "NOT implemented in Yake" ); //TODO
+	    }
+	    else if ( nodeName == "sphere" )
+	    {
+		real radius;
+		readSphere( *it, radius );
+
+		real scale = ( rParentTransform.scale_.x
+			+ rParentTransform.scale_.y
+			+ rParentTransform.scale_.z ) /3;
+
+		radius *= scale;
+
+		shapeDesc = new IShape::SphereDesc(
+			radius,
+			"",
+			geomTransform.position_,
+			geomTransform.rotation_ );
+	    }
+	    else if ( nodeName == "trimesh" )
+	    {
+		TriangleMeshDesc::VertexVector vertices;
+		TriangleMeshDesc::IndexVector indices;
+
+		readTrimesh( *it, vertices, indices );
+
+		TriangleMeshDesc::VertexVector scaledVertices;
+
+		ConstVectorIterator< TriangleMeshDesc::VertexVector > iV( vertices.begin(), vertices.end() );
+
+		while ( iV.hasMoreElements() )
+		{
+		    const math::Vector3& vertex = iV.getNext();
+		    scaledVertices.push_back( vertex * rParentTransform.scale_ );
+		}
+
+		TriangleMeshDesc dataDesc( vertices, indices );
+
+		shapeDesc = new IShape::TriMeshDesc( dataDesc, "",
+			geomTransform.position_, geomTransform.rotation_ );
+	    }
+	    else if ( nodeName == "ext" )
+	    {
+		readExtension( *it, name, rParentTransform );
+	    }
+
+	    if ( shapeDesc != NULL )
+	    {
+		//TODO fill in all other description params!
+		// parent name, etc
+		GeomDesc geomDesc;
+		geomDesc.name_ = name;
+		geomDesc.parentName_ = parent;
+		geomDesc.shape_.reset( shapeDesc );
+
+		sigGeom_( geomDesc );
+
+		// read material after geom definition was found.
+		// TODO is this a right place to read material?
+		// 
+		readMaterialExt( *it, name );
+	    }
+	}
+
+	YAKE_LOG( "XODE: Leaving readGeom()" );
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readBox( const NodeSharedPtr pNode, real& sizeX, real& sizeY, real& sizeZ )
+    {
+	sizeX = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "sizex" ) );
+	sizeY = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "sizey" ) );
+	sizeZ = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "sizez" ) );
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readCappedCylinder( const NodeSharedPtr pNode, real& radius, real& length )
+    {
+	radius = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "radius" ) );
+	length = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "length" ) );
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readCone( const NodeSharedPtr pNode, real& radius, real& length )
+    {
+	radius = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "radius" ) );
+	length = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "length" ) );
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readCylinder( const NodeSharedPtr pNode, real& radius, real& length )
+    {
+	radius = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "radius" ) );
+	length = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "length" ) );
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readPlane( const NodeSharedPtr pNode, real& a, real& b, real& c, real& d )
+    {
+	a = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "a" ) );
+	b = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "b" ) );
+	c = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "c" ) );
+	d = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "d" ) );
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readRay( const NodeSharedPtr pNode, real& length )
+    {
+	length = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "length" ) );
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readSphere( const NodeSharedPtr pNode, real& radius )
+    {
+	radius = StringUtil::parseReal( pNode->getAttributeValueAs<String>( "radius" ) );
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readTrimesh( const NodeSharedPtr pMeshNode,
+	    TriangleMeshDesc::VertexVector& rVertices,
+	    TriangleMeshDesc::IndexVector& rIndices )
+    {
+	const dom::NodeList& nodes = pMeshNode->getNodes();
+
+	for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it )
+	{
+	    String nodeName = StringUtil::toLowerCase( (*it)->getName() );
+
+	    YAKE_LOG( "XODE: reading " + nodeName + " trimesh now..." );
+
+	    if ( nodeName == "vertices" )
+	    {
+		readVertices( *it, rVertices );
+	    }
+	    else if ( nodeName == "triangles" )
+	    {
+		readIndices( *it, rIndices );
+	    }
+	}
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readVertices( const NodeSharedPtr pNode, TriangleMeshDesc::VertexVector& rVertices )
+    {
+	const dom::NodeList& nodes = pNode->getNodes();
+
+	for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it )
+	{
+	    String nodeName = StringUtil::toLowerCase( (*it)->getName() );
+
+	    if ( nodeName == "v" )
+	    {
+		real x = StringUtil::parseReal( (*it)->getAttributeValueAs< String >( "x" ) );
+		real y = StringUtil::parseReal( (*it)->getAttributeValueAs< String >( "y" ) );
+		real z = StringUtil::parseReal( (*it)->getAttributeValueAs< String >( "z" ) );
+
+		rVertices.push_back( math::Vector3( x, y, z ) );
+	    }
+	}
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readIndices( const NodeSharedPtr pNode, TriangleMeshDesc::IndexVector& rIndices )
+    {
+	const dom::NodeList& nodes = pNode->getNodes();
+
+	typedef int32 IndexT;
+
+	for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it )
+	{
+	    String nodeName =
+		StringUtil::toLowerCase( (*it)->getName() );
+
+	    if ( nodeName == "t" )
+	    {
+		IndexT ia = StringUtil::parseInt( (*it)->getAttributeValueAs< String >( "ia" ) );
+		IndexT ib = StringUtil::parseInt( (*it)->getAttributeValueAs< String >( "ib" ) );
+		IndexT ic = StringUtil::parseInt( (*it)->getAttributeValueAs< String >( "ic" ) );
+
+		rIndices.push_back( ia );
+		rIndices.push_back( ib );
+		rIndices.push_back( ic );
+	    }
+	}
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readJoint( const NodeSharedPtr pJointNode,
+	    const String& parent,
+	    const Transform& rParentTransform )
+    {
+	JointDesc desc;
+	desc.parentName_ = parent;
+	desc.transform_ = rParentTransform;
+
+	// reading joint... creating description.
+
+	const dom::NodeList& nodes = pJointNode->getNodes();
+	const String name = pJointNode->getAttributeValueAs<String>( "name" );
+
+	desc.name_ = name;
+
+	YAKE_LOG( "XODE: reading joint '" + name + "' ..." );
+
+	// Looking for link1
+	NodeHunter link1Hunter( "link1" );
+	NodeListIter iLink1 =
+	    std::find_if<NodeListIter, NodeHunter>( nodes.begin(), nodes.end(), link1Hunter );
+
+	String body1Name;
+	// <link1 .. can be omitted. Parent is then considered 
+	// to be the first body.
+	// See .xode description for explanation.
+	if ( iLink1 == nodes.end() )
+	    body1Name = parent;
+	else
+	    body1Name = (*iLink1)->getAttributeValueAs<String>( "body" );
+
+	desc.body1_ = body1Name;
+
+	// Looking for link2
+	NodeHunter linkHunter( "link2" );
+	NodeListIter iLink =
+	    std::find_if<NodeListIter, NodeHunter>( nodes.begin(), nodes.end(), linkHunter );
+
+	YAKE_ASSERT( iLink != nodes.end() ).error( "2nd body name is not present in joint definition!" );
+
+	String body2Name = (*iLink)->getAttributeValueAs<String>( "body" );
+
+	desc.body2_ = body2Name;
+
+	YAKE_LOG( "XODE: the joint connects two actors:" );
+	YAKE_LOG( "XODE: 1:" + body1Name );
+	YAKE_LOG( "XODE: 2:" + body2Name );
+
+	// Looking for transform
+	NodeHunter hunter( "transform" );
+	NodeListIter iTrans =
+	    std::find_if<NodeListIter, NodeHunter>( nodes.begin(), nodes.end(), hunter );
+
+	Transform jointTransform;
+	if ( iTrans != nodes.end() )
+	{
+	    YAKE_LOG( "XODE: joint has transform " );
+
+	    readTransform( *iTrans, jointTransform );
+	}
+
+	if ( !rParentTransform.isIdentity() )
+	{
+	    jointTransform = jointTransform.getDerivedTransform( rParentTransform );
+	}
+
+	for ( NodeListIter it = nodes.begin(); it != nodes.end(); ++it )
+	{
+	    String nodeName = StringUtil::toLowerCase( (*it)->getName() );
+
+	    IJoint::DescBase* jointDesc = NULL;
+
+	    YAKE_LOG( "XODE: reading " + nodeName + " now..." );
+
+	    if ( nodeName == "ball" )
+	    {
+		jointDesc = readBall( *it, jointTransform );
+	    }
+	    else if ( nodeName == "fixed" )
+	    {
+		jointDesc = readFixed( *it, jointTransform );
+	    }
+	    else if ( nodeName == "hinge" )
+	    {
+		jointDesc = readHinge( *it, jointTransform );
+	    }
+	    else if ( nodeName == "hinge2" )
+	    {
+		jointDesc = readHinge2( *it, jointTransform );
+	    }
+	    else if ( nodeName == "slider" )
+	    {
+		jointDesc = readSlider( *it, jointTransform );
+	    }
+	    else if ( nodeName == "universal" )
+	    {
+		jointDesc = readUniversal( *it, jointTransform );
+	    }
+	    else if ( nodeName == "amotor" )
+	    {
+		YAKE_ASSERT( false ).error( "amotor joint type is not supported!" );
+	    }
+
+	    if ( jointDesc != NULL )
+	    {
+		desc.joint_.reset( jointDesc );
+
+		sigJoint_( desc );
+	    }
+	}
+
+    }
+
+    //------------------------------------------------------
+    IJoint::DescBase* XODEParser::readBall( const NodeSharedPtr pJointNode, const Transform& rJointTransform )
+    {
+	YAKE_LOG( "XODE: reading ball joint description..." );
+
+	const dom::NodeList& nodes = pJointNode->getNodes();
+
+	typedef dom::NodeList::const_iterator NodeListIter;
+
+	// Looking for anchor
+	NodeHunter anchorHunter( "anchor" );
+	NodeListIter iAnchor =
+	    std::find_if<NodeListIter, NodeHunter>( nodes.begin(), nodes.end(), anchorHunter );
+
+	YAKE_ASSERT( iAnchor != nodes.end() ).error( "Anchor was not defined for ball joint!" );
+
+	math::Vector3 anchor;
+
+	readAnchor( *iAnchor, anchor, rJointTransform );
+
+	IJoint::DescBase* desc = new IJoint::DescBall( NULL, NULL, anchor );
+
+	YAKE_LOG( "XODE: Finished processing ball joint description." );
+
+	return desc;
+    }
+
+    //------------------------------------------------------
+    IJoint::DescBase* XODEParser::readFixed( const NodeSharedPtr pJointNode, const Transform& rJointTransform )
+    {
+	YAKE_LOG( "Reading fixed joint description..." );
+
+	IJoint::DescBase* desc = new IJoint::DescFixed( NULL, NULL );
+
+	YAKE_LOG( "Finished processing fixed joint description." );
+
+	return desc;
+    }
+
+    //------------------------------------------------------
+    IJoint::DescBase* XODEParser::readHinge( const NodeSharedPtr pJointNode, const Transform& rJointTransform )
+    {
+	YAKE_LOG( "Reading hinge joint description..." );
+
+	const dom::NodeList& nodes = pJointNode->getNodes();
+
+	// Looking for anchor
+	NodeHunter anchorHunter( "anchor" );
+	NodeListIter iAnchor =
+	    std::find_if<NodeListIter, NodeHunter>( nodes.begin(), nodes.end(), anchorHunter );
+
+	YAKE_ASSERT( iAnchor != nodes.end() ).error( "Anchor was not defined for hinge joint!" );
+
+	// Looking for axis
+	NodeHunter axisHunter( "axis" );
+	NodeListIter iAxis =
+	    std::find_if<NodeListIter, NodeHunter>( nodes.begin(), nodes.end(), axisHunter );
+
+	YAKE_ASSERT( iAxis != nodes.end() ).error( "Axis was not defined for hinge joint!" );
+
+	math::Vector3 anchor;
+	math::Vector3 axis;
+
+	readAnchor( *iAnchor, anchor, rJointTransform );
+	readAxis( *iAxis, axis, rJointTransform );
+
+	IJoint::DescBase* desc = new IJoint::DescHinge( NULL, NULL, axis, anchor );
+
+	YAKE_LOG( "Finished processing hinge joint description." );
+
+	return desc;
+    }
+
+    //------------------------------------------------------
+    IJoint::DescBase* XODEParser::readHinge2( const NodeSharedPtr pJointNode, const Transform& rJointTransform )
+    {
+	YAKE_LOG( "Reading hinge2 joint description..." );
+
+	const dom::NodeList& nodes = pJointNode->getNodes();
+
+	// Looking for anchor
+	NodeHunter anchorHunter( "anchor" );
+	NodeListIter iAnchor =
+	    std::find_if<NodeListIter, NodeHunter>( nodes.begin(), nodes.end(), anchorHunter );
+
+	YAKE_ASSERT( iAnchor != nodes.end() ).error( "Anchor was not defined for hinge2 joint!" );
+
+	// Looking for axis
+	NodeHunter axisHunter( "axis" );
+	NodeListIter iAxis0 =
+	    std::find_if<NodeListIter, NodeHunter>( nodes.begin(), nodes.end(), axisHunter );
+
+	YAKE_ASSERT( iAxis0 != nodes.end() ).error( "Axis0 was not defined for hinge2 joint!" );
+
+	NodeListIter iAxis1 =
+	    std::find_if<NodeListIter, NodeHunter>( iAxis0 + 1, nodes.end(), axisHunter );
+
+	YAKE_ASSERT( iAxis1 != nodes.end() ).error( "Axis1 was not defined for hinge2 joint!" );
+
+	math::Vector3 anchor;
+	math::Vector3 axis0;
+	math::Vector3 axis1;
+
+	readAnchor( *iAnchor, anchor, rJointTransform );
+	readAxis( *iAxis0, axis0, rJointTransform );
+	readAxis( *iAxis1, axis1, rJointTransform );
+
+	IJoint::DescBase* desc = new IJoint::DescHinge2( NULL, NULL, axis0, axis1, anchor );
+
+	YAKE_LOG( "XODE: finished processing hinge2 joint description." );
+
+	return desc;
+    }
+
+    //------------------------------------------------------
+    IJoint::DescBase* XODEParser::readSlider( const NodeSharedPtr pJointNode, const Transform& rJointTransform )
+    {
+	YAKE_LOG( "XODE: reading slider joint description..." );
+
+	const dom::NodeList& nodes = pJointNode->getNodes();
+
+	// Looking for axis
+	NodeHunter axisHunter( "axis" );
+	NodeListIter iAxis =
+	    std::find_if<NodeListIter, NodeHunter>( nodes.begin(), nodes.end(), axisHunter );
+
+	YAKE_ASSERT( iAxis != nodes.end() ).error( "Axis was not defined for slider joint!" );
+
+	math::Vector3 axis;
+
+	readAxis( *iAxis, axis, rJointTransform );
+
+	IJoint::DescBase* desc = new IJoint::DescSlider( NULL, NULL, axis );
+
+	YAKE_LOG( "XODE: finished processing slider joint description." );
+
+	return desc;
+    }
+
+    //------------------------------------------------------
+    IJoint::DescBase* XODEParser::readUniversal( const NodeSharedPtr pJointNode, const Transform& rJointTransform )
+    {
+	YAKE_LOG( "XODE: reading universal joint description..." );
+
+	const dom::NodeList& nodes = pJointNode->getNodes();
+
+	// Looking for anchor
+	NodeHunter anchorHunter( "anchor" );
+	NodeListIter iAnchor =
+	    std::find_if<NodeListIter, NodeHunter>( nodes.begin(), nodes.end(), anchorHunter );
+
+	YAKE_ASSERT( iAnchor != nodes.end() ).error( "Anchor was not defined for universal joint!" );
+
+	// Looking for axis
+	NodeHunter axisHunter( "axis" );
+	NodeListIter iAxis0 =
+	    std::find_if<NodeListIter, NodeHunter>( nodes.begin(), nodes.end(), axisHunter );
+
+	YAKE_ASSERT( iAxis0 != nodes.end() ).error( "Axis0 was not defined for universal joint!" );
+
+	NodeListIter iAxis1 =
+	    std::find_if<NodeListIter, NodeHunter>( iAxis0 + 1, nodes.end(), axisHunter );
+
+	YAKE_ASSERT( iAxis1 != nodes.end() ).error( "Axis1 was not defined for universal joint!" );
+
+	math::Vector3 anchor;
+	math::Vector3 axis0;
+	math::Vector3 axis1;
+
+	readAnchor( *iAnchor, anchor, rJointTransform );
+	readAxis( *iAxis0, axis0, rJointTransform );
+	readAxis( *iAxis1, axis1, rJointTransform );
+
+	IJoint::DescBase* desc = new IJoint::DescUniversal( NULL, NULL, axis0, axis1, anchor );
+
+	YAKE_LOG( "XODE: finished processing universal joint description." );
+
+	return desc;
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readAnchor( const NodeSharedPtr pAnchorNode,
+	    math::Vector3& rAnchor,
+	    const Transform& rJointTransform )
+    {
+	YAKE_LOG( "XODE: reading anchor..." );
+
+	rAnchor.x = StringUtil::parseReal( pAnchorNode->getAttributeValueAs<String>( "x" ) );
+	rAnchor.y = StringUtil::parseReal( pAnchorNode->getAttributeValueAs<String>( "y" ) );
+	rAnchor.z = StringUtil::parseReal( pAnchorNode->getAttributeValueAs<String>( "z" ) );
+
+	rAnchor = rJointTransform.position_ + rJointTransform.rotation_*( rJointTransform.scale_*rAnchor );
+    }
+
+    //------------------------------------------------------
+    void XODEParser::readAxis(	const NodeSharedPtr pAxisNode,
+	    math::Vector3& rAxis,
+	    const Transform& rJointTransform )
+    {
+	YAKE_LOG( "XODE: reading axis..." );
+
+	rAxis.x = StringUtil::parseReal( pAxisNode->getAttributeValueAs<String>( "x" ) );
+	rAxis.y = StringUtil::parseReal( pAxisNode->getAttributeValueAs<String>( "y" ) );
+	rAxis.z = StringUtil::parseReal( pAxisNode->getAttributeValueAs<String>( "z" ) );
+
+	/// TODO What about all other axis params?
+
+	rAxis = rJointTransform.rotation_*rAxis;
+    }
+
+} //xode
+} //parser
+} //data
+} //yake
+

Modified: trunk/yake/src/yake/model/yakeComponentCreatorManager.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeComponentCreatorManager.cpp	2006-06-12 21:26:14 UTC (rev 1333)
+++ trunk/yake/src/yake/model/yakeComponentCreatorManager.cpp	2006-06-12 21:27:15 UTC (rev 1334)
@@ -39,11 +39,11 @@
 	ComponentCreatorManager::~ComponentCreatorManager()
 	{
 	}
-	ModelComponent* ComponentCreatorManager::create(const String& type, const ComponentCreationContext& ctx, const StringMap& params)
+	void ComponentCreatorManager::create(const String& type, const ComponentCreationContext& ctx, const StringMap& params)
 	{
 		YAKE_ASSERT( !type.empty() )(type)(params).debug("Invalid type!");
 		if (type.empty())
-			return 0;
+			return;
 
 		ComponentCreator* theCreator = 0;
 		{
@@ -60,7 +60,7 @@
 				}
 				YAKE_ASSERT( creator.get() )(type)(params).debug("Failed to create component creator! Probably it has not been registered/loaded.");
 				if (!creator.get())
-					return 0;
+					return;
 				creators_.insert( std::make_pair(type,creator) );
 				theCreator = creator.get();
 			}
@@ -68,10 +68,10 @@
 				theCreator = it->second.get();
 		}
 		YAKE_ASSERT( theCreator );
-		ModelComponent* c = theCreator->create(ctx,params);
-		YAKE_ASSERT( c )(type)(params).debug("Failed to create component!");
+		theCreator->create(ctx,params);
+		//YAKE_ASSERT( c )(type)(params).debug("Failed to create component!");
 
-		return c;
+		//return c;
 	}
 
 } // namespace model

Added: trunk/yake/src/yake/model/yakeDotLinkLoader.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeDotLinkLoader.cpp	2006-06-12 21:26:14 UTC (rev 1333)
+++ trunk/yake/src/yake/model/yakeDotLinkLoader.cpp	2006-06-12 21:27:15 UTC (rev 1334)
@@ -0,0 +1,176 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"
+#include "yake/model/prerequisites.h"
+#include "yake/model/model.h"
+#include "yake/model/model_link_dotlink_loader.h"
+
+namespace yake {
+namespace model {
+
+	DotLinkLoader::DotLinkLoader() : mpModel(0)
+	{
+	}
+
+	DotLinkLoader::~DotLinkLoader()
+	{
+	}
+
+	bool DotLinkLoader::load( const String & rDotLinkFilename, Model & rModel, CentralControllerBase& centralController )
+	{
+		using namespace data::dom;
+
+		xml::XmlSerializer ser;
+		ser.parse( rDotLinkFilename, false );
+
+		const SharedPtr<INode> pLinksNode = ser.getDocumentNode();
+		YAKE_ASSERT( pLinksNode )( rDotLinkFilename );
+		if (!pLinksNode)
+			return false;
+
+		return load( *pLinksNode, rModel, centralController );
+	}
+
+	bool DotLinkLoader::load( const data::dom::INode & rLinksNode, Model & rModel, CentralControllerBase& centralController )
+	{
+		using namespace data::dom;
+		using namespace base::templates;
+
+		mpModel = &rModel;
+		mpCentralController = &centralController;
+
+		// parse links
+		const NodeList nodes = rLinksNode.getNodes();
+		ConstVectorIterator< NodeList > itNode( nodes.begin(), nodes.end() );
+		while (itNode.hasMoreElements())
+		{
+			const SharedPtr<INode> & pNode = itNode.getNext();
+			if (!pNode.get())
+				continue;
+			parseLink( *pNode.get() );
+		}
+
+		mpModel = 0;
+		return true;
+	}
+
+	Movable* getMovableFromModel( Model& rModel, const data::dom::INode& rNode )
+	{
+		// parse
+		String sourceType = StringUtil::toLowerCase(rNode.getAttributeValueAs<String>("type"));
+		String sourceModelName = (rNode.getAttributeValueAs<String>("submodel"));
+		String sourceMovableType = StringUtil::toLowerCase(rNode.getAttributeValueAs<String>("elementtype"));
+		String sourceMovableName = (rNode.getAttributeValueAs<String>("element"));
+		
+		YAKE_LOG( "Searching movable: " ); 
+		YAKE_LOG( "    type: " + sourceType );
+		YAKE_LOG( "    submodel: " + sourceModelName );
+		YAKE_LOG( "    movable type: " + sourceMovableType );
+		YAKE_LOG( "    movable name: " + sourceMovableName );
+		
+		// retrieve source movable
+		Movable* pMovable = 0;
+		if ( sourceType == "graphical" )
+		{
+			YAKE_ASSERT( sourceMovableType == "graphics.scenenode" );
+			YAKE_LOG( "Searching for graphical named '" + sourceModelName + "'" );
+
+			Graphical* pG = dynamic_cast<Graphical*>(rModel.getComponentByTag( sourceModelName ));
+			YAKE_ASSERT( pG )( sourceModelName );
+
+			pMovable = pG->getSceneNode( sourceMovableName );
+		}
+		else if ( sourceType == "physical" )
+		{
+			YAKE_LOG( "Searching for physical named '" + sourceModelName + "'" );
+
+			Physical* pP = dynamic_cast<Physical*>(rModel.getComponentByTag( sourceModelName ));
+			YAKE_ASSERT( pP )( sourceModelName );
+
+			if (sourceMovableType == "physics.actor" || sourceMovableType == "physics.complex")
+				pMovable = pP->getActor( sourceMovableName );
+		}
+
+		YAKE_ASSERT( pMovable != NULL ).error( "Couldn't find movable '" + sourceMovableName + "'. Bailing out." );
+		return pMovable;
+	}
+
+	void DotLinkLoader::parseLink( const data::dom::INode & rLinkNode )
+	{
+		YAKE_ASSERT( mpModel );
+		if (!mpModel)
+			return;
+
+		YAKE_ASSERT( mpCentralController );
+		if (!mpCentralController)
+			return;
+
+		using namespace data::dom;
+		using namespace yake::templates;
+
+		const String linkType = StringUtil::toLowerCase( rLinkNode.getAttributeValueAs<String>("type") );
+		//const String linkName = varGet<String>( rLinkNode.getId("id") );
+		const String linkName = "[not_set]";
+
+		std::cout << "Creating link of type '"<< linkType << "'" << std::endl;
+
+		// source
+		const SharedPtr<INode> pSourceNode = rLinkNode.getNodeByName("link_source");
+		YAKE_ASSERT( pSourceNode )( linkName );
+		if (!pSourceNode)
+			return;
+	
+		std::cout << "Found source for link... Searching for targets " << std::endl;
+
+		// targets
+		const NodeList targets = rLinkNode.getNodes();
+		ConstVectorIterator< NodeList > itTargetNode( targets.begin(), targets.end() );
+		while (itTargetNode.hasMoreElements())
+		{
+			const SharedPtr<INode> & pTargetNode = itTargetNode.getNext();
+			YAKE_ASSERT( pTargetNode.get() )( linkName );
+			if (!pTargetNode.get())
+				continue;
+
+			const String nodeName = StringUtil::toLowerCase( pTargetNode->getName() );
+			if (nodeName != "link_target")
+				continue;
+	
+			Movable* from = getMovableFromModel(*mpModel,*pSourceNode);
+			Movable* to = getMovableFromModel(*mpModel,*pTargetNode);
+
+			std::cout << "Found source and target. Adding controller to model..." << std::endl;
+
+			ModelMovableLink* link = mpModel->createLink( from, to, linkType );
+			YAKE_ASSERT( link );
+			
+			mpCentralController->subscribeToGraphicsUpdate(boost::bind(&ModelMovableLink::update,link,_1,_2));
+		}
+	}
+
+} // namespace model
+} // namespace yake

Modified: trunk/yake/src/yake/model/yakeGraphical.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeGraphical.cpp	2006-06-12 21:26:14 UTC (rev 1333)
+++ trunk/yake/src/yake/model/yakeGraphical.cpp	2006-06-12 21:27:15 UTC (rev 1334)
@@ -34,6 +34,11 @@
 	Graphical::Graphical()
 	{
 	}
+	/*
+	Graphical::Graphical(Model& owner) : ModelComponent(owner)
+	{
+	}
+	*/
 	Graphical::~Graphical()
 	{
 		/*

Modified: trunk/yake/src/yake/model/yakeGraphicalCreator.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeGraphicalCreator.cpp	2006-06-12 21:26:14 UTC (rev 1333)
+++ trunk/yake/src/yake/model/yakeGraphicalCreator.cpp	2006-06-12 21:27:15 UTC (rev 1334)
@@ -34,26 +34,26 @@
 
 	YAKE_REGISTER_CONCRETE(GraphicalFromDotSceneCreator)
 
-	ModelComponent* GraphicalFromDotSceneCreator::create(const ComponentCreationContext& ctx, const StringMap& params)
+	void GraphicalFromDotSceneCreator::create(const ComponentCreationContext& ctx, const StringMap& params)
 	{
 		// Verify validity of creation context
 		graphics::IWorld* pGWorld = ctx.gworld_;
 		YAKE_ASSERT( pGWorld );
 		if (!pGWorld)
-			return 0;
+			return;
 
 		// Extract parameters
 
 		StringMap::const_iterator itParam = params.find("file");
 		YAKE_ASSERT(itParam != params.end()).debug("Missing parameter 'file'.");
 		if (itParam == params.end())
-			return 0;
+			return;
 		const String fn = itParam->second;
 
 		itParam = params.find("name");
 		YAKE_ASSERT(itParam != params.end()).debug("Missing parameter 'name'.");
 		if (itParam == params.end())
-			return 0;
+			return;
 		const String name = itParam->second;
 
 		// Read dotscene file into DOM
@@ -66,9 +66,11 @@
 
 		yake::data::parser::dotscene::DotSceneParserV1 dsp;
 
-		Graphical* pGraphical = new Graphical();
+		Graphical* pGraphical = new Graphical(/**ctx.model_*/);
 
-		DotSceneListener dotSceneListener( *pGraphical, name.empty() ? _T("") : (name + _T("/")) );
+		const String namePrefix = _T("model:") + ctx.model_->getName() + _T("/")  // model
+									+ (name.empty() ? _T("") : (name + _T("/"))); // component
+		DotSceneListener dotSceneListener( *pGraphical, namePrefix );
 		dotSceneListener.reset( pGWorld );
 
 		dsp.subscribeToNodeSignal( Bind1( &DotSceneListener::processSceneNode, &dotSceneListener ) );
@@ -81,7 +83,7 @@
 			YAKE_SAFE_DELETE( pGraphical );
 		}
 
-		return pGraphical;
+		ctx.model_->addComponent( pGraphical, name );
 	}
 
 } // namespace model

Added: trunk/yake/src/yake/model/yakeLinkCreator.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeLinkCreator.cpp	2006-06-12 21:26:14 UTC (rev 1333)
+++ trunk/yake/src/yake/model/yakeLinkCreator.cpp	2006-06-12 21:27:15 UTC (rev 1334)
@@ -0,0 +1,63 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"
+#include "yake/model/prerequisites.h"
+#include "yake/model/model.h"
+#include "yake/model/model_link_dotlink_loader.h"
+
+namespace yake {
+namespace model {
+
+	YAKE_REGISTER_CONCRETE(LinkFromDotLinkCreator)
+
+	void LinkFromDotLinkCreator::create(const ComponentCreationContext& ctx, const StringMap& params)
+	{
+		// Extract parameters
+
+		StringMap::const_iterator itParam = params.find("file");
+		YAKE_ASSERT(itParam != params.end()).debug("Missing parameter 'file'.");
+		if (itParam == params.end())
+			return;
+		const String fn = itParam->second;
+
+		// Read XML file into DOM
+
+		yake::data::dom::xml::XmlSerializer ser;
+		ser.parse( fn, false );
+		YAKE_ASSERT( ser.getDocumentNode() )( fn ).error("Could not parse XML document!");
+
+		// Parse DOM and create graphical objects
+
+		DotLinkLoader dotLinkLoader;
+		if (!dotLinkLoader.load( *ser.getDocumentNode(), *ctx.model_, *ctx.centralController_ ))
+		{
+			//@todo Report error!
+		}
+	}
+
+} // namespace model
+} // namespace yake

Modified: trunk/yake/src/yake/model/yakeModel.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeModel.cpp	2006-06-12 21:26:14 UTC (rev 1333)
+++ trunk/yake/src/yake/model/yakeModel.cpp	2006-06-12 21:27:15 UTC (rev 1334)
@@ -49,6 +49,20 @@
 	{
 		return components_.getComponentByTag(tag);
 	}
+	ModelMovableLink* Model::createLink(yake::Movable* from, yake::Movable* to, const yake::String &linkType)
+	{
+		//SharedPtr<ModelMovableLink> link = create<ModelMovableLink>(linkType); //@todo USE FACTORY!
+		ModelMovableLink* link = new ModelMovableDirectLink();
+		link->setSource( from );
+		link->subscribeToPositionChanged(to);
+		this->addLink( link );
+		return link;
+	}
+	void Model::addLink(yake::model::ModelLink* link)
+	{
+		YAKE_ASSERT( link );
+		links_.addModelLink( link );
+	}
 	/*
 	Model* Model::clone() const
 	{

Added: trunk/yake/src/yake/model/yakeModelLink.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeModelLink.cpp	2006-06-12 21:26:14 UTC (rev 1333)
+++ trunk/yake/src/yake/model/yakeModelLink.cpp	2006-06-12 21:27:15 UTC (rev 1334)
@@ -0,0 +1,35 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"
+#include "yake/model/prerequisites.h"
+#include "yake/model/model.h"
+
+namespace yake {
+namespace model {
+	YAKE_IMPLEMENT_REGISTRY(ModelLink)
+} // namespace model
+} // namespace yake

Modified: trunk/yake/src/yake/model/yakeModelManager.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeModelManager.cpp	2006-06-12 21:26:14 UTC (rev 1333)
+++ trunk/yake/src/yake/model/yakeModelManager.cpp	2006-06-12 21:27:15 UTC (rev 1334)
@@ -50,15 +50,28 @@
 			}
 		}
 	} // namespace detail
+	void ModelManager::clear()
+	{
+		models_.clear();
+	}
 	/// graphics/dotScene:name=gfx;file=bla.scene|physics/dotXODE...
-	Model* ModelManager::createModel(const String& def)
+	Model* ModelManager::createModel(const String& modelName, const String& def)
 	{
+		YAKE_ASSERT( !modelName.empty() );
+		YAKE_ASSERT( models_.find(modelName) == models_.end() )(modelName).debug("Model with that name already exists.");
+		if (models_.find(modelName) != models_.end())
+			return 0;
+
 		Vector<String> defComponents = split<String>(def, "|");
-		YAKE_ASSERT(!defComponents.empty());
+		YAKE_ASSERT(!defComponents.empty())(modelName)(def);
 		if (defComponents.empty())
 			return 0;
+
 		Model* m = new Model();
-		models_.push_back( SharedPtr<Model>(m) );
+		m->setName( modelName );
+		models_.insert( std::make_pair(modelName,SharedPtr<Model>(m)) );
+		ctx_.model_ = m;
+
 		ConstVectorIterator<Vector<String> > itDef( defComponents );
 		while (itDef.hasMoreElements())
 		{
@@ -66,23 +79,37 @@
 
 			// Split e.g. "gfx=graphics/dotScene:file=blah.scene" into "gfx" and "file=graphics/dotScene:blah.scene"
 			Vector<String> defTypeRest = split<String>( defC, ":" );
-			YAKE_ASSERT( defTypeRest.size() == 2 );
+			YAKE_ASSERT( defTypeRest.size() == 2 )(modelName)(def);
 
-			const String type = defTypeRest.front(); // e.g. "graphics/dotScene"
+			const String type = defTypeRest.front(); // e.g. "graphics/dotScene" or "physics/XODE" etc
 
+			// Extract parameters.
 			StringMap params;
 			detail::extractParams( defTypeRest.back(), params );
 
+			// Extract parameter 'name'.
 			StringMap::const_iterator itParam = params.find("name");
-			YAKE_ASSERT( itParam != params.end() ).debug("No property 'name' for component!");
-			if (itParam == params.end())
-				continue;
-			const String name = itParam->second;
+			const String name = (itParam == params.end()) ? _T("") : itParam->second;
 
-			YAKE_ASSERT( m->getComponentByTag(name) == 0 ).debug("Components with duplicate tags are not allowed within the same model!");
+			// Create component.
 
-			m->addComponent( creatorMgr_.create( type, ctx_, params ), name );
+#ifdef YAKE_DEBUG
+			if (!name.empty())
+			{
+				YAKE_ASSERT( m->getComponentByTag(name) == 0 )(name)(type).debug("Components with duplicate tags are not allowed within the same model!");
+			}
+#endif
+
+			creatorMgr_.create( type, ctx_, params );
+
+#ifdef YAKE_DEBUG
+			if (!name.empty())
+			{
+				YAKE_ASSERT( m->getComponentByTag(name) != 0 )(name)(type).debug("Failed to create component!");
+			}
+#endif
 		}
+		ctx_.model_ = 0;
 		return m;
 	}
 	void ModelManager::setCreationContext_GraphicalWorld(graphics::IWorld* w)
@@ -93,6 +120,10 @@
 	{
 		ctx_.pworld_ = w;
 	}
+	void ModelManager::setCreationContext_CentralController(CentralControllerBase* c)
+	{
+		ctx_.centralController_ = c;
+	}
 
 } // namespace model
 } // namespace yake

Added: trunk/yake/src/yake/model/yakeModelMovableLink.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeModelMovableLink.cpp	2006-06-12 21:26:14 UTC (rev 1333)
+++ trunk/yake/src/yake/model/yakeModelMovableLink.cpp	2006-06-12 21:27:15 UTC (rev 1334)
@@ -0,0 +1,112 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"
+#include "yake/model/prerequisites.h"
+#include "yake/model/model.h"
+
+namespace yake {
+namespace model {
+	ModelMovableLink::ModelMovableLink()
+	{
+	}
+	void ModelMovableLink::setSource(Movable* src)
+	{
+		mSource = src;
+	}
+	Movable* ModelMovableLink::getSource() const
+	{
+		return mSource;
+	}
+	SignalConnection ModelMovableLink::subscribeToPositionChanged( Movable* pMovable )
+	{	
+		const Vector3 srcPos = getSource()->getPosition();
+		pMovable->setPosition( srcPos );
+
+		return mPositionSignal.connect( Bind1( &Movable::setPosition, pMovable ) );
+	}
+
+	SignalConnection ModelMovableLink::subscribeToOrientationChanged( Movable* pMovable )
+	{
+		const Quaternion srcOrientation = getSource()->getOrientation();
+		pMovable->setOrientation( srcOrientation );
+
+		return mOrientationSignal.connect( Bind1( &Movable::setOrientation, pMovable ) );
+	}
+
+	YAKE_REGISTER_CONCRETE(ModelMovableDirectLink)
+	ModelMovableDirectLink::ModelMovableDirectLink()
+	{
+	}
+	void ModelMovableDirectLink::update( const uint32, const real timeElapsed )
+	{
+		const Movable* pSource = getSource();
+		YAKE_ASSERT( pSource ).debug("no update source -> no updates");
+		if (!pSource)
+			return;
+		Vector3 position = pSource->getPosition();
+		if (mLastPosition != position)
+		{
+			mPositionSignal( position );
+			mLastPosition = position;
+		}
+		Quaternion orientation = pSource->getOrientation();
+		if (mLastOrientation != orientation)
+		{
+			mOrientationSignal( orientation );
+			mLastOrientation = orientation;
+		}
+	}
+
+	YAKE_REGISTER_CONCRETE( ModelMovableWorldLink );
+	ModelMovableWorldLink::ModelMovableWorldLink()
+	{
+	}
+	void ModelMovableWorldLink::update( const uint32, real timeElapsed )
+	{
+		const Movable* pSource = getSource();
+
+		YAKE_ASSERT( pSource ).error("no update source -> no updates");
+
+		if ( pSource == NULL )
+			return;
+
+		Vector3 position = pSource->getDerivedPosition();
+		if (mLastPosition != position)
+		{
+			mPositionSignal( position );
+			mLastPosition = position;
+		}
+		Quaternion orientation = pSource->getDerivedOrientation();
+		if (mLastOrientation != orientation)
+		{
+			mOrientationSignal( orientation );
+			mLastOrientation = orientation;
+		}
+	}
+
+} // namespace model
+} // namespace yake

Modified: trunk/yake/src/yake/model/yakePhysical.cpp
===================================================================
--- trunk/yake/src/yake/model/yakePhysical.cpp	2006-06-12 21:26:14 UTC (rev 1333)
+++ trunk/yake/src/yake/model/yakePhysical.cpp	2006-06-12 21:27:15 UTC (rev 1334)
@@ -34,6 +34,11 @@
 	Physical::Physical()
 	{
 	}
+	/*
+	Physical::Physical(Model& owner) : ModelComponent(owner)
+	{
+	}
+	*/
 	Physical::~Physical()
 	{
 		for (TagActorMap::iterator itA = actors_.begin(); itA != actors_.end(); ++itA)

Added: trunk/yake/src/yake/model/yakePhysicalCreator.cpp
===================================================================
--- trunk/yake/src/yake/model/yakePhysicalCreator.cpp	2006-06-12 21:26:14 UTC (rev 1333)
+++ trunk/yake/src/yake/model/yakePhysicalCreator.cpp	2006-06-12 21:27:15 UTC (rev 1334)
@@ -0,0 +1,87 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"
+#include "yake/model/prerequisites.h"
+#include "yake/model/model.h"
+#include "yake/model/model_physical_xode_loader.h"
+
+namespace yake {
+namespace model {
+
+	YAKE_REGISTER_CONCRETE(PhysicalFromXODECreator)
+
+	void PhysicalFromXODECreator::create(const ComponentCreationContext& ctx, const StringMap& params)
+	{
+		// Verify validity of creation context
+		physics::IWorld* pPWorld = ctx.pworld_;
+		YAKE_ASSERT( pPWorld );
+		if (!pPWorld)
+			return;
+
+		// Extract parameters
+
+		StringMap::const_iterator itParam = params.find("file");
+		YAKE_ASSERT(itParam != params.end()).debug("Missing parameter 'file'.");
+		if (itParam == params.end())
+			return;
+		const String fn = itParam->second;
+
+		itParam = params.find("name");
+		YAKE_ASSERT(itParam != params.end()).debug("Missing parameter 'name'.");
+		if (itParam == params.end())
+			return;
+		const String name = itParam->second;
+
+		// Read XML file into DOM
+
+		yake::data::dom::xml::XmlSerializer ser;
+		ser.parse( fn, false );
+		YAKE_ASSERT( ser.getDocumentNode() )( fn ).error("Could not parse dotScene document!");
+
+		// Parse DOM and create graphical objects
+
+		yake::data::parser::xode::XODEParserV1 xodeparser;
+
+		Physical* pPhysical = new Physical(/**ctx.model_*/);
+
+		const String namePrefix = _T("model:") + ctx.model_->getName() + _T("/")  // model
+									+ (name.empty() ? _T("") : (name + _T("/"))); // component
+		XODEListener xodeListener( *pPhysical, pPWorld, namePrefix );
+
+		xodeparser.subscribeToBodySignal( Bind1( &XODEListener::processBody, &xodeListener ) );
+		xodeparser.subscribeToGeomSignal( Bind1( &XODEListener::processGeom, &xodeListener ) );
+
+		if (!xodeparser.load( ser.getDocumentNode() ))
+		{
+			YAKE_SAFE_DELETE( pPhysical );
+		}
+
+		ctx.model_->addComponent( pPhysical, name );
+	}
+
+} // namespace model
+} // namespace yake

Added: trunk/yake/src/yake/model/yakeXODEListener.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeXODEListener.cpp	2006-06-12 21:26:14 UTC (rev 1333)
+++ trunk/yake/src/yake/model/yakeXODEListener.cpp	2006-06-12 21:27:15 UTC (rev 1334)
@@ -0,0 +1,214 @@
+/*
+	 ------------------------------------------------------------------------------------
+	 This file is part of YAKE
+	 Copyright	2004 The YAKE Team
+	 For the latest information visit http://www.yake.org 
+	 ------------------------------------------------------------------------------------
+	 This program is free software; you can redistribute it and/or modify it under
+	 the terms of the GNU Lesser General Public License as published by the Free Software
+	 Foundation; either version 2 of the License, or (at your option) any later
+	 version.
+ 
+	 This program is distributed in the hope that it will be useful, but WITHOUT
+	 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+	 FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+ 
+	 You should have received a copy of the GNU Lesser General Public License along with
+	 this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+	 Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+	 http://www.gnu.org/copyleft/lesser.txt.
+	 ------------------------------------------------------------------------------------
+	 If you are interested in another license model contact the Yake Team via
+	 E-Mail: team at yake.org.
+	 For more information see the LICENSE file in the root directory of the
+	 source code distribution.
+	 ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"
+#include "yake/model/prerequisites.h"
+#include "yake/model/model.h"
+#include "yake/model/model_physical_xode_loader.h"
+
+namespace yake {
+namespace model {
+
+	//-----------------------------------------------------
+	void XODEListener::processBody( const parser_t::BodyDesc& desc )
+	{
+		YAKE_LOG( "XODE listener: processing body description..." );
+
+		// create actor
+		physics::IActorPtr pDynActor = physicalWorld_->createActor( physics::ACTOR_DYNAMIC );
+
+		// we need to zero out the mass.. @todo fix comment
+		pDynActor->getBodyPtr()->setMass( 1. );
+
+		YAKE_ASSERT( pDynActor != NULL ).error( "Failed to create actor!" );
+
+		// set transform. TODO what about scale?
+		pDynActor->setPosition( desc.transform_.position_ );
+		pDynActor->setOrientation( desc.transform_.rotation_ );
+
+		// adding to collection
+		ActorInfo info;
+		info.actor_ = pDynActor;
+		info.parentName_ = desc.parentName_;
+
+		actors_[ desc.name_ ] = info;
+
+		// filling owner model
+		owner_.addActor( pDynActor, desc.name_ );
+
+		YAKE_LOG( "XODE listener: Success." );
+	}
+
+	//-----------------------------------------------------
+	void XODEListener::processGeom( const parser_t::GeomDesc& desc )
+	{
+		YAKE_LOG( "XODE listener: processing geom description..." );
+
+		physics::IActorPtr parentActor = NULL;
+
+		// search for parent in actors
+		ActorMap::iterator actor = actors_.find( desc.parentName_ );
+
+		if ( actor != actors_.end() )
+		{
+			// parent actor found!
+			parentActor = actor->second.actor_;
+		}
+		else
+		{
+			YAKE_LOG( "XODE listener: geom parent not found... creating static actor. " );
+		    
+			// create static actor
+			parentActor = physicalWorld_->createActor( physics::ACTOR_STATIC );
+
+			// add to collection
+			ActorInfo info;
+			info.actor_ = parentActor;
+			info.parentName_ = ""; // FIXME what should be here? a space perhaps?
+
+			actors_[ desc.parentName_ ] = info; 
+		}
+
+		physics::IShape* shape = parentActor->createShape( *desc.shape_ );
+
+		GeomInfo info;
+		info.shape_ = shape;
+		info.parentName_ = desc.parentName_;
+
+		// add to collection 
+		geoms_[ desc.name_ ] = info;
+
+		YAKE_LOG( "XODE listener: Success." );
+	}
+
+	//-----------------------------------------------------
+	void XODEListener::processMaterial( const parser_t::MaterialDesc& desc )
+	{
+		YAKE_LOG( "XODE listener: processing material description..." );
+
+		physics::IMaterial* material = physicalWorld_->createMaterial( desc.material_, desc.name_ );
+
+		// find parent
+		GeomMap::iterator shape = geoms_.find( desc.parentName_ );
+
+		if ( shape != geoms_.end() )
+		{
+			YAKE_LOG( "XODE listener: shape found! Applying material..." );
+
+			// apply material to shape
+			shape->second.shape_->setMaterial( material );
+		}
+
+		MaterialInfo info;
+		info.material_ = material;
+		info.parentName_ = desc.parentName_;
+
+		// add to collection
+		materials_[ desc.name_ ] = info;
+
+		YAKE_LOG( "XODE listener: Success." );
+	}
+
+	//-----------------------------------------------------
+	void XODEListener::processMass( const parser_t::MassDesc& desc )
+	{
+		YAKE_LOG( "XODE listener: processing mass description..." );
+
+		// search for parent in actors
+		ActorMap::iterator actor = actors_.find( desc.parentName_ );
+
+		if ( actor != actors_.end() )
+		{
+			// parent actor found!
+			physics::IBody& body = actor->second.actor_->getBody();
+
+			YAKE_LOG( "XODE listener: owner body found. Adding mass..." );
+
+			body.addMass( *desc.mass_ );
+
+			// TODO process mass... add to collection etc.
+		}
+
+		YAKE_LOG( "XODE listener: Success." );
+	}
+
+	//-----------------------------------------------------
+	void XODEListener::processJoint( const parser_t::JointDesc& desc )
+	{
+		YAKE_LOG( "XODE listener: processing joint description..." );
+
+		// storing joint description for further processing...
+		jointDescriptions_.push_back( desc );
+
+		YAKE_LOG( "XODE listener: Success." );
+	}
+
+	//-----------------------------------------------------
+	void XODEListener::postprocess()
+	{
+		// create joints here
+		YAKE_LOG( "XODE listener: postprocessing..." );
+
+		// TODO only implemented creation of joint connecting dynamic objects
+
+		JointDescVector::iterator end = jointDescriptions_.end();
+		for( JointDescVector::iterator i = jointDescriptions_.begin(); i != end; ++i )
+		{
+			parser_t::JointDesc& desc = *i;
+
+			// search for connected actors
+
+			YAKE_LOG( "XODE listener: processing " + desc.name_ + " ... " );
+			YAKE_LOG( "XODE listener: searching for actors [0]: " + desc.body1_ + ", [1]: " + desc.body2_ );
+
+			ActorMap::iterator actor0 = actors_.find( desc.body1_ );
+			ActorMap::iterator actor1 = actors_.find( desc.body2_ );
+
+			if ( actor0 == actors_.end() || actor1 == actors_.end() )
+			{
+				YAKE_LOG( "XODE listener: Failed to find actors... :( " );
+				continue;
+			}
+
+			desc.joint_->actor0 = actor0->second.actor_;
+			desc.joint_->actor1 = actor1->second.actor_;
+
+			physics::IJointPtr joint = physicalWorld_->createJoint( *desc.joint_ );
+
+			JointInfo info;
+			info.joint_ = joint;
+			info.parentName_ = desc.parentName_;
+
+			// add to collection
+			joints_[ desc.name_ ] = info;
+		}
+
+		YAKE_LOG( "XODE listener: finished postprocessing." );
+	}
+
+} //model
+} //yake
+



From codeandroid at berlios.de  Mon Jun 12 23:27:30 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Mon, 12 Jun 2006 23:27:30 +0200
Subject: [Yake-svn] r1335 - in trunk/yake/yake: loader model
Message-ID: <200606122127.k5CLRUjG023560@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-12 23:27:29 +0200 (Mon, 12 Jun 2006)
New Revision: 1335

Added:
   trunk/yake/yake/loader/yakeDotLinkLoader.h
   trunk/yake/yake/loader/yakeXODEParser.h
   trunk/yake/yake/model/model_link_dotlink_loader.h
   trunk/yake/yake/model/model_physical_xode_loader.h
Modified:
   trunk/yake/yake/loader/loader.h
   trunk/yake/yake/model/model.h
   trunk/yake/yake/model/model_component.h
   trunk/yake/yake/model/model_graphical_dotscene_loader.h
   trunk/yake/yake/model/model_link.h
Log:
added physics/XODE and model/dotLink support

Modified: trunk/yake/yake/loader/loader.h
===================================================================
--- trunk/yake/yake/loader/loader.h	2006-06-12 21:27:15 UTC (rev 1334)
+++ trunk/yake/yake/loader/loader.h	2006-06-12 21:27:29 UTC (rev 1335)
@@ -29,5 +29,6 @@
 
 #include "yake/loader/prerequisites.h"
 #include "yake/loader/yakeDotScene.h"
+#include "yake/loader/yakeXODEParser.h"
 
 #endif

Added: trunk/yake/yake/loader/yakeDotLinkLoader.h
===================================================================
--- trunk/yake/yake/loader/yakeDotLinkLoader.h	2006-06-12 21:27:15 UTC (rev 1334)
+++ trunk/yake/yake/loader/yakeDotLinkLoader.h	2006-06-12 21:27:29 UTC (rev 1335)
@@ -0,0 +1,53 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright ? 2004 The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#ifndef YAPP_DOTLINKLOADER_H
+#define YAPP_DOTLINKLOADER_H
+
+#include <yapp/base/yappPrerequisites.h>
+
+namespace yake {
+namespace model {
+
+	class YAPP_BASE_API DotLinkLoader
+	{
+	public:
+		DotLinkLoader();
+		~DotLinkLoader();
+
+		bool load( const String & rDotLinkFilename, complex::Model & rModel );
+		bool load( const data::dom::INode & rLinksNode, complex::Model & rModel );
+
+		typedef SharedPtr<ModelLink> SharedModelLinkPtr;
+		typedef Deque< SharedModelLinkPtr > SharedModelLinkList;
+	private:
+		void parseLink( const data::dom::INode & rLinkNode );
+		complex::Model*		mpModel;
+	};
+
+}
+}
+#endif

Added: trunk/yake/yake/loader/yakeXODEParser.h
===================================================================
--- trunk/yake/yake/loader/yakeXODEParser.h	2006-06-12 21:27:15 UTC (rev 1334)
+++ trunk/yake/yake/loader/yakeXODEParser.h	2006-06-12 21:27:29 UTC (rev 1335)
@@ -0,0 +1,257 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright  2004 The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#ifndef YAKE_DATA_XODEPARSER_H
+#define YAKE_DATA_XODEPARSER_H
+
+#include <yake/loader/prerequisites.h>
+#include <yake/data/yakeData.h>
+#include <yake/physics/yakePhysics.h>
+
+namespace yake {
+namespace data {
+namespace parser {
+namespace xode {
+
+	/** XODEParser base class providing default implementation for DOM parsing.
+	*/
+	class YAKE_LOADER_API XODEParser
+	{
+	public:
+		typedef SharedPtr<dom::INode> NodeSharedPtr;
+		typedef dom::NodeList::const_iterator NodeListIter;
+
+		
+		XODEParser();
+		virtual ~XODEParser() {}
+
+		String getName() const
+		{ 
+			return "yake.data.xode";
+		}
+
+		virtual Version getVersion() const = 0;
+
+		/** Build physics model from DOM!
+			\param file 
+			\return 
+		*/
+		virtual bool load( const NodeSharedPtr docNode );
+
+		/** Prepare for next run of load/store.
+		*/
+		virtual void reset();
+		
+		/// XODE "transform" node representation
+		struct Transform
+		{
+			math::Vector3		position_;
+			math::Quaternion	rotation_;
+			math::Vector3		scale_;
+			
+			Transform() : scale_( math::Vector3::kUnitScale )
+			{
+			}
+			
+			bool isIdentity() const
+			{
+				bool result = scale_ == math::Vector3::kUnitScale;
+				result &= position_ == math::Vector3::kZero;
+				result &= rotation_ == math::Quaternion::kZero;
+				
+				return result;
+			}
+			
+			const Transform getDerivedTransform( const Transform& parentTransform )
+			{
+				Transform result;
+				
+				const math::Quaternion& rParRot = parentTransform.rotation_;
+				const math::Vector3& rParPos = parentTransform.position_;
+				const math::Vector3& rParScale = parentTransform.scale_;
+				
+				result.position_ = parentTransform.position_ 
+					+ rParRot*( position_*rParScale );
+					
+				result.rotation_ = rParRot*rotation_;
+				
+				result.scale_ = scale_*rParScale;  
+				
+				return result;
+			}
+		};
+
+		// Event-spawning parser makes heavy use of these
+		struct Desc
+		{
+		    String	name_;
+		    String	parentName_;
+		    Transform	transform_;
+		};
+
+		struct BodyDesc : public Desc
+		{
+		};
+
+		struct GeomDesc : public Desc
+		{
+		    SharedPtr<physics::IShape::Desc> shape_;
+		};
+
+		struct MassDesc : public Desc
+		{
+		    SharedPtr<physics::IBody::MassDesc> mass_;
+		};
+
+		struct JointDesc : public Desc
+		{
+		    String body1_;
+		    String body2_;
+
+		    SharedPtr<physics::IJoint::DescBase> joint_;
+		};
+
+		struct MaterialDesc : public Desc
+		{
+		    physics::IMaterial::Desc material_;
+		};
+		
+		typedef SignalX< void( const BodyDesc& ) > BodySignal;
+		typedef SignalX< void( const GeomDesc& ) > GeomSignal;
+		typedef SignalX< void( const MassDesc& ) > MassSignal;
+		typedef SignalX< void( const JointDesc& ) > JointSignal;
+		typedef SignalX< void( const MaterialDesc& ) > MaterialSignal;
+		typedef SignalX< void ( void ) > EventSignal; // special event handler type
+	
+		SignalConnection subscribeToBodySignal( const BodySignal::slot_type& slot )
+		{ return sigBody_.connect(slot); } 
+		SignalConnection subscribeToGeomSignal( const GeomSignal::slot_type& slot )
+		{ return sigGeom_.connect(slot); } 
+		SignalConnection subscribeToMassSignal( const MassSignal::slot_type& slot )
+		{ return sigMass_.connect(slot); } 
+		SignalConnection subscribeToJointSignal( const JointSignal::slot_type& slot )
+		{ return sigJoint_.connect(slot); } 
+		SignalConnection subscribeToMaterialSignal( const MaterialSignal::slot_type& slot )
+		{ return sigMaterial_.connect(slot); } 
+
+		SignalConnection subscribeToParseEndedSignal( const EventSignal::slot_type& slot )
+		{ return sigParseEnded_.connect( slot ); } 
+
+		typedef AssocVector< String, BodyDesc > BodyDescMap;
+		typedef AssocVector< String, GeomDesc > GeomDescMap;
+		typedef AssocVector< String, MassDesc > MassDescMap;
+		typedef AssocVector< String, JointDesc > JointDescMap;
+		typedef AssocVector< String, MaterialDesc > MaterialDescMap;
+
+		const BodyDescMap& getBodyDescriptions() { return bodyDescriptions_; }
+		const GeomDescMap& getGeomDescriptions() { return geomDescriptions_; }
+		const MassDescMap& getMassDescriptions() { return massDescriptions_; }
+		const JointDescMap& getJointDescriptions() { return jointDescriptions_; }
+		const MaterialDescMap& getMaterialDescriptions() { return materialDescriptions_; }
+		
+	protected:
+		BodySignal	sigBody_;
+		GeomSignal	sigGeom_;
+		MassSignal	sigMass_;
+		JointSignal	sigJoint_;
+		MaterialSignal	sigMaterial_;
+		EventSignal	sigParseEnded_;
+	
+		BodyDescMap bodyDescriptions_;
+		GeomDescMap geomDescriptions_;
+		MassDescMap massDescriptions_;
+		JointDescMap jointDescriptions_;
+		MaterialDescMap materialDescriptions_;
+		
+		/// Default implementations for common functions.
+		virtual void readXODE( const NodeSharedPtr pNode );
+		virtual void readWorld( const NodeSharedPtr pWorldNode );
+		virtual void readSpace( const NodeSharedPtr pSpaceNode, const String& parent );
+		virtual void readBody( const NodeSharedPtr pBodyNode, const String& parent );
+		virtual void readGeom( const NodeSharedPtr pGeomNode, const String& parent , 
+			const Transform& rParentTransform = Transform(), bool absoluteTransform = false );
+		virtual void readBox( const NodeSharedPtr pNode, real& sX, real& sY, real& sZ );
+		virtual void readCappedCylinder( const NodeSharedPtr pNode, real& radius, real& length );
+		virtual void readCone( const NodeSharedPtr pNode, real& radius, real& length );
+		virtual void readCylinder( const NodeSharedPtr pNode, real& radius, real& length );
+		virtual void readPlane( const NodeSharedPtr pNode, real& a, real& b, real& c, real& d );
+		virtual void readRay( const NodeSharedPtr pNode, real& length );
+		virtual void readSphere( const NodeSharedPtr pNode, real& radius );
+		virtual void readTrimesh( const NodeSharedPtr pNode, physics::TriangleMeshDesc::VertexVector& rVertices, physics::TriangleMeshDesc::IndexVector& rIndices );
+		virtual void readVertices( const NodeSharedPtr pNode, physics::TriangleMeshDesc::VertexVector& rVertices );
+		virtual void readIndices( const NodeSharedPtr pNode, physics::TriangleMeshDesc::IndexVector& rIndices );
+		
+		virtual void readTransform( const NodeSharedPtr pTransformNode, Transform& rTrans );
+
+		virtual void readVector3( const NodeSharedPtr pVecNode, math::Vector3& rVec );  
+		virtual void readPosition( const NodeSharedPtr pPosNode, math::Vector3& rPos );  
+		virtual void readQuaternion( const NodeSharedPtr pQuatNode, math::Quaternion& rQuat );
+		virtual void readRotation( const NodeSharedPtr pRotNode, math::Quaternion& rRot );
+		virtual void readScale( const NodeSharedPtr pScaleNode, math::Vector3& rScale );  
+		virtual void readAxisAngleRot( const NodeSharedPtr pRotNode, math::Quaternion& rRot );
+		virtual void readMass( const NodeSharedPtr pMassNode, const String& parent , const Transform& rParentTransform ); 
+		virtual void readMassShape( const NodeSharedPtr pMShapeNode, const String& parent, const Transform& rParentTransform ); 
+		virtual void readMassAdjust( const NodeSharedPtr pMAdjustNode, const String& parent ); 
+		virtual void readJoint( const NodeSharedPtr pJointNode, const String& parent , const Transform& rParentTransform = Transform() );
+		
+		virtual physics::IJoint::DescBase* readBall( const NodeSharedPtr pJointNode, const Transform& rJointTransform );
+		virtual physics::IJoint::DescBase* readFixed( const NodeSharedPtr pJointNode, const Transform& rJointTransform );
+		virtual physics::IJoint::DescBase* readHinge( const NodeSharedPtr pJointNode, const Transform& rJointTransform );
+		virtual physics::IJoint::DescBase* readHinge2( const NodeSharedPtr pJointNode, const Transform& rJointTransform );
+		virtual physics::IJoint::DescBase* readSlider( const NodeSharedPtr pJointNode, const Transform& rJointTransform );
+		virtual physics::IJoint::DescBase* readUniversal( const NodeSharedPtr pJointNode, const Transform& rJointTransform );
+		
+		virtual void readAnchor( const NodeSharedPtr pAnchorNode, math::Vector3& rAnchor, const Transform& rJointTransform );
+		virtual void readAxis( const NodeSharedPtr pAxisNode, math::Vector3& rAxis, const Transform& rJointTransform );
+		virtual void readMaterialExt( const NodeSharedPtr pNode, const String& parent  );
+		
+		// override to read xode extensions unknown to original parser
+		virtual void readExtension( const NodeSharedPtr, 
+			const String& parent, 
+			const Transform& parentTransformIfAny );
+
+	private:
+		NodeSharedPtr		mDocNode;
+	};
+	
+	class YAKE_LOADER_API XODEParserV1 : public XODEParser
+	{
+	public:
+		virtual ~XODEParserV1() {}
+		
+		virtual Version getVersion() const
+		{ 
+			return Version( 0, 5, 2 );
+		}
+	};
+
+} // xode
+} // parser
+} // data
+} // yake
+
+#endif
+

Modified: trunk/yake/yake/model/model.h
===================================================================
--- trunk/yake/yake/model/model.h	2006-06-12 21:27:15 UTC (rev 1334)
+++ trunk/yake/yake/model/model.h	2006-06-12 21:27:29 UTC (rev 1335)
@@ -42,13 +42,24 @@
 namespace yake {
 namespace model {
 	///@todo move out!!!
-	struct CentralController
+	struct CentralControllerBase
 	{
+		virtual ~CentralControllerBase() {}
+
 		// parameters: frame (int32), timeElapsed/dt (real)
 		typedef Signal2<void(const uint32, const real)> PhysicsUpdateSignal;
 		typedef Signal2<void(const uint32, const real)> GraphicsUpdateSignal;
-		SignalConnection subscribeToPhysicsUpdate(const PhysicsUpdateSignal::slot_type&); 
-		SignalConnection subscribeToGraphicsUpdate(const PhysicsUpdateSignal::slot_type&);
+		SignalConnection subscribeToPhysicsUpdate(const PhysicsUpdateSignal::slot_type& slot)
+		{ return physicsUpdateSignal_.connect(slot); }
+		SignalConnection subscribeToGraphicsUpdate(const GraphicsUpdateSignal::slot_type& slot)
+		{ return graphicsUpdateSignal_.connect(slot); }
+		void triggerPhysicsUpdateSignal(const uint32 si, const real dt)
+		{ physicsUpdateSignal_(si,dt); }
+		void triggerGraphicsUpdateSignal(const uint32 si, const real dt)
+		{ graphicsUpdateSignal_(si,dt); }
+	protected:
+		PhysicsUpdateSignal		physicsUpdateSignal_;
+		GraphicsUpdateSignal	graphicsUpdateSignal_;
 	};
 
 	template<typename T>
@@ -91,7 +102,7 @@
 				only ever a single link (instead of having one for each
 				pair of source/target objects).
 		*/
-		ModelMovableLink* createLink(Movable*,Movable*,const String& linkType = "yake.movable");
+		ModelMovableLink* createLink(Movable*,Movable*,const String& linkType = _T("yake.movable"));
 		ModelMovableLink* createDirectLink(Movable*,Movable*); // uses "yake.movable"
 		ModelMovableLink* createWorldSpaceLink(Movable*,Movable*); // uses "yake.movable_world"
 
@@ -115,10 +126,12 @@
 		ModelManager();
 		~ModelManager();
 
-		Model* createModel(const String&);
+		Model* createModel(const String& modelName, const String& def);
+		void clear();
 
 		void setCreationContext_GraphicalWorld(graphics::IWorld*);
 		void setCreationContext_PhysicalWorld(physics::IWorld*);
+		void setCreationContext_CentralController(CentralControllerBase*);
 	private:
 		ModelManager(const ModelManager&);
 		ModelManager& operator=(const ModelManager&);
@@ -126,7 +139,7 @@
 		ComponentCreatorManager		creatorMgr_;
 		ComponentCreationContext	ctx_;
 
-		typedef Vector<SharedPtr<Model> > ModelList;
+		typedef AssocVector<String,SharedPtr<Model> > ModelList;
 		ModelList					models_;
 	};
 	/**@todo Move into private impl file. */

Modified: trunk/yake/yake/model/model_component.h
===================================================================
--- trunk/yake/yake/model/model_component.h	2006-06-12 21:27:15 UTC (rev 1334)
+++ trunk/yake/yake/model/model_component.h	2006-06-12 21:27:29 UTC (rev 1335)
@@ -36,9 +36,15 @@
 	{
 		ModelComponent() {}
 		virtual ~ModelComponent() {}
+		//Model* getOwner() const;
 	private:
+		//ModelComponent();
 		ModelComponent(const ModelComponent&);
 		ModelComponent& operator=(const ModelComponent&);
+	protected:
+		//ModelComponent(Model& owner) : owner_(&owner) {}
+	private:
+		//Model*	owner_;
 	};
 	typedef SharedPtr<ModelComponent> ModelComponentSharedPtr;
 	typedef std::deque<ModelComponentSharedPtr> ModelComponentList;
@@ -72,6 +78,7 @@
 		Physical& operator=(const Physical&);
 	public:
 		//@todo register factory?
+		//Physical(Model& owner);
 		Physical();
 		virtual ~Physical();
 
@@ -124,6 +131,7 @@
 	};
 	struct YAKE_MODEL_API Graphical : public ModelComponent
 	{
+		//Graphical(Model& owner);
 		Graphical();
 		virtual ~Graphical();
 		//@todo register factory?
@@ -146,6 +154,7 @@
 		void translate(const Vector3&);
 		//void rotate(const Quaternion&);
 	private:
+		//Graphical();
 		Graphical(const Graphical&);
 		Graphical& operator=(const Graphical&);
 	private:
@@ -181,12 +190,17 @@
 			return ((it != ctr.end()) ? it->second.p_ : 0);
 		}
 	};
-	//@todo move into private header
+
+	//@todo move into private header:
+
+	struct CentralControllerBase;
 	struct ComponentCreationContext
 	{
-		graphics::IWorld*	gworld_;
-		physics::IWorld*	pworld_;
-		ComponentCreationContext() : gworld_(0), pworld_(0)
+		Model*					model_;
+		graphics::IWorld*		gworld_;
+		physics::IWorld*		pworld_;
+		CentralControllerBase*	centralController_;
+		ComponentCreationContext() : model_(0), gworld_(0), pworld_(0), centralController_(0)
 		{}
 	};
 	struct YAKE_MODEL_API ComponentCreator
@@ -194,20 +208,32 @@
 		YAKE_DECLARE_REGISTRY_0(ComponentCreator, String);
 		virtual ~ComponentCreator() {}
 
-		virtual ModelComponent* create(const ComponentCreationContext& ctx, const StringMap& params) = 0;
+		virtual void create(const ComponentCreationContext& ctx, const StringMap& params) = 0;
 	};
 	struct GraphicalFromDotSceneCreator : public ComponentCreator
 	{
 		YAKE_DECLARE_CONCRETE(GraphicalFromDotSceneCreator,"graphics/dotScene");
 
-		virtual ModelComponent* create(const ComponentCreationContext& ctx, const StringMap& params);
+		virtual void create(const ComponentCreationContext& ctx, const StringMap& params);
 	};
+	struct PhysicalFromXODECreator : public ComponentCreator
+	{
+		YAKE_DECLARE_CONCRETE(PhysicalFromXODECreator,"physics/dotXODE");
+
+		virtual void create(const ComponentCreationContext& ctx, const StringMap& params);
+	};
+	struct LinkFromDotLinkCreator : public ComponentCreator
+	{
+		YAKE_DECLARE_CONCRETE(LinkFromDotLinkCreator,"model/dotLink");
+
+		virtual void create(const ComponentCreationContext& ctx, const StringMap& params);
+	};
 	struct YAKE_MODEL_API ComponentCreatorManager
 	{
 		ComponentCreatorManager();
 		~ComponentCreatorManager();
 
-		ModelComponent* create(const String& type, const ComponentCreationContext& ctx, const StringMap& params);
+		void create(const String& type, const ComponentCreationContext& ctx, const StringMap& params);
 	private:
 		ComponentCreatorManager(const ComponentCreatorManager&);
 		ComponentCreatorManager& operator=(const ComponentCreatorManager);

Modified: trunk/yake/yake/model/model_graphical_dotscene_loader.h
===================================================================
--- trunk/yake/yake/model/model_graphical_dotscene_loader.h	2006-06-12 21:27:15 UTC (rev 1334)
+++ trunk/yake/yake/model/model_graphical_dotscene_loader.h	2006-06-12 21:27:29 UTC (rev 1335)
@@ -25,8 +25,8 @@
    ------------------------------------------------------------------------------------
 */
 
-#ifndef YAPP_MODEL_GRAPHICAL_DOTSCENE_LOADER_H
-#define YAPP_MODEL_GRAPHICAL_DOTSCENE_LOADER_H
+#ifndef YAKE_MODEL_GRAPHICAL_DOTSCENE_LOADER_H
+#define YAKE_MODEL_GRAPHICAL_DOTSCENE_LOADER_H
 
 #include <yake/model/prerequisites.h>
 #include <yake/graphics/yakeGraphicsSystem.h>

Modified: trunk/yake/yake/model/model_link.h
===================================================================
--- trunk/yake/yake/model/model_link.h	2006-06-12 21:27:15 UTC (rev 1334)
+++ trunk/yake/yake/model/model_link.h	2006-06-12 21:27:29 UTC (rev 1335)
@@ -59,8 +59,14 @@
 		virtual ~Updatable() {}
 		virtual void update(const Arg0Type) = 0;
 	};
-	struct YAKE_MODEL_API ModelMovableLink : public ModelLink, public Updatable<real>
+	template<typename Arg0Type,typename Arg1Type>
+	struct Updatable2
 	{
+		virtual ~Updatable2() {}
+		virtual void update(const Arg0Type, const Arg1Type) = 0;
+	};
+	struct YAKE_MODEL_API ModelMovableLink : public ModelLink, public Updatable2<uint32,real>
+	{
 	public:
 		typedef Signal1< void(const Vector3&) > PositionSignal;
 		typedef Signal1< void(const Quaternion&) > OrientationSignal;
@@ -70,6 +76,8 @@
 		SignalConnection subscribeToPositionChanged( Movable* pMovable );
 		SignalConnection subscribeToOrientationChanged( Movable* pMovable );
 
+		void setSource(Movable* );
+		Movable* getSource() const;
 	protected:
 		ModelMovableLink();
 	protected:
@@ -78,6 +86,8 @@
 
 		Vector3				mLastPosition;
 		Quaternion			mLastOrientation;
+
+		Movable*			mSource;
 	};
 	/** A link controller designed to forward position and/or orientation to
 		to other clients using signals. Factory item id is "yake.movable".
@@ -89,7 +99,7 @@
 		YAKE_DECLARE_CONCRETE( ModelMovableDirectLink, "yake.movable" );
 
 		ModelMovableDirectLink();
-		virtual void update( const real timeElapsed );
+		virtual void update( const uint32, const real timeElapsed );
 	};
 	/** A link controller designed to forward absolute (world space) position and/or orientation to
 		to other clients using signals. Factory item id is "yake.movable".
@@ -101,7 +111,7 @@
 		YAKE_DECLARE_CONCRETE( ModelMovableWorldLink, "yake.movable_world" ); // world coordinate system
 
 		ModelMovableWorldLink();
-		virtual void update( const real timeElapsed );
+		virtual void update( const uint32, const real timeElapsed );
 	};
 	struct ModelMovableLink_decoupled : public ModelMovableLink
 	{
@@ -109,7 +119,7 @@
 		YAKE_DECLARE_CONCRETE( ModelMovableWorldLink, "yake.movable.decoupled" );
 
 		ModelMovableLink_decoupled();
-		virtual void update( const real timeElapsed );
+		virtual void update( const uint32, const real timeElapsed );
 		//@todo add history/interpolation specific code
 	};
 

Added: trunk/yake/yake/model/model_link_dotlink_loader.h
===================================================================
--- trunk/yake/yake/model/model_link_dotlink_loader.h	2006-06-12 21:27:15 UTC (rev 1334)
+++ trunk/yake/yake/model/model_link_dotlink_loader.h	2006-06-12 21:27:29 UTC (rev 1335)
@@ -0,0 +1,56 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright ? 2004 The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#ifndef YAKE_MODEL_DOTLINKLOADER_H
+#define YAKE_MODEL_DOTLINKLOADER_H
+
+#include <yake/model/prerequisites.h>
+#include <yake/data/yakeData.h>
+
+namespace yake {
+namespace model {
+
+	struct CentralControllerBase;
+	class YAKE_MODEL_API DotLinkLoader
+	{
+	public:
+		DotLinkLoader();
+		~DotLinkLoader();
+
+		bool load( const String & rDotLinkFilename, Model & rModel, CentralControllerBase& centralController );
+		bool load( const yake::data::dom::INode & rLinksNode, Model & rModel, CentralControllerBase& centralController );
+
+		typedef SharedPtr<ModelLink> SharedModelLinkPtr;
+		typedef Deque< SharedModelLinkPtr > SharedModelLinkList;
+	private:
+		void parseLink( const data::dom::INode & rLinkNode );
+		Model*					mpModel;
+		CentralControllerBase*	mpCentralController;
+	};
+
+}
+}
+#endif

Added: trunk/yake/yake/model/model_physical_xode_loader.h
===================================================================
--- trunk/yake/yake/model/model_physical_xode_loader.h	2006-06-12 21:27:15 UTC (rev 1334)
+++ trunk/yake/yake/model/model_physical_xode_loader.h	2006-06-12 21:27:29 UTC (rev 1335)
@@ -0,0 +1,125 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright  2004 The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+
+#ifndef YAKE_MODEL_PHYSICAL_XODE_LOADER_H
+#define YAKE_MODEL_PHYSICAL_XODE_LOADER_H
+
+#include <yake/model/prerequisites.h>
+#include <yake/physics/yakePhysics.h>
+#include <yake/loader/yakeXODEParser.h>
+
+namespace yake {
+namespace model {
+
+    /** Class implements DotSceneParser's listener. Creates graphical objects and places
+     * them in model::Graphical object.
+     */
+    class YAKE_MODEL_API XODEListener
+    {
+	public:
+	    XODEListener( Physical& owner, physics::IWorld* physWorld, const String& namePrefix = _T("") ) : 
+			owner_( owner ), 
+			physicalWorld_( physWorld ),
+			namePrefix_(namePrefix)
+	    {}
+
+	    virtual ~XODEListener() {}		
+
+		typedef yake::data::parser::xode::XODEParser parser_t;
+
+	    virtual void processBody( const parser_t::BodyDesc& desc );
+	    virtual void processGeom( const parser_t::GeomDesc& desc );
+	    virtual void processMass( const parser_t::MassDesc& desc );
+	    virtual void processJoint( const parser_t::JointDesc& desc );
+	    virtual void processMaterial( const parser_t::MaterialDesc& desc );
+	    virtual void postprocess();
+
+		physics::IJoint* getJointByName( const String& name )
+	    {
+			JointMap::const_iterator it = joints_.find( name );
+			return (it == joints_.end()) ? 0 : it->second.joint_;
+	    }
+
+	protected:
+
+	    struct ActorInfo
+	    {
+		physics::IActor*		actor_;
+		String					parentName_;
+	    };
+	    
+	    struct GeomInfo
+	    {
+		physics::IShape*		shape_;
+		String					parentName_;
+	    };
+
+	    struct MassInfo
+	    {
+		physics::IBody::MassDesc	mass_;
+		String						parentName_;
+	    };
+
+	    struct JointInfo
+	    {
+		physics::IJoint*		joint_;
+		String					parentName_;
+	    };
+
+	    struct MaterialInfo
+	    {
+		physics::IMaterial*		material_;
+		String					parentName_;
+	    };
+
+	    typedef AssocVector< String, ActorInfo > ActorMap;
+	    typedef AssocVector< String, GeomInfo > GeomMap;
+	    typedef AssocVector< String, MassInfo > MassMap;
+	    typedef AssocVector< String, JointInfo > JointMap;
+	    typedef AssocVector< String, MaterialInfo > MaterialMap;
+	    typedef Vector< typename parser_t::JointDesc > JointDescVector;
+
+	    JointDescVector jointDescriptions_;
+
+	    ActorMap	actors_;
+	    GeomMap	geoms_;
+	    MassMap	masses_;
+	    JointMap	joints_;
+	    MaterialMap materials_;
+
+	    physics::IWorld*	physicalWorld_;
+
+	    Physical&			owner_;
+		String				namePrefix_;
+    };
+
+
+} // model
+} // yake
+
+#endif 
+



From codeandroid at berlios.de  Mon Jun 12 23:27:53 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Mon, 12 Jun 2006 23:27:53 +0200
Subject: [Yake-svn] r1336 - trunk/yake/scripts/msvc8
Message-ID: <200606122127.k5CLRrXg023594@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-12 23:27:53 +0200 (Mon, 12 Jun 2006)
New Revision: 1336

Modified:
   trunk/yake/scripts/msvc8/loader.vcproj
   trunk/yake/scripts/msvc8/model.vcproj
Log:
added physics/XODE and model/dotLink support

Modified: trunk/yake/scripts/msvc8/loader.vcproj
===================================================================
--- trunk/yake/scripts/msvc8/loader.vcproj	2006-06-12 21:27:29 UTC (rev 1335)
+++ trunk/yake/scripts/msvc8/loader.vcproj	2006-06-12 21:27:53 UTC (rev 1336)
@@ -215,6 +215,10 @@
 				RelativePath="..\..\src\yake\loader\yakeDotScene.cpp"
 				>
 			</File>
+			<File
+				RelativePath="..\..\src\yake\loader\yakeXODEParser.cpp"
+				>
+			</File>
 		</Filter>
 		<Filter
 			Name="inc"
@@ -237,6 +241,10 @@
 				RelativePath="..\..\yake\loader\yakeDotScene.h"
 				>
 			</File>
+			<File
+				RelativePath="..\..\yake\loader\yakeXODEParser.h"
+				>
+			</File>
 		</Filter>
 	</Files>
 	<Globals>

Modified: trunk/yake/scripts/msvc8/model.vcproj
===================================================================
--- trunk/yake/scripts/msvc8/model.vcproj	2006-06-12 21:27:29 UTC (rev 1335)
+++ trunk/yake/scripts/msvc8/model.vcproj	2006-06-12 21:27:53 UTC (rev 1336)
@@ -216,6 +216,10 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\yake\model\yakeDotLinkLoader.cpp"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\yake\model\yakeGraphical.cpp"
 				>
 			</File>
@@ -228,6 +232,10 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\yake\model\yakeLinkCreator.cpp"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\yake\model\yakeModel.cpp"
 				>
 			</File>
@@ -236,6 +244,10 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\yake\model\yakeModelLink.cpp"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\yake\model\yakeModelLinkContainer.cpp"
 				>
 			</File>
@@ -244,9 +256,21 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\yake\model\yakeModelMovableLink.cpp"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\yake\model\yakePhysical.cpp"
 				>
 			</File>
+			<File
+				RelativePath="..\..\src\yake\model\yakePhysicalCreator.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\yake\model\yakeXODEListener.cpp"
+				>
+			</File>
 		</Filter>
 		<Filter
 			Name="inc"
@@ -270,6 +294,14 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\yake\model\model_link_dotlink_loader.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\yake\model\model_physical_xode_loader.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\yake\model\pch.h"
 				>
 			</File>



From codeandroid at berlios.de  Tue Jun 13 00:11:27 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 13 Jun 2006 00:11:27 +0200
Subject: [Yake-svn] r1337 - trunk/yake/yapp/base
Message-ID: <200606122211.k5CMBR6a028368@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-13 00:11:26 +0200 (Tue, 13 Jun 2006)
New Revision: 1337

Modified:
   trunk/yake/yapp/base/yapp.h
Log:
remove old 'model' and 'loader' components

Modified: trunk/yake/yapp/base/yapp.h
===================================================================
--- trunk/yake/yapp/base/yapp.h	2006-06-12 21:27:53 UTC (rev 1336)
+++ trunk/yake/yapp/base/yapp.h	2006-06-12 22:11:26 UTC (rev 1337)
@@ -35,11 +35,8 @@
 
 #include <yapp/base/yappPrerequisites.h>
 #include <yake/base/yake.h>
-#include <yapp/model/yakeModel.h>
-#include <yapp/model/yakeComplexModel.h>
 #include <yapp/base/event/yakeEvent.h>
 #include <yapp/base/yakeTask.h>
-#include <yapp/model/yakeModelMovableLink.h>
 /*
 #include <yapp/gui/yappGUIVisual.h>
 #include <yapp/gui/yappButton.h>



From codeandroid at berlios.de  Tue Jun 13 00:12:09 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 13 Jun 2006 00:12:09 +0200
Subject: [Yake-svn] r1338 - trunk/yake/yapp/vehicle
Message-ID: <200606122212.k5CMC9Jv028422@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-13 00:12:09 +0200 (Tue, 13 Jun 2006)
New Revision: 1338

Modified:
   trunk/yake/yapp/vehicle/yakeInterfaces.h
   trunk/yake/yapp/vehicle/yakeNativeOde.h
   trunk/yake/yapp/vehicle/yakePrerequisites.h
   trunk/yake/yapp/vehicle/yakeTemplates.h
Log:
ported to new 'model' component

Modified: trunk/yake/yapp/vehicle/yakeInterfaces.h
===================================================================
--- trunk/yake/yapp/vehicle/yakeInterfaces.h	2006-06-12 22:11:26 UTC (rev 1337)
+++ trunk/yake/yapp/vehicle/yakeInterfaces.h	2006-06-12 22:12:09 UTC (rev 1338)
@@ -29,6 +29,7 @@
 
 #include <yapp/vehicle/yakePrerequisites.h>
 #include <yapp/vehicle/yakeTemplates.h>
+#include <yake/graphics/yakeGraphics.h>
 
 namespace yake {
 namespace vehicle {

Modified: trunk/yake/yapp/vehicle/yakeNativeOde.h
===================================================================
--- trunk/yake/yapp/vehicle/yakeNativeOde.h	2006-06-12 22:11:26 UTC (rev 1337)
+++ trunk/yake/yapp/vehicle/yakeNativeOde.h	2006-06-12 22:12:09 UTC (rev 1338)
@@ -135,7 +135,7 @@
 		typedef AssocVector<String,MountPoint*> MountPointList;
 		MountPointList		mMountPoints;
 
-		model::complex::Model*	mDebugModel;
+		model::Model*		mDebugModel;
 	};
 
 	class GearBox;

Modified: trunk/yake/yapp/vehicle/yakePrerequisites.h
===================================================================
--- trunk/yake/yapp/vehicle/yakePrerequisites.h	2006-06-12 22:11:26 UTC (rev 1337)
+++ trunk/yake/yapp/vehicle/yakePrerequisites.h	2006-06-12 22:12:09 UTC (rev 1338)
@@ -33,5 +33,6 @@
 #	define YAKE_VEH_API DLLIMPORT
 #endif
 
+#include <yake/model/model.h>
 
 #endif

Modified: trunk/yake/yapp/vehicle/yakeTemplates.h
===================================================================
--- trunk/yake/yapp/vehicle/yakeTemplates.h	2006-06-12 22:11:26 UTC (rev 1337)
+++ trunk/yake/yapp/vehicle/yakeTemplates.h	2006-06-12 22:12:09 UTC (rev 1338)
@@ -28,6 +28,7 @@
 #define YAKE_VEHICLE_TEMPLATES_H
 
 #include "yapp/vehicle/yakePrerequisites.h"
+#include "yake/physics/yakePhysics.h"
 
 namespace yake {
 namespace vehicle {



From codeandroid at berlios.de  Tue Jun 13 00:12:34 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 13 Jun 2006 00:12:34 +0200
Subject: [Yake-svn] r1339 - trunk/yake/src/yake/model
Message-ID: <200606122212.k5CMCYjv028479@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-13 00:12:34 +0200 (Tue, 13 Jun 2006)
New Revision: 1339

Modified:
   trunk/yake/src/yake/model/yakeModel.cpp
Log:
implemented functions

Modified: trunk/yake/src/yake/model/yakeModel.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeModel.cpp	2006-06-12 22:12:09 UTC (rev 1338)
+++ trunk/yake/src/yake/model/yakeModel.cpp	2006-06-12 22:12:34 UTC (rev 1339)
@@ -41,6 +41,10 @@
 	{
 		return name_; 
 	}
+	void Model::addComponent(ModelComponent* c)
+	{
+		components_.addComponent(c);
+	}
 	void Model::addComponent(ModelComponent* c, const ComponentTag& tag)
 	{
 		components_.addComponent(c,tag);
@@ -55,9 +59,19 @@
 		ModelMovableLink* link = new ModelMovableDirectLink();
 		link->setSource( from );
 		link->subscribeToPositionChanged(to);
+		link->subscribeToOrientationChanged(to);
 		this->addLink( link );
 		return link;
 	}
+	ModelMovableLink* Model::createDirectLink(yake::Movable* from, yake::Movable* to)
+	{
+		ModelMovableLink* link = new ModelMovableDirectLink();
+		link->setSource( from );
+		link->subscribeToPositionChanged(to);
+		link->subscribeToOrientationChanged(to);
+		this->addLink( link );
+		return link;
+	}
 	void Model::addLink(yake::model::ModelLink* link)
 	{
 		YAKE_ASSERT( link );



From codeandroid at berlios.de  Tue Jun 13 00:12:51 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 13 Jun 2006 00:12:51 +0200
Subject: [Yake-svn] r1340 - trunk/yake/src/yapp/samples/misc/car
Message-ID: <200606122212.k5CMCpIb028536@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-13 00:12:51 +0200 (Tue, 13 Jun 2006)
New Revision: 1340

Modified:
   trunk/yake/src/yapp/samples/misc/car/yakeDemo.cpp
Log:
ported to new 'model' component

Modified: trunk/yake/src/yapp/samples/misc/car/yakeDemo.cpp
===================================================================
--- trunk/yake/src/yapp/samples/misc/car/yakeDemo.cpp	2006-06-12 22:12:34 UTC (rev 1339)
+++ trunk/yake/src/yapp/samples/misc/car/yakeDemo.cpp	2006-06-12 22:12:51 UTC (rev 1340)
@@ -1,7 +1,8 @@
 #include <yapp/samples/misc/car/yakePCH.h>
 #include <yake/audio/yakeAudio.h>
 #include <yapp/raf/yakeRaf.h>
-#include <yapp/model/yakeModelMovableLink.h>
+#include <yake/model/model.h>
+#include <yake/model/model_link.h>
 #include <yapp/vehicle/yakeVehicle.h>
 #include <yake/input/yakeInput.h>
 
@@ -53,6 +54,16 @@
 	{
 	}
 private:
+	typedef Signal2<void(const uint32,const real)> GraphicsUpdateSignal;
+	GraphicsUpdateSignal	graphicsUpdateSig_;
+	void subscribeToGraphicsUpdate(const GraphicsUpdateSignal::slot_type& slot)
+	{
+		graphicsUpdateSig_.connect(slot);
+	}
+	void _triggerGraphicsUpdate(const uint32 si, const real dt)
+	{
+		graphicsUpdateSig_(si,dt);
+	}
 	void _createWheelVisual(const String& wheelId, graphics::ISceneNode& parentSN)
 	{
 		// scene node + wheel mesh
@@ -60,7 +71,8 @@
 		graphics::IEntity* pE = getGraphicalWorld()->createEntity("wheel1.mesh");
 		pE->setCastsShadow( true );
 		pSN->attachEntity( pE );
-		mComplex->addLink( mVehicle->getWheelInterface(wheelId), pSN );
+		model::ModelMovableLink* pLink = mComplex->createLink( mVehicle->getWheelInterface(wheelId), pSN );
+		this->subscribeToGraphicsUpdate( Bind2(&model::ModelMovableLink::update,pLink) );
 
 		// scene node + particle system for smoke...
 		pSN = getGraphicalWorld()->createSceneNode();
@@ -68,10 +80,11 @@
 		mWheelPs[wheelId] = pPS;
 		mEmitterEmissionRate[wheelId] = pPS->getEmissionRate(0);
 		pSN->attachParticleSystem( pPS );
-		model::ModelMovableLink* pLink = new model::ModelMovableLink();
+		pLink = new model::ModelMovableDirectLink();
 		pLink->setSource( mVehicle->getWheelInterface(wheelId) );
 		pLink->subscribeToPositionChanged( pSN ); //position only!
-		mComplex->addGraphicsController( pLink );
+		mComplex->addLink( pLink );
+		this->subscribeToGraphicsUpdate( Bind2(&model::ModelMovableLink::update,pLink) );
 	}
 protected:
 	virtual void onCreateScene()
@@ -91,8 +104,11 @@
 		getDefaultCamera()->setFixedYawAxis(Vector3::kUnitY);
 		getDefaultCamera()->setPosition(Vector3(7,4,-7));
 
+		//
+		getPhysicalWorld()->setGlobalGravity(Vector3(0,-9.81,0));
+
 		// create ground
-		mGround = new model::complex::Model();
+		mGround = new model::Model();
 		{
 			const real groundHeight = -2;
 			// visual
@@ -105,8 +121,8 @@
 			pGroundSN->setPosition( Vector3(0,groundHeight,0) );
 
 			model::Graphical* pG = new model::Graphical();
-			pG->addSceneNode( pGroundSN );
-			mGround->addGraphical( pG );
+			pG->addSceneNode( pGroundSN, "groundSN" );
+			mGround->addComponent( pG );
 
 			// physical
 			physics::IActorPtr pGroundPlane = getPhysicalWorld()->createActor( physics::ACTOR_STATIC );
@@ -114,15 +130,15 @@
 
 			model::Physical* pP = new model::Physical();
 			pP->addActor( pGroundPlane, "groundPlane" );
-			mGround->addPhysical( pP );
+			mGround->addComponent( pP );
 		}
 
 		// create vehicle container (e.g. for graphical objects and links)
-		mComplex = new model::complex::Model();
+		mComplex = new model::Model();
 		model::Graphical* pG = new model::Graphical();
-		mComplex->addGraphical( SharedPtr<model::Graphical>(pG) );
+		mComplex->addComponent( pG, "g" );
 		model::Physical* pP = new model::Physical();
-		mComplex->addPhysical( SharedPtr<model::Physical>(pP) );
+		mComplex->addComponent( pP, "p" );
 
 		// materials @todo read from .physics:
 		getPhysicalWorld()->createMaterial( physics::IMaterial::Desc( 0.01f, 0.01f, 0.01f ), "chassis" );
@@ -151,7 +167,7 @@
 		pE->setCastsShadow( true );
 		pSN->attachEntity( pE );
 		//pSN->setScale( Vector3::kUnitScale * razorMeshScale );
-		pG->addSceneNode(pSN);
+		pG->addSceneNode(pSN, "delorean_root");
 
 		// - wheel visuals
 		if (mVehicle->getWheelInterface("leftFrontWheel"))
@@ -163,7 +179,8 @@
 		}
 
 		// create visual <-> physics links
-		mComplex->addLink( mVehicle->getChassisMovable(), pSN );
+		model::ModelMovableLink* pLink = mComplex->createLink( mVehicle->getChassisMovable(), pSN );
+		this->subscribeToGraphicsUpdate( Bind2(&model::ModelMovableLink::update,pLink) );
 
 		// sky box
 		getGraphicalWorld()->setSkyBox("Examples/SpaceSkyBox");
@@ -238,7 +255,7 @@
 		mVehicle->getWheelInterface("rightFrontWheel")->brake(braking0);
 
 		mVehicle->updateSimulation( timeElapsed );
-		mComplex->updatePhysics( timeElapsed );
+		//mComplex->updatePhysics( timeElapsed );
 
 		ConstDequeIterator< WheelPsMap > itWheel( mWheelPs );
 		while (itWheel.hasMoreElements())
@@ -248,8 +265,10 @@
 		}
 
 		getDefaultCamera()->lookAt(mVehicle->getChassisPosition());
-		mComplex->updateGraphics( timeElapsed );
+		//mComplex->updateGraphics( timeElapsed );
 
+		this->_triggerGraphicsUpdate(0,timeElapsed);
+
 		mActiveActions.clear();
 	}
 protected:
@@ -265,9 +284,9 @@
 	{ mActiveActions.insert( input::ACTIONID_RIGHT ); }
 private:
 private:
-	model::complex::Model*	mGround;
+	model::Model*			mGround;
 	vehicle::IVehicle*		mVehicle;
-	model::complex::Model*	mComplex;
+	model::Model*			mComplex;
 	typedef AssocVector<String,real> EmitterRealMap;
 	EmitterRealMap			mEmitterMinVel;
 	EmitterRealMap			mEmitterMaxVel;



From codeandroid at berlios.de  Tue Jun 13 00:13:05 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 13 Jun 2006 00:13:05 +0200
Subject: [Yake-svn] r1341 - trunk/yake/src/yapp/vehicle
Message-ID: <200606122213.k5CMD5sS028568@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-13 00:13:05 +0200 (Tue, 13 Jun 2006)
New Revision: 1341

Modified:
   trunk/yake/src/yapp/vehicle/yakeDotVehicle.cpp
   trunk/yake/src/yapp/vehicle/yakeNativeOde.cpp
Log:
ported to new 'model' component

Modified: trunk/yake/src/yapp/vehicle/yakeDotVehicle.cpp
===================================================================
--- trunk/yake/src/yapp/vehicle/yakeDotVehicle.cpp	2006-06-12 22:12:51 UTC (rev 1340)
+++ trunk/yake/src/yapp/vehicle/yakeDotVehicle.cpp	2006-06-12 22:13:05 UTC (rev 1341)
@@ -27,6 +27,7 @@
 #include <yapp/vehicle/yakePCH.h>
 #include <yapp/vehicle/yakeVehicle.h>
 #include <yapp/vehicle/yakeDotVehicle.h>
+#include <yake/data/yakeData.h>
 
 namespace yake {
 namespace vehicle {

Modified: trunk/yake/src/yapp/vehicle/yakeNativeOde.cpp
===================================================================
--- trunk/yake/src/yapp/vehicle/yakeNativeOde.cpp	2006-06-12 22:12:51 UTC (rev 1340)
+++ trunk/yake/src/yapp/vehicle/yakeNativeOde.cpp	2006-06-12 22:13:05 UTC (rev 1341)
@@ -38,7 +38,7 @@
 #	include <yake/plugins/physicsODE/OdeWorld.h>
 #	pragma comment(lib, "physicsODE.lib")
 #	ifdef YAKE_DEBUG
-#		pragma comment(lib, "oded.lib")
+#		pragma comment(lib, "ode.lib")
 #	else
 #		pragma comment(lib, "ode.lib")
 #	endif
@@ -155,12 +155,6 @@
 		mSigUpdateEngineSimulation( timeElapsed );
 		mSigApplyThrusterToTargets();
 		_applyDriveTorqueToAxles( timeElapsed );
-
-		if (mDebugModel)
-		{
-			mDebugModel->updatePhysics(timeElapsed);
-			mDebugModel->updateGraphics(timeElapsed);
-		}
 	}
 	void GenericVehicle::_applyDriveTorqueToAxles( real timeElapsed )
 	{
@@ -275,7 +269,7 @@
 		    YAKE_LOG( "External physical body found. Searching provided model for it..." );
 
 		    // searching for actor in provided model
-		    physics::IActorPtr actor = physModel.getActorByName( tpl.mChassis.mPhysicsBody );
+		    physics::IActorPtr actor = physModel.getActor( tpl.mChassis.mPhysicsBody );
 
 		    YAKE_ASSERT( actor != NULL ).error( "Actor '" + tpl.mChassis.mPhysicsBody 
 			    +  "' was not found in physical model! Are you sure you provided the right model???" );
@@ -440,7 +434,7 @@
 	void createDebugGeometry(	const physics::IActor& actor, 
 								graphics::IWorld& GWorld, 
 								model::Graphical& graphical,
-								model::complex::Model& theModel)
+								model::Model& theModel)
 	{
 		physics::IShapePtrList shapes = actor.getShapes();
 		ConstDequeIterator<physics::IShapePtrList> itShape( shapes );
@@ -472,13 +466,13 @@
 			}
 			if (pE)
 			{
-				graphical.addSceneNode( pSN );
+				graphical.addSceneNode( pSN, uniqueName::create("yake::vehicle_dbg_geom_") );
 
-				model::ModelMovableLink* pLink = new model::ModelMovableLink();
+				model::ModelMovableLink* pLink = new model::ModelMovableDirectLink();
 				pLink->setSource( pShape );
 				pLink->subscribeToPositionChanged( pSN );
 				pLink->subscribeToOrientationChanged( pSN );
-				theModel.addGraphicsController( pLink );
+				theModel.addLink( pLink );
 			}
 			else
 				delete pSN;
@@ -488,10 +482,11 @@
 	{
 		if (mDebugModel)
 			delete mDebugModel;
-		mDebugModel = new model::complex::Model();
+		mDebugModel = new model::Model();
+		mDebugModel->setName( uniqueName::create("yake::vehicle_dbg_") );
 		model::Graphical* pGraphical = new model::Graphical();
 		createDebugGeometry( *mpChassis, GWorld, *pGraphical, *mDebugModel );
-		mDebugModel->addGraphical( pGraphical );
+		mDebugModel->addComponent( pGraphical, "gfx" );
 	}
 	void GenericVehicle::disableDebugGeometry()
 	{



From codeandroid at berlios.de  Tue Jun 13 00:13:36 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 13 Jun 2006 00:13:36 +0200
Subject: [Yake-svn] r1342 - trunk/yake/yake/model
Message-ID: <200606122213.k5CMDa1f028659@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-13 00:13:36 +0200 (Tue, 13 Jun 2006)
New Revision: 1342

Modified:
   trunk/yake/yake/model/model_link.h
Log:
added API declaration

Modified: trunk/yake/yake/model/model_link.h
===================================================================
--- trunk/yake/yake/model/model_link.h	2006-06-12 22:13:05 UTC (rev 1341)
+++ trunk/yake/yake/model/model_link.h	2006-06-12 22:13:36 UTC (rev 1342)
@@ -93,7 +93,7 @@
 		to other clients using signals. Factory item id is "yake.movable".
 		@Remarks A controller only fires signals when the values have changed!
 	*/
-	struct ModelMovableDirectLink : public ModelMovableLink
+	struct YAKE_MODEL_API ModelMovableDirectLink : public ModelMovableLink
 	{
 	public:
 		YAKE_DECLARE_CONCRETE( ModelMovableDirectLink, "yake.movable" );
@@ -105,7 +105,7 @@
 		to other clients using signals. Factory item id is "yake.movable".
 		@Remarks A controller only fires signals when the values have changed!
 	*/
-	struct ModelMovableWorldLink : public ModelMovableLink
+	struct YAKE_MODEL_API ModelMovableWorldLink : public ModelMovableLink
 	{
 	public:
 		YAKE_DECLARE_CONCRETE( ModelMovableWorldLink, "yake.movable_world" ); // world coordinate system



From codeandroid at berlios.de  Tue Jun 13 00:14:25 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 13 Jun 2006 00:14:25 +0200
Subject: [Yake-svn] r1344 - trunk/yake/scripts/msvc8
Message-ID: <200606122214.k5CMEP3N028774@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-13 00:14:25 +0200 (Tue, 13 Jun 2006)
New Revision: 1344

Modified:
   trunk/yake/scripts/msvc8/vehicle.vcproj
Log:
now using ode 0.6

Modified: trunk/yake/scripts/msvc8/vehicle.vcproj
===================================================================
--- trunk/yake/scripts/msvc8/vehicle.vcproj	2006-06-12 22:14:00 UTC (rev 1343)
+++ trunk/yake/scripts/msvc8/vehicle.vcproj	2006-06-12 22:14:25 UTC (rev 1344)
@@ -67,7 +67,7 @@
 				AdditionalDependencies="base.lib physics.lib data.lib"
 				OutputFile="$(OutDir)/$(ProjectName).dll"
 				LinkIncremental="2"
-				AdditionalLibraryDirectories="../../common/lib/$(ConfigurationName);../../dependencies/lib;../../dependencies/ode/lib"
+				AdditionalLibraryDirectories="../../common/lib/$(ConfigurationName);../../dependencies/lib;../../dependencies/ode/lib/debugdll"
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="1"
@@ -148,7 +148,7 @@
 				AdditionalDependencies="base.lib physics.lib data.lib"
 				OutputFile="$(OutDir)/$(ProjectName).dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="../../common/lib/$(ConfigurationName);../../dependencies/lib;../../dependencies/ode/lib"
+				AdditionalLibraryDirectories="../../common/lib/$(ConfigurationName);../../dependencies/lib;../../dependencies/ode/lib/releasedll"
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="1"



From codeandroid at berlios.de  Tue Jun 13 00:14:00 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 13 Jun 2006 00:14:00 +0200
Subject: [Yake-svn] r1343 - trunk/yake/scripts/msvc8
Message-ID: <200606122214.k5CME038028727@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-13 00:14:00 +0200 (Tue, 13 Jun 2006)
New Revision: 1343

Modified:
   trunk/yake/scripts/msvc8/yapp.vcproj
Log:
remove old 'model' and 'loader' components

Modified: trunk/yake/scripts/msvc8/yapp.vcproj
===================================================================
--- trunk/yake/scripts/msvc8/yapp.vcproj	2006-06-12 22:13:36 UTC (rev 1342)
+++ trunk/yake/scripts/msvc8/yapp.vcproj	2006-06-12 22:14:00 UTC (rev 1343)
@@ -507,90 +507,6 @@
 			</File>
 		</Filter>
 		<Filter
-			Name="model"
-			>
-			<File
-				RelativePath="..\..\src\yapp\model\yakeActor.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\yapp\model\yakeActor.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\src\yapp\model\yakeComplexModel.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\yapp\model\yakeComplexModel.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\src\yapp\model\yakeGraphical.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\yapp\model\yakeGraphical.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\src\yapp\model\yakeGraphicalDataImporter.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\yapp\model\yakeGraphicalDataImporter.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\yapp\model\yakeModel.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\src\yapp\model\yakeModelLink.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\yapp\model\yakeModelLink.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\src\yapp\model\yakeModelMovableLink.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\yapp\model\yakeModelMovableLink.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\src\yapp\model\yakeMountable.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\yapp\model\yakeMountable.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\src\yapp\model\yakePhysical.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\yapp\model\yakePhysical.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\src\yapp\model\yakePhysicalDataImporter.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\yapp\model\yakePhysicalDataImporter.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\yapp\model\yakeUpdaters.h"
-				>
-			</File>
-		</Filter>
-		<Filter
 			Name="messaging"
 			>
 			<File
@@ -635,50 +551,6 @@
 			</File>
 		</Filter>
 		<Filter
-			Name="loader"
-			>
-			<File
-				RelativePath="..\..\src\yapp\loader\yakeDotLinkLoader.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\yapp\loader\yakeDotLinkLoader.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\src\yapp\loader\yakeDotScene.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\yapp\loader\yakeDotScene.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\src\yapp\loader\yakeModelLinkCreator.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\yapp\loader\yakeModelLinkCreator.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\src\yapp\loader\yakeModelMovableLinkCreator.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\yapp\loader\yakeModelMovableLinkCreator.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\src\yapp\loader\yakeXODEParser.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\..\yapp\loader\yakeXODEParser.h"
-				>
-			</File>
-		</Filter>
-		<Filter
 			Name="trigger"
 			>
 			<File



From codeandroid at berlios.de  Sat Jun 17 15:33:46 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Sat, 17 Jun 2006 15:33:46 +0200
Subject: [Yake-svn] r1345 - in trunk/yake: src/yake/model yake/model
Message-ID: <200606171333.k5HDXkwD016302@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-17 15:33:43 +0200 (Sat, 17 Jun 2006)
New Revision: 1345

Modified:
   trunk/yake/src/yake/model/yakeGraphicalCreator.cpp
   trunk/yake/src/yake/model/yakeModelManager.cpp
   trunk/yake/src/yake/model/yakePhysicalCreator.cpp
   trunk/yake/yake/model/model.h
   trunk/yake/yake/model/model_component.h
Log:
added possibility to specify custom dotScene and XODE parsers as part of the model creation context

Modified: trunk/yake/src/yake/model/yakeGraphicalCreator.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeGraphicalCreator.cpp	2006-06-12 22:14:25 UTC (rev 1344)
+++ trunk/yake/src/yake/model/yakeGraphicalCreator.cpp	2006-06-17 13:33:43 UTC (rev 1345)
@@ -64,25 +64,34 @@
 
 		// Parse DOM and create graphical objects
 
-		yake::data::parser::dotscene::DotSceneParserV1 dsp;
+		data::parser::dotscene::DotSceneParser* parser = ctx.dotSceneParser_;
+		if (!parser)
+			parser = new yake::data::parser::dotscene::DotSceneParserV1();
+		YAKE_ASSERT( parser );
 
 		Graphical* pGraphical = new Graphical(/**ctx.model_*/);
 
 		const String namePrefix = _T("model:") + ctx.model_->getName() + _T("/")  // model
 									+ (name.empty() ? _T("") : (name + _T("/"))); // component
+
 		DotSceneListener dotSceneListener( *pGraphical, namePrefix );
 		dotSceneListener.reset( pGWorld );
 
-		dsp.subscribeToNodeSignal( Bind1( &DotSceneListener::processSceneNode, &dotSceneListener ) );
-		dsp.subscribeToEntitySignal( Bind1( &DotSceneListener::processEntity, &dotSceneListener ) );
-		dsp.subscribeToCameraSignal( Bind1( &DotSceneListener::processCamera, &dotSceneListener ) );
-		dsp.subscribeToLightSignal( Bind1( &DotSceneListener::processLight, &dotSceneListener ) );
+		parser->subscribeToNodeSignal( Bind1( &DotSceneListener::processSceneNode, &dotSceneListener ) );
+		parser->subscribeToEntitySignal( Bind1( &DotSceneListener::processEntity, &dotSceneListener ) );
+		parser->subscribeToCameraSignal( Bind1( &DotSceneListener::processCamera, &dotSceneListener ) );
+		parser->subscribeToLightSignal( Bind1( &DotSceneListener::processLight, &dotSceneListener ) );
 
-		if (!dsp.load( ser.getDocumentNode() ))
+		if (!parser->load( ser.getDocumentNode() ))
 		{
 			YAKE_SAFE_DELETE( pGraphical );
 		}
 
+		if (!ctx.dotSceneParser_)
+		{
+			YAKE_SAFE_DELETE( parser );
+		}
+
 		ctx.model_->addComponent( pGraphical, name );
 	}
 

Modified: trunk/yake/src/yake/model/yakeModelManager.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeModelManager.cpp	2006-06-12 22:14:25 UTC (rev 1344)
+++ trunk/yake/src/yake/model/yakeModelManager.cpp	2006-06-17 13:33:43 UTC (rev 1345)
@@ -124,6 +124,14 @@
 	{
 		ctx_.centralController_ = c;
 	}
+	void ModelManager::setCreationContext_DotSceneParser(data::parser::dotscene::DotSceneParser* parser)
+	{
+		ctx_.dotSceneParser_ = parser;
+	}
+	void ModelManager::setCreationContext_XODEParser(data::parser::xode::XODEParser* parser)
+	{
+		ctx_.xodeParser_ = parser;
+	}
 
 } // namespace model
 } // namespace yake

Modified: trunk/yake/src/yake/model/yakePhysicalCreator.cpp
===================================================================
--- trunk/yake/src/yake/model/yakePhysicalCreator.cpp	2006-06-12 22:14:25 UTC (rev 1344)
+++ trunk/yake/src/yake/model/yakePhysicalCreator.cpp	2006-06-17 13:33:43 UTC (rev 1345)
@@ -64,7 +64,10 @@
 
 		// Parse DOM and create graphical objects
 
-		yake::data::parser::xode::XODEParserV1 xodeparser;
+		data::parser::xode::XODEParser* xodeparser = ctx.xodeParser_;
+		if (!xodeparser)
+			xodeparser = new data::parser::xode::XODEParserV1();
+		YAKE_ASSERT( xodeparser );
 
 		Physical* pPhysical = new Physical(/**ctx.model_*/);
 
@@ -72,14 +75,19 @@
 									+ (name.empty() ? _T("") : (name + _T("/"))); // component
 		XODEListener xodeListener( *pPhysical, pPWorld, namePrefix );
 
-		xodeparser.subscribeToBodySignal( Bind1( &XODEListener::processBody, &xodeListener ) );
-		xodeparser.subscribeToGeomSignal( Bind1( &XODEListener::processGeom, &xodeListener ) );
+		xodeparser->subscribeToBodySignal( Bind1( &XODEListener::processBody, &xodeListener ) );
+		xodeparser->subscribeToGeomSignal( Bind1( &XODEListener::processGeom, &xodeListener ) );
 
-		if (!xodeparser.load( ser.getDocumentNode() ))
+		if (!xodeparser->load( ser.getDocumentNode() ))
 		{
 			YAKE_SAFE_DELETE( pPhysical );
 		}
 
+		if (!ctx.xodeParser_)
+		{
+			YAKE_SAFE_DELETE( xodeparser );
+		}
+
 		ctx.model_->addComponent( pPhysical, name );
 	}
 

Modified: trunk/yake/yake/model/model.h
===================================================================
--- trunk/yake/yake/model/model.h	2006-06-12 22:14:25 UTC (rev 1344)
+++ trunk/yake/yake/model/model.h	2006-06-17 13:33:43 UTC (rev 1345)
@@ -132,6 +132,8 @@
 		void setCreationContext_GraphicalWorld(graphics::IWorld*);
 		void setCreationContext_PhysicalWorld(physics::IWorld*);
 		void setCreationContext_CentralController(CentralControllerBase*);
+		void setCreationContext_DotSceneParser(data::parser::dotscene::DotSceneParser*);
+		void setCreationContext_XODEParser(data::parser::xode::XODEParser*);
 	private:
 		ModelManager(const ModelManager&);
 		ModelManager& operator=(const ModelManager&);

Modified: trunk/yake/yake/model/model_component.h
===================================================================
--- trunk/yake/yake/model/model_component.h	2006-06-12 22:14:25 UTC (rev 1344)
+++ trunk/yake/yake/model/model_component.h	2006-06-17 13:33:43 UTC (rev 1345)
@@ -30,8 +30,40 @@
 #include "yake/model/prerequisites.h"
 
 namespace yake {
+	namespace data {
+	namespace parser {
+	namespace dotscene {
+		class DotSceneParser;
+	}
+	namespace xode {
+		class XODEParser;
+	}
+	}
+	}
 namespace model {
+	//@todo move into private header:
+	struct CentralControllerBase;
+	struct ComponentCreationContext
+	{
+		Model*					model_;
+		graphics::IWorld*		gworld_;
+		physics::IWorld*		pworld_;
 
+		CentralControllerBase*	centralController_;
+
+		data::parser::dotscene::DotSceneParser*		dotSceneParser_;
+		data::parser::xode::XODEParser*				xodeParser_;
+
+		ComponentCreationContext() : 
+			model_(0),
+			gworld_(0),
+			pworld_(0),
+			centralController_(0),
+			dotSceneParser_(0),
+			xodeParser_(0)
+		{}
+	};
+
 	struct YAKE_MODEL_API ModelComponent //: public Clonable<ModelComponent>
 	{
 		ModelComponent() {}
@@ -191,18 +223,6 @@
 		}
 	};
 
-	//@todo move into private header:
-
-	struct CentralControllerBase;
-	struct ComponentCreationContext
-	{
-		Model*					model_;
-		graphics::IWorld*		gworld_;
-		physics::IWorld*		pworld_;
-		CentralControllerBase*	centralController_;
-		ComponentCreationContext() : model_(0), gworld_(0), pworld_(0), centralController_(0)
-		{}
-	};
 	struct YAKE_MODEL_API ComponentCreator
 	{
 		YAKE_DECLARE_REGISTRY_0(ComponentCreator, String);



From codeandroid at berlios.de  Sat Jun 17 16:00:20 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Sat, 17 Jun 2006 16:00:20 +0200
Subject: [Yake-svn] r1346 - in trunk/yake: src/yake/model yake/model
Message-ID: <200606171400.k5HE0KcT027913@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-17 16:00:03 +0200 (Sat, 17 Jun 2006)
New Revision: 1346

Modified:
   trunk/yake/src/yake/model/yakeGraphicalCreator.cpp
   trunk/yake/src/yake/model/yakePhysicalCreator.cpp
   trunk/yake/yake/model/model_component.h
Log:
avoid frequent memory allocation/deallocation when using default dotscene and xode parsers.

Modified: trunk/yake/src/yake/model/yakeGraphicalCreator.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeGraphicalCreator.cpp	2006-06-17 13:33:43 UTC (rev 1345)
+++ trunk/yake/src/yake/model/yakeGraphicalCreator.cpp	2006-06-17 14:00:03 UTC (rev 1346)
@@ -34,6 +34,10 @@
 
 	YAKE_REGISTER_CONCRETE(GraphicalFromDotSceneCreator)
 
+	GraphicalFromDotSceneCreator::GraphicalFromDotSceneCreator() :
+		defaultParser_( new data::parser::dotscene::DotSceneParserV1() )
+	{
+	}
 	void GraphicalFromDotSceneCreator::create(const ComponentCreationContext& ctx, const StringMap& params)
 	{
 		// Verify validity of creation context
@@ -66,7 +70,7 @@
 
 		data::parser::dotscene::DotSceneParser* parser = ctx.dotSceneParser_;
 		if (!parser)
-			parser = new yake::data::parser::dotscene::DotSceneParserV1();
+			parser = defaultParser_.get();
 		YAKE_ASSERT( parser );
 
 		Graphical* pGraphical = new Graphical(/**ctx.model_*/);
@@ -77,22 +81,22 @@
 		DotSceneListener dotSceneListener( *pGraphical, namePrefix );
 		dotSceneListener.reset( pGWorld );
 
-		parser->subscribeToNodeSignal( Bind1( &DotSceneListener::processSceneNode, &dotSceneListener ) );
-		parser->subscribeToEntitySignal( Bind1( &DotSceneListener::processEntity, &dotSceneListener ) );
-		parser->subscribeToCameraSignal( Bind1( &DotSceneListener::processCamera, &dotSceneListener ) );
-		parser->subscribeToLightSignal( Bind1( &DotSceneListener::processLight, &dotSceneListener ) );
+		SignalConnection conn1 = parser->subscribeToNodeSignal( Bind1( &DotSceneListener::processSceneNode, &dotSceneListener ) );
+		SignalConnection conn2 = parser->subscribeToEntitySignal( Bind1( &DotSceneListener::processEntity, &dotSceneListener ) );
+		SignalConnection conn3 = parser->subscribeToCameraSignal( Bind1( &DotSceneListener::processCamera, &dotSceneListener ) );
+		SignalConnection conn4 = parser->subscribeToLightSignal( Bind1( &DotSceneListener::processLight, &dotSceneListener ) );
 
 		if (!parser->load( ser.getDocumentNode() ))
 		{
 			YAKE_SAFE_DELETE( pGraphical );
 		}
 
-		if (!ctx.dotSceneParser_)
-		{
-			YAKE_SAFE_DELETE( parser );
-		}
+		ctx.model_->addComponent( pGraphical, name );
 
-		ctx.model_->addComponent( pGraphical, name );
+		conn1.disconnect();
+		conn2.disconnect();
+		conn3.disconnect();
+		conn4.disconnect();
 	}
 
 } // namespace model

Modified: trunk/yake/src/yake/model/yakePhysicalCreator.cpp
===================================================================
--- trunk/yake/src/yake/model/yakePhysicalCreator.cpp	2006-06-17 13:33:43 UTC (rev 1345)
+++ trunk/yake/src/yake/model/yakePhysicalCreator.cpp	2006-06-17 14:00:03 UTC (rev 1346)
@@ -34,6 +34,10 @@
 
 	YAKE_REGISTER_CONCRETE(PhysicalFromXODECreator)
 
+	PhysicalFromXODECreator::PhysicalFromXODECreator() :
+		defaultParser_( new data::parser::xode::XODEParserV1() )
+	{
+	}
 	void PhysicalFromXODECreator::create(const ComponentCreationContext& ctx, const StringMap& params)
 	{
 		// Verify validity of creation context
@@ -66,7 +70,7 @@
 
 		data::parser::xode::XODEParser* xodeparser = ctx.xodeParser_;
 		if (!xodeparser)
-			xodeparser = new data::parser::xode::XODEParserV1();
+			xodeparser = defaultParser_.get();
 		YAKE_ASSERT( xodeparser );
 
 		Physical* pPhysical = new Physical(/**ctx.model_*/);
@@ -75,20 +79,18 @@
 									+ (name.empty() ? _T("") : (name + _T("/"))); // component
 		XODEListener xodeListener( *pPhysical, pPWorld, namePrefix );
 
-		xodeparser->subscribeToBodySignal( Bind1( &XODEListener::processBody, &xodeListener ) );
-		xodeparser->subscribeToGeomSignal( Bind1( &XODEListener::processGeom, &xodeListener ) );
+		SignalConnection conn1 = xodeparser->subscribeToBodySignal( Bind1( &XODEListener::processBody, &xodeListener ) );
+		SignalConnection conn2 = xodeparser->subscribeToGeomSignal( Bind1( &XODEListener::processGeom, &xodeListener ) );
 
 		if (!xodeparser->load( ser.getDocumentNode() ))
 		{
 			YAKE_SAFE_DELETE( pPhysical );
 		}
 
-		if (!ctx.xodeParser_)
-		{
-			YAKE_SAFE_DELETE( xodeparser );
-		}
+		ctx.model_->addComponent( pPhysical, name );
 
-		ctx.model_->addComponent( pPhysical, name );
+		conn2.disconnect();
+		conn1.disconnect();
 	}
 
 } // namespace model

Modified: trunk/yake/yake/model/model_component.h
===================================================================
--- trunk/yake/yake/model/model_component.h	2006-06-17 13:33:43 UTC (rev 1345)
+++ trunk/yake/yake/model/model_component.h	2006-06-17 14:00:03 UTC (rev 1346)
@@ -234,13 +234,21 @@
 	{
 		YAKE_DECLARE_CONCRETE(GraphicalFromDotSceneCreator,"graphics/dotScene");
 
+		GraphicalFromDotSceneCreator();
 		virtual void create(const ComponentCreationContext& ctx, const StringMap& params);
+
+	private:
+		SharedPtr<data::parser::dotscene::DotSceneParser>	defaultParser_;
 	};
 	struct PhysicalFromXODECreator : public ComponentCreator
 	{
 		YAKE_DECLARE_CONCRETE(PhysicalFromXODECreator,"physics/dotXODE");
 
+		PhysicalFromXODECreator();
 		virtual void create(const ComponentCreationContext& ctx, const StringMap& params);
+
+	private:
+		SharedPtr<data::parser::xode::XODEParser>	defaultParser_;
 	};
 	struct LinkFromDotLinkCreator : public ComponentCreator
 	{



From codeandroid at berlios.de  Tue Jun 20 10:05:19 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 20 Jun 2006 10:05:19 +0200
Subject: [Yake-svn] r1347 - in trunk/yake: src/yake/model yake/model
Message-ID: <200606200805.k5K85Jx5008102@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-20 10:05:16 +0200 (Tue, 20 Jun 2006)
New Revision: 1347

Modified:
   trunk/yake/src/yake/model/yakeModelManager.cpp
   trunk/yake/yake/model/model.h
Log:
added signals

Modified: trunk/yake/src/yake/model/yakeModelManager.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeModelManager.cpp	2006-06-17 14:00:03 UTC (rev 1346)
+++ trunk/yake/src/yake/model/yakeModelManager.cpp	2006-06-20 08:05:16 UTC (rev 1347)
@@ -72,6 +72,8 @@
 		models_.insert( std::make_pair(modelName,SharedPtr<Model>(m)) );
 		ctx_.model_ = m;
 
+		sigModelCreatedSignal_(*m,ctx_);
+
 		ConstVectorIterator<Vector<String> > itDef( defComponents );
 		while (itDef.hasMoreElements())
 		{
@@ -100,7 +102,9 @@
 			}
 #endif
 
+			sigPreCreateModelComponent_(*m,ctx_,type);
 			creatorMgr_.create( type, ctx_, params );
+			sigPostCreateModelComponent_(*m,ctx_,type);
 
 #ifdef YAKE_DEBUG
 			if (!name.empty())
@@ -110,6 +114,7 @@
 #endif
 		}
 		ctx_.model_ = 0;
+		sigModelInitializedSignal_(*m,ctx_);
 		return m;
 	}
 	void ModelManager::setCreationContext_GraphicalWorld(graphics::IWorld* w)

Modified: trunk/yake/yake/model/model.h
===================================================================
--- trunk/yake/yake/model/model.h	2006-06-17 14:00:03 UTC (rev 1346)
+++ trunk/yake/yake/model/model.h	2006-06-20 08:05:16 UTC (rev 1347)
@@ -134,6 +134,17 @@
 		void setCreationContext_CentralController(CentralControllerBase*);
 		void setCreationContext_DotSceneParser(data::parser::dotscene::DotSceneParser*);
 		void setCreationContext_XODEParser(data::parser::xode::XODEParser*);
+
+		/** Signals (in order that they are called in):
+		*/
+		typedef Signal2<void(Model&,const ComponentCreationContext&)> ModelCreatedSignal;
+		typedef Signal3<void(Model&,const ComponentCreationContext&,const String&)> PreCreateModelComponent;
+		typedef Signal3<void(Model&,const ComponentCreationContext&,const String&)> PostCreateModelComponent;
+		typedef Signal2<void(Model&,const ComponentCreationContext&)> ModelInitializedSignal;
+		void subscribeToModelCreatedSignal(const ModelCreatedSignal::slot_type&);
+		void subscribeToPreCreateModelComponent(const PreCreateModelComponent::slot_type&);
+		void subscribeToPostCreateModelComponent(const PostCreateModelComponent::slot_type&);
+		void subscribeToModelInitializedSignal(const ModelInitializedSignal::slot_type&);
 	private:
 		ModelManager(const ModelManager&);
 		ModelManager& operator=(const ModelManager&);
@@ -143,6 +154,11 @@
 
 		typedef AssocVector<String,SharedPtr<Model> > ModelList;
 		ModelList					models_;
+
+		ModelCreatedSignal			sigModelCreatedSignal_;
+		PreCreateModelComponent		sigPreCreateModelComponent_;
+		PostCreateModelComponent	sigPostCreateModelComponent_;
+		ModelInitializedSignal		sigModelInitializedSignal_;
 	};
 	/**@todo Move into private impl file. */
 	struct ModelTemplate : public ModelComponentContainer



From codeandroid at berlios.de  Tue Jun 20 20:07:06 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 20 Jun 2006 20:07:06 +0200
Subject: [Yake-svn] r1348 - trunk/yake/yake/model
Message-ID: <200606201807.k5KI76BP001345@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-20 20:06:58 +0200 (Tue, 20 Jun 2006)
New Revision: 1348

Modified:
   trunk/yake/yake/model/model.h
   trunk/yake/yake/model/model_component.h
Log:
added signals,
Physical can now manage physics::IBodyAffectors and their targets,
various comments

Modified: trunk/yake/yake/model/model.h
===================================================================
--- trunk/yake/yake/model/model.h	2006-06-20 08:05:16 UTC (rev 1347)
+++ trunk/yake/yake/model/model.h	2006-06-20 18:06:58 UTC (rev 1348)
@@ -74,26 +74,35 @@
 		Model();
 		//virtual ~Model() {} //@todo virtual?
 
-		// basic properties
+		/** @name basic properties */
+		//@{
 		void setName(const String&);
 		const String& getName() const;
+		//@}
 
-		// component management
+		/** @name component management */
+		//@{
 		void addComponent(ModelComponent*);
 		void addComponent(ModelComponent*, const ComponentTag&);
 		ModelComponent* removeComponent(ModelComponent*);
 		ModelComponent* getComponentByTag(const ComponentTag&) const;
 		ModelComponent* getComponentByIndex(const size_t) const;
 		size_t numComponents() const;
+		//@}
 
-		// link management
+		/** @name link management */
+		//@{
 		void addLink(ModelLink*);
 		void removeLink(ModelLink*);
 		void destroyAllLinks();
+		//@}
 
-		// signal
+		/** @name signals */
+		//@{
+		//@}
 
-		// helpers (for convencience only)
+		/** @name helpers (for convencience only) */
+		//@{
 		/** For convenience! This function creates a ModelMovableLink between
 			source and target movable objects. Both position and rotation
 			are marked for updates.
@@ -105,6 +114,7 @@
 		ModelMovableLink* createLink(Movable*,Movable*,const String& linkType = _T("yake.movable"));
 		ModelMovableLink* createDirectLink(Movable*,Movable*); // uses "yake.movable"
 		ModelMovableLink* createWorldSpaceLink(Movable*,Movable*); // uses "yake.movable_world"
+		//@}
 
 		//Model* clone() const;
 	private:
@@ -120,31 +130,45 @@
 		ModelLinkContainer		links_;
 		ModelComponentContainer	components_;
 	};
+	struct ModelTemplate;
 	struct YAKE_MODEL_API ModelManager
 	{
 	public:
 		ModelManager();
 		~ModelManager();
 
+		Model* createFromTemplate(const ModelTemplate&);
+		Model* createFromDotModel(const String& modelName, const String& fn, const String& tplName);
+		Model* createModel(const String& modelName, const ModelComponentDescList&);
 		Model* createModel(const String& modelName, const String& def);
 		void clear();
 
+		/** @name Model/Component creation context manipulation */
+		//@{
 		void setCreationContext_GraphicalWorld(graphics::IWorld*);
 		void setCreationContext_PhysicalWorld(physics::IWorld*);
 		void setCreationContext_CentralController(CentralControllerBase*);
 		void setCreationContext_DotSceneParser(data::parser::dotscene::DotSceneParser*);
 		void setCreationContext_XODEParser(data::parser::xode::XODEParser*);
+		//@}
 
-		/** Signals (in order that they are called in):
-		*/
+		/** @name Signals (in order that they are called in) */
+		//@{
 		typedef Signal2<void(Model&,const ComponentCreationContext&)> ModelCreatedSignal;
 		typedef Signal3<void(Model&,const ComponentCreationContext&,const String&)> PreCreateModelComponent;
 		typedef Signal3<void(Model&,const ComponentCreationContext&,const String&)> PostCreateModelComponent;
 		typedef Signal2<void(Model&,const ComponentCreationContext&)> ModelInitializedSignal;
-		void subscribeToModelCreatedSignal(const ModelCreatedSignal::slot_type&);
-		void subscribeToPreCreateModelComponent(const PreCreateModelComponent::slot_type&);
-		void subscribeToPostCreateModelComponent(const PostCreateModelComponent::slot_type&);
-		void subscribeToModelInitializedSignal(const ModelInitializedSignal::slot_type&);
+		SignalConnection subscribeToModelCreatedSignal(const ModelCreatedSignal::slot_type&);
+		SignalConnection subscribeToPreCreateModelComponent(const PreCreateModelComponent::slot_type&);
+		SignalConnection subscribeToPostCreateModelComponent(const PostCreateModelComponent::slot_type&);
+		SignalConnection subscribeToModelInitializedSignal(const ModelInitializedSignal::slot_type&);
+
+		typedef ComponentCreationContext::ComponentPreInitializeSignal ComponentPreInitializeSignal;
+		typedef ComponentCreationContext::ComponentPostInitializeSignal ComponentPostInitializeSignal;
+		SignalConnection subscribeToComponentPreInitializeSignal(const ComponentPreInitializeSignal::slot_type&);
+		SignalConnection subscribeToComponentPostInitializeSignal(const ComponentPostInitializeSignal::slot_type&);
+		//@}
+
 	private:
 		ModelManager(const ModelManager&);
 		ModelManager& operator=(const ModelManager&);
@@ -160,40 +184,34 @@
 		PostCreateModelComponent	sigPostCreateModelComponent_;
 		ModelInitializedSignal		sigModelInitializedSignal_;
 	};
+	struct ModelTemplateManager
+	{
+		ModelTemplateManager();
+		~ModelTemplateManager();
+
+		bool loadTemplatesFromDotLink(const String& fn);
+		ModelTemplate* getTemplate(const String&) const;
+		void destroyTemplate(const String&);
+	private:
+		ModelTemplateManager(const ModelTemplateManager&);
+		ModelTemplateManager& operator=(const ModelTemplateManager&);
+	private:
+		typedef AssocVector<String,SharedPtr<ModelTemplate> > ModelTemplateList;
+		ModelTemplateList	tplMap_;
+	};
 	/**@todo Move into private impl file. */
-	struct ModelTemplate : public ModelComponentContainer
+	struct ModelTemplate
 	{
 		ModelTemplate();
 		~ModelTemplate();
 
-		/// Example 1: from=physical:"p_mine":actor:"mineActor" to=graphical:"g_mine":scenenode:"mine_root"
-		/// Example 2: from=physical:"p_mine":shape:"mineActor/sphere1" to=graphical:"g_mine":scenenode:"mine_root"
-		/// Example params for ModelMovableLink: "position,orientation"
-		void addLink(const String& from, const String& to, const String& params);
-
-		/// Clones model (including components) and recreates links for the cloned model.
-		Model* createInstance(const String& name) const;
+		void addComponentDesc(const ModelComponent::Desc&);
+		const ModelComponentDescList& getComponentDescriptions() const;
 	private:
 		ModelTemplate(const ModelTemplate&);
 		ModelTemplate& operator=(const ModelTemplate&);
 	private:
-		struct link_t
-		{
-			String	fromComponentType_;
-			String	fromComponentName_;
-			String	fromElementType_;
-			String	fromElementName_;
-			String	toComponentType_;
-			String	toComponentName_;
-			String	toElementType_;
-			String	toElementName_;
-		};
-		typedef std::deque<link_t> LinkList;
-		LinkList	links_;
-
-		Model*		modelWithoutLinks_;
-	private:
-		void _createLinks(Model&);
+		ModelComponentDescList	compDescList_;
 	};
 
 } // namespace model

Modified: trunk/yake/yake/model/model_component.h
===================================================================
--- trunk/yake/yake/model/model_component.h	2006-06-20 08:05:16 UTC (rev 1347)
+++ trunk/yake/yake/model/model_component.h	2006-06-20 18:06:58 UTC (rev 1348)
@@ -43,6 +43,9 @@
 namespace model {
 	//@todo move into private header:
 	struct CentralControllerBase;
+	/** @remarks Do *NOT* rely on the existence of the members of this structure!
+				Always access them through ModelManager!
+	*/
 	struct ComponentCreationContext
 	{
 		Model*					model_;
@@ -54,6 +57,11 @@
 		data::parser::dotscene::DotSceneParser*		dotSceneParser_;
 		data::parser::xode::XODEParser*				xodeParser_;
 
+		typedef Signal2<void(const ComponentCreationContext&,ModelComponent&)> ComponentPreInitializeSignal;
+		typedef ComponentPreInitializeSignal ComponentPostInitializeSignal;
+		ComponentPreInitializeSignal	sigPreInit_;
+		ComponentPostInitializeSignal	sigPostInit_;
+
 		ComponentCreationContext() : 
 			model_(0),
 			gworld_(0),
@@ -69,6 +77,20 @@
 		ModelComponent() {}
 		virtual ~ModelComponent() {}
 		//Model* getOwner() const;
+
+		/** @name Types */
+		//@{
+		struct Desc {
+			String		name;
+			String		type;
+			StringMap	params;
+			Desc() {}
+			Desc(const String& n, const String& t, const StringMap& p = StringMap()) :
+				name(n), type(t), params(p)
+			{}
+		};
+		typedef std::deque<Desc> DescList;
+		//@}
 	private:
 		//ModelComponent();
 		ModelComponent(const ModelComponent&);
@@ -78,18 +100,22 @@
 	private:
 		//Model*	owner_;
 	};
+	typedef ModelComponent::DescList ModelComponentDescList;
 	typedef SharedPtr<ModelComponent> ModelComponentSharedPtr;
 	typedef std::deque<ModelComponentSharedPtr> ModelComponentList;
 	typedef std::string ComponentTag;
 	struct YAKE_MODEL_API ModelComponentContainer
 	{
 		ModelComponentContainer();
+		/** @name Component container interface */
+		//@{
 		void addComponent(ModelComponent*);
 		void addComponent(ModelComponent*, const ComponentTag&);
 		ModelComponent* getComponentByTag(const ComponentTag&) const;
 		ModelComponent* getComponentByIndex(const size_t) const;
 		size_t numComponents() const;
 		bool empty() const;
+		//@}
 	private:
 		ModelComponentContainer(const ModelComponentContainer&);
 		ModelComponentContainer& operator=(const ModelComponentContainer&);
@@ -117,11 +143,18 @@
 		void addActor(physics::IActor*, const String&);
 		void addBody(physics::IBody*, const String&);
 		void addJoint(physics::IJoint*, const String&);
+		void addAffector(physics::IBodyAffector*, const String&);
+		void addAffectorTargetBody(physics::IBodyAffector*,physics::IBody*);
+		void addAffectorTargetBody(physics::IBodyAffector*,const String& bodyXPath);
+		void addAffectorTargetActor(physics::IBodyAffector*,const String& actorXPath);
 
 		physics::IActor* getActor(const String&) const;
 		physics::IBody* getBody(const String&) const;
 		physics::IJoint* getJoint(const String&) const;
+		physics::IBodyAffector* getAffector(const String&) const;
 
+		void updateAffectors(const real dt);
+
 		//getShape(const String&,const String&)
 
 		//void setPosition(const Vector3&);
@@ -140,10 +173,15 @@
 		typedef AssocVector<String,EntryT<physics::IActor> > TagActorMap;
 		typedef AssocVector<String,EntryT<physics::IBody> > TagBodyMap;
 		typedef AssocVector<String,EntryT<physics::IJoint> > TagJointMap;
+		typedef AssocVector<String,EntryT<physics::IBodyAffector> > TagAffectorMap;
 		TagActorMap		actors_;
 		TagBodyMap		bodies_;
 		TagJointMap		joints_;
+		TagAffectorMap	affectors_;
 
+		typedef AssocVector<physics::IBodyAffector*, physics::BodyGroup> AffectorTargetMap;
+		AffectorTargetMap	affectorTargetMap_;
+
 		template<typename T>
 		void _add(T* obj,AssocVector<String,EntryT<T> >& ctr, const String& xpath)
 		{



From codeandroid at berlios.de  Tue Jun 20 20:10:44 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 20 Jun 2006 20:10:44 +0200
Subject: [Yake-svn] r1349 - in trunk/yake/src/yake: model samples/model/dotScene
Message-ID: <200606201810.k5KIAi8a002612@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-20 20:10:25 +0200 (Tue, 20 Jun 2006)
New Revision: 1349

Modified:
   trunk/yake/src/yake/model/yakeGraphicalCreator.cpp
   trunk/yake/src/yake/model/yakeModelManager.cpp
   trunk/yake/src/yake/model/yakePhysical.cpp
   trunk/yake/src/yake/model/yakePhysicalCreator.cpp
   trunk/yake/src/yake/samples/model/dotScene/demo.cpp
Log:
added signals,
Physical can now manage physics::IBodyAffectors and their targets,
various comments

Modified: trunk/yake/src/yake/model/yakeGraphicalCreator.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeGraphicalCreator.cpp	2006-06-20 18:06:58 UTC (rev 1348)
+++ trunk/yake/src/yake/model/yakeGraphicalCreator.cpp	2006-06-20 18:10:25 UTC (rev 1349)
@@ -74,6 +74,7 @@
 		YAKE_ASSERT( parser );
 
 		Graphical* pGraphical = new Graphical(/**ctx.model_*/);
+		ctx.sigPreInit_(ctx,*pGraphical);
 
 		const String namePrefix = _T("model:") + ctx.model_->getName() + _T("/")  // model
 									+ (name.empty() ? _T("") : (name + _T("/"))); // component
@@ -91,12 +92,13 @@
 			YAKE_SAFE_DELETE( pGraphical );
 		}
 
-		ctx.model_->addComponent( pGraphical, name );
-
 		conn1.disconnect();
 		conn2.disconnect();
 		conn3.disconnect();
 		conn4.disconnect();
+
+		ctx.sigPostInit_(ctx,*pGraphical);
+		ctx.model_->addComponent( pGraphical, name );
 	}
 
 } // namespace model

Modified: trunk/yake/src/yake/model/yakeModelManager.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeModelManager.cpp	2006-06-20 18:06:58 UTC (rev 1348)
+++ trunk/yake/src/yake/model/yakeModelManager.cpp	2006-06-20 18:10:25 UTC (rev 1349)
@@ -37,6 +37,30 @@
 	ModelManager::~ModelManager()
 	{
 	}
+	SignalConnection ModelManager::subscribeToModelCreatedSignal(const ModelCreatedSignal::slot_type& slot)
+	{
+		return sigModelCreatedSignal_.connect(slot);
+	}
+	SignalConnection ModelManager::subscribeToPreCreateModelComponent(const PreCreateModelComponent::slot_type& slot)
+	{
+		return sigPreCreateModelComponent_.connect(slot);
+	}
+	SignalConnection ModelManager::subscribeToPostCreateModelComponent(const PostCreateModelComponent::slot_type& slot)
+	{
+		return sigPostCreateModelComponent_.connect(slot);
+	}
+	SignalConnection ModelManager::subscribeToModelInitializedSignal(const ModelInitializedSignal::slot_type& slot)
+	{
+		return sigModelInitializedSignal_.connect(slot);
+	}
+	SignalConnection ModelManager::subscribeToComponentPreInitializeSignal(const ComponentPreInitializeSignal::slot_type& slot)
+	{
+		return ctx_.sigPreInit_.connect( slot );
+	}
+	SignalConnection ModelManager::subscribeToComponentPostInitializeSignal(const ComponentPostInitializeSignal::slot_type& slot)
+	{
+		return ctx_.sigPostInit_.connect( slot );
+	}
 	namespace detail {
 		void extractParams(const String& params, StringMap& out)
 		{
@@ -54,19 +78,27 @@
 	{
 		models_.clear();
 	}
-	/// graphics/dotScene:name=gfx;file=bla.scene|physics/dotXODE...
-	Model* ModelManager::createModel(const String& modelName, const String& def)
+	/**
+	list of components:
+		component #1
+			type=graphics/dotScene
+			name=gfx
+			file=...
+			...
+		component #2
+			type=physics/dotXODE
+			name=...
+			...
+	*/
+	Model* ModelManager::createModel(const String& modelName, const ModelComponentDescList& compDescList)
 	{
+		// Validate name
 		YAKE_ASSERT( !modelName.empty() );
 		YAKE_ASSERT( models_.find(modelName) == models_.end() )(modelName).debug("Model with that name already exists.");
 		if (models_.find(modelName) != models_.end())
 			return 0;
 
-		Vector<String> defComponents = split<String>(def, "|");
-		YAKE_ASSERT(!defComponents.empty())(modelName)(def);
-		if (defComponents.empty())
-			return 0;
-
+		// Create model object
 		Model* m = new Model();
 		m->setName( modelName );
 		models_.insert( std::make_pair(modelName,SharedPtr<Model>(m)) );
@@ -74,27 +106,20 @@
 
 		sigModelCreatedSignal_(*m,ctx_);
 
-		ConstVectorIterator<Vector<String> > itDef( defComponents );
-		while (itDef.hasMoreElements())
+		// Create components (if any)
+		ConstVectorIterator<ModelComponentDescList> itCompDesc(compDescList);
+		while (itCompDesc.hasMoreElements())
 		{
-			const String& defC = itDef.getNextRef();
+			const ModelComponent::Desc& desc = itCompDesc.getNextRef();
 
-			// Split e.g. "gfx=graphics/dotScene:file=blah.scene" into "gfx" and "file=graphics/dotScene:blah.scene"
-			Vector<String> defTypeRest = split<String>( defC, ":" );
-			YAKE_ASSERT( defTypeRest.size() == 2 )(modelName)(def);
+			const String& type = desc.type; // e.g. "graphics/dotScene" or "physics/XODE" etc
+			const StringMap& params = desc.params;
 
-			const String type = defTypeRest.front(); // e.g. "graphics/dotScene" or "physics/XODE" etc
-
-			// Extract parameters.
-			StringMap params;
-			detail::extractParams( defTypeRest.back(), params );
-
 			// Extract parameter 'name'.
 			StringMap::const_iterator itParam = params.find("name");
 			const String name = (itParam == params.end()) ? _T("") : itParam->second;
 
 			// Create component.
-
 #ifdef YAKE_DEBUG
 			if (!name.empty())
 			{
@@ -117,6 +142,44 @@
 		sigModelInitializedSignal_(*m,ctx_);
 		return m;
 	}
+	/// graphics/dotScene:name=gfx;file=bla.scene|physics/dotXODE...
+	Model* ModelManager::createModel(const String& modelName, const String& def)
+	{
+		// Validate name
+		YAKE_ASSERT( !modelName.empty() );
+		YAKE_ASSERT( models_.find(modelName) == models_.end() )(modelName).debug("Model with that name already exists.");
+		if (models_.find(modelName) != models_.end())
+			return 0;
+
+		// Split components string
+		Vector<String> defComponents = split<String>(def, "|");
+
+		// Create ModelComponentDescList.
+		ModelComponentDescList compDescList;
+		ConstVectorIterator<Vector<String> > itDef( defComponents );
+		while (itDef.hasMoreElements())
+		{
+			const String& defC = itDef.getNextRef();
+
+			// Split e.g. "gfx=graphics/dotScene:file=blah.scene" into "gfx" and "file=graphics/dotScene:blah.scene"
+			Vector<String> defTypeRest = split<String>( defC, ":" );
+			YAKE_ASSERT( defTypeRest.size() == 2 )(modelName)(def);
+
+			const String type = defTypeRest.front(); // e.g. "graphics/dotScene" or "physics/XODE" etc
+
+			// Extract parameters.
+			StringMap params;
+			detail::extractParams( defTypeRest.back(), params );
+
+			// Extract parameter 'name'.
+			StringMap::const_iterator itParam = params.find("name");
+			const String name = (itParam == params.end()) ? _T("") : itParam->second;
+
+			// Create component description.
+			compDescList.push_back( ModelComponent::Desc(name,type,params) );
+		}
+		return this->createModel(modelName,compDescList);
+	}
 	void ModelManager::setCreationContext_GraphicalWorld(graphics::IWorld* w)
 	{
 		ctx_.gworld_ = w;

Modified: trunk/yake/src/yake/model/yakePhysical.cpp
===================================================================
--- trunk/yake/src/yake/model/yakePhysical.cpp	2006-06-20 18:06:58 UTC (rev 1348)
+++ trunk/yake/src/yake/model/yakePhysical.cpp	2006-06-20 18:10:25 UTC (rev 1349)
@@ -67,6 +67,11 @@
 		YAKE_LOG(String("Physical::addBody(") + xpath + _T(")"));
 		this->_add<physics::IBody>(body,bodies_,xpath);
 	}
+	void Physical::addAffector(physics::IBodyAffector* affector, const String& xpath)
+	{
+		YAKE_LOG(String("Physical::addAffector(") + xpath + _T(")"));
+		this->_add<physics::IBodyAffector>(affector,affectors_,xpath);
+	}
 	physics::IActor* Physical::getActor(const yake::String& xpath) const
 	{
 		return this->_get(actors_,xpath);
@@ -79,6 +84,45 @@
 	{
 		return this->_get(bodies_,xpath);
 	}
+	physics::IBodyAffector* Physical::getAffector(const String& xpath) const
+	{
+		return this->_get(affectors_,xpath);
+	}
+	void Physical::addAffectorTargetBody(physics::IBodyAffector* affector,physics::IBody* target)
+	{
+		//@todo test for existence of affector in affectorTargetMap_.
+		YAKE_ASSERT( affector );
+		YAKE_ASSERT( target );
+		affectorTargetMap_[affector] += target;
+	}
+	void Physical::addAffectorTargetBody(physics::IBodyAffector* affector,const String& bodyXPath)
+	{
+		//@todo test for existence of affector in affectorTargetMap_.
+		YAKE_ASSERT( affector );
+		YAKE_ASSERT( !bodyXPath.empty() );
+		physics::IBodyPtr body = this->getBody( bodyXPath );
+		YAKE_ASSERT( body );
+		this->addAffectorTargetBody(affector,body);
+	}
+	void Physical::addAffectorTargetActor(physics::IBodyAffector* affector,const String& actorXPath)
+	{
+		//@todo test for existence of affector in affectorTargetMap_.
+		YAKE_ASSERT( affector );
+		YAKE_ASSERT( !actorXPath.empty() );
+		physics::IActorPtr actor = this->getActor(actorXPath);
+		YAKE_ASSERT( actor );
+		physics::IBodyPtr body = actor->getBodyPtr();
+		YAKE_ASSERT( body );
+		this->addAffectorTargetBody(affector,body);
+	}
+	void Physical::updateAffectors(const real dt)
+	{
+		AffectorTargetMap::iterator itEnd = affectorTargetMap_.end();
+		for (AffectorTargetMap::iterator it = affectorTargetMap_.begin(); it != itEnd; ++it)
+		{
+			it->first->applyTo(it->second,dt);
+		}
+	}
 
 } // namespace model
 } // namespace yake

Modified: trunk/yake/src/yake/model/yakePhysicalCreator.cpp
===================================================================
--- trunk/yake/src/yake/model/yakePhysicalCreator.cpp	2006-06-20 18:06:58 UTC (rev 1348)
+++ trunk/yake/src/yake/model/yakePhysicalCreator.cpp	2006-06-20 18:10:25 UTC (rev 1349)
@@ -74,6 +74,7 @@
 		YAKE_ASSERT( xodeparser );
 
 		Physical* pPhysical = new Physical(/**ctx.model_*/);
+		ctx.sigPreInit_(ctx,*pPhysical);
 
 		const String namePrefix = _T("model:") + ctx.model_->getName() + _T("/")  // model
 									+ (name.empty() ? _T("") : (name + _T("/"))); // component
@@ -87,10 +88,11 @@
 			YAKE_SAFE_DELETE( pPhysical );
 		}
 
-		ctx.model_->addComponent( pPhysical, name );
-
 		conn2.disconnect();
 		conn1.disconnect();
+
+		ctx.sigPostInit_(ctx,*pPhysical);
+		ctx.model_->addComponent( pPhysical, name );
 	}
 
 } // namespace model

Modified: trunk/yake/src/yake/samples/model/dotScene/demo.cpp
===================================================================
--- trunk/yake/src/yake/samples/model/dotScene/demo.cpp	2006-06-20 18:06:58 UTC (rev 1348)
+++ trunk/yake/src/yake/samples/model/dotScene/demo.cpp	2006-06-20 18:10:25 UTC (rev 1349)
@@ -45,6 +45,14 @@
 	{
 		std::cout << "MB: " << static_cast<int>(btn) << std::endl;
 	}
+	void onModelComponent_preInit(const model::ComponentCreationContext& ctx, model::ModelComponent&)
+	{
+		YAKE_LOG("demo: onModelComponent_preInit()");
+	}
+	void onModelComponent_postInit(const model::ComponentCreationContext& ctx, model::ModelComponent&)
+	{
+		YAKE_LOG("demo: onModelComponent_postInit()");
+	}
 	int createCameraViewportPair( real sx, real sy, real w, real h, int z )
 	{
 		graphics::ICamera* pC = mGWorld->createCamera();
@@ -121,11 +129,19 @@
 		setupScene();
 
 		//mGWorld->setShadowsEnabled( true );
+
+		// create a model manager and set up the model creation context.
 		model::ModelManager modelMgr;
 		modelMgr.setCreationContext_GraphicalWorld( mGWorld.get() );
 		modelMgr.setCreationContext_PhysicalWorld( mPWorld.get() );
 		modelMgr.setCreationContext_CentralController( this );
 
+		// just for demo purposes:
+		modelMgr.subscribeToComponentPreInitializeSignal( Bind2(&TheApp::onModelComponent_preInit,this) );
+		modelMgr.subscribeToComponentPostInitializeSignal( Bind2(&TheApp::onModelComponent_postInit,this) );
+
+		// create models :)
+
 		model::Model* m = modelMgr.createModel("m1","graphics/dotScene:name=gfx;file=../../media/samples/dotScene/DotScene1.scene");
 		YAKE_ASSERT( m );
 		((model::Graphical*)m->getComponentByTag("gfx"))->translate(Vector3(40,20,0));



From codeandroid at berlios.de  Tue Jun 20 20:19:17 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 20 Jun 2006 20:19:17 +0200
Subject: [Yake-svn] r1350 - trunk/yake/yake/model
Message-ID: <200606201819.k5KIJHOo006461@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-20 20:19:14 +0200 (Tue, 20 Jun 2006)
New Revision: 1350

Modified:
   trunk/yake/yake/model/model_component.h
Log:
fixed memory management for IBodyAffectors managed by Physicals

Modified: trunk/yake/yake/model/model_component.h
===================================================================
--- trunk/yake/yake/model/model_component.h	2006-06-20 18:10:25 UTC (rev 1349)
+++ trunk/yake/yake/model/model_component.h	2006-06-20 18:19:14 UTC (rev 1350)
@@ -170,10 +170,18 @@
 			EntryT(pointer p) : p_(p)
 			{}
 		};
+		template<typename T>
+		struct EntrySharedT
+		{
+			typedef SharedPtr<T> pointer;
+			pointer	p_;
+			EntrySharedT(pointer p) : p_(p)
+			{}
+		};
 		typedef AssocVector<String,EntryT<physics::IActor> > TagActorMap;
 		typedef AssocVector<String,EntryT<physics::IBody> > TagBodyMap;
 		typedef AssocVector<String,EntryT<physics::IJoint> > TagJointMap;
-		typedef AssocVector<String,EntryT<physics::IBodyAffector> > TagAffectorMap;
+		typedef AssocVector<String,EntrySharedT<physics::IBodyAffector> > TagAffectorMap;
 		TagActorMap		actors_;
 		TagBodyMap		bodies_;
 		TagJointMap		joints_;
@@ -193,11 +201,27 @@
 			ctr.insert( std::make_pair( xpath, EntryT<T>(obj) ) );
 		}
 		template<typename T>
+		void _add(T* obj,AssocVector<String,EntrySharedT<T> >& ctr, const String& xpath)
+		{
+			YAKE_ASSERT( obj );
+			YAKE_ASSERT( !xpath.empty() );
+#ifdef YAKE_DEBUG_BUILD
+			YAKE_ASSERT( ctr.end() == ctr.find(xpath) )(xpath).debug(_T("Item with this xpath already exists!"));
+#endif
+			ctr.insert( std::make_pair( xpath, typename EntrySharedT<T>::pointer(obj) ) );
+		}
+		template<typename T>
 		T* _get(const AssocVector<String,EntryT<T> >& ctr, const String& xpath) const
 		{
 			typename AssocVector<String,EntryT<T> >::const_iterator it = ctr.find( xpath );
 			return ((it != ctr.end()) ? it->second.p_ : 0);
 		}
+		template<typename T>
+		T* _get(const AssocVector<String,EntrySharedT<T> >& ctr, const String& xpath) const
+		{
+			typename AssocVector<String,EntrySharedT<T> >::const_iterator it = ctr.find( xpath );
+			return ((it != ctr.end()) ? it->second.p_.get() : 0);
+		}
 	};
 	struct YAKE_MODEL_API Graphical : public ModelComponent
 	{



From codeandroid at berlios.de  Tue Jun 20 21:59:41 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 20 Jun 2006 21:59:41 +0200
Subject: [Yake-svn] r1351 - trunk/yake/yake/model
Message-ID: <200606201959.k5KJxf1O023525@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-20 21:59:40 +0200 (Tue, 20 Jun 2006)
New Revision: 1351

Added:
   trunk/yake/yake/model/model_dotmodel_parser.h
Modified:
   trunk/yake/yake/model/model.h
Log:
added dotModel templates

Modified: trunk/yake/yake/model/model.h
===================================================================
--- trunk/yake/yake/model/model.h	2006-06-20 18:19:14 UTC (rev 1350)
+++ trunk/yake/yake/model/model.h	2006-06-20 19:59:40 UTC (rev 1351)
@@ -137,10 +137,13 @@
 		ModelManager();
 		~ModelManager();
 
-		Model* createFromTemplate(const ModelTemplate&);
-		Model* createFromDotModel(const String& modelName, const String& fn, const String& tplName);
+		bool loadTemplatesFromDotModel(const String& fn);
+
+		Model* createModelFromTemplate(const String& modelName, const String& tplName);
+
 		Model* createModel(const String& modelName, const ModelComponentDescList&);
 		Model* createModel(const String& modelName, const String& def);
+
 		void clear();
 
 		/** @name Model/Component creation context manipulation */
@@ -183,13 +186,17 @@
 		PreCreateModelComponent		sigPreCreateModelComponent_;
 		PostCreateModelComponent	sigPostCreateModelComponent_;
 		ModelInitializedSignal		sigModelInitializedSignal_;
+
+		typedef AssocVector<String,SharedPtr<ModelTemplate> > ModelTemplateList;
+		ModelTemplateList			modelTemplates_;
 	};
+	/*
 	struct ModelTemplateManager
 	{
 		ModelTemplateManager();
 		~ModelTemplateManager();
 
-		bool loadTemplatesFromDotLink(const String& fn);
+		bool loadTemplatesFromDotModel(const String& fn);
 		ModelTemplate* getTemplate(const String&) const;
 		void destroyTemplate(const String&);
 	private:
@@ -199,6 +206,7 @@
 		typedef AssocVector<String,SharedPtr<ModelTemplate> > ModelTemplateList;
 		ModelTemplateList	tplMap_;
 	};
+	*/
 	/**@todo Move into private impl file. */
 	struct ModelTemplate
 	{

Added: trunk/yake/yake/model/model_dotmodel_parser.h
===================================================================
--- trunk/yake/yake/model/model_dotmodel_parser.h	2006-06-20 18:19:14 UTC (rev 1350)
+++ trunk/yake/yake/model/model_dotmodel_parser.h	2006-06-20 19:59:40 UTC (rev 1351)
@@ -0,0 +1,123 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright  2004 The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#ifndef YAKE_MODEL_DOTMODELPARSER_H
+#define YAKE_MODEL_DOTMODELPARSER_H
+
+#include <yake/model/prerequisites.h>
+#include <yake/data/yakeData.h>
+#include <yake/model/model_component.h>
+
+namespace yake {
+namespace data {
+namespace parser {
+namespace dotmodel {
+
+	/** DotModelParser base class providing default implementation.
+	*/
+	class YAKE_MODEL_API DotModelParser
+	{
+	public:
+		typedef SharedPtr<dom::INode> NodeSharedPtr;
+		typedef dom::NodeList::const_iterator NodeListIter;
+
+		
+		DotModelParser();
+		virtual ~DotModelParser() {}
+
+		String getName() const
+		{ 
+			return "yake.data.dotModel";
+		}
+
+		virtual Version getVersion() const = 0;
+
+		/** Build physics model from DOM!
+			\param file 
+			\return 
+		*/
+		virtual bool load( const NodeSharedPtr docNode );
+
+		/** Prepare for next run of load/store.
+		*/
+		virtual void reset();
+
+		typedef model::ModelComponent::Desc ModelComponentDesc;
+		struct ModelDesc
+		{
+			String	name_;
+		};
+
+		typedef SignalX< void( const ModelDesc& ) > ModelSignal;
+		typedef ModelSignal ModelFinishedSignal;
+		typedef SignalX< void( const ModelComponentDesc& ) > ModelComponentSignal;
+		typedef SignalX< void ( void ) > EventSignal; // special event handler type
+	
+		SignalConnection subscribeToModelSignal( const ModelSignal::slot_type& slot )
+		{ return sigModel_.connect(slot); } 
+		SignalConnection subscribeToModelComponentSignal( const ModelComponentSignal::slot_type& slot )
+		{ return sigModelComponent_.connect(slot); } 
+		SignalConnection subscribeToModelFinishedSignal( const ModelFinishedSignal::slot_type& slot )
+		{ return sigModelFinished_.connect(slot); } 
+
+		SignalConnection subscribeToParseEndedSignal( const EventSignal::slot_type& slot )
+		{ return sigParseEnded_.connect( slot ); } 
+
+	protected:
+		ModelSignal				sigModel_;
+		ModelFinishedSignal		sigModelFinished_;
+		ModelComponentSignal	sigModelComponent_;
+		EventSignal				sigParseEnded_;
+	
+		/// Default implementations for common functions.
+		virtual void readDotModel( const NodeSharedPtr pNode );
+		virtual void readModels( const NodeSharedPtr pModelsNode );
+		virtual void readModel( const NodeSharedPtr pModelNode );
+		virtual void readModelComponent( const NodeSharedPtr pCompNode, ModelDesc& modelDesc );
+		virtual void readModelComponentParameter( const NodeSharedPtr pParamNode, String& name, String& value );
+
+	private:
+		NodeSharedPtr		mDocNode;
+	};
+	
+	class YAKE_MODEL_API DotModelParserV1 : public DotModelParser
+	{
+	public:
+		virtual ~DotModelParserV1() {}
+		
+		virtual Version getVersion() const
+		{ 
+			return Version( 1, 0, 0 );
+		}
+	};
+
+} // xode
+} // parser
+} // data
+} // yake
+
+#endif
+



From codeandroid at berlios.de  Tue Jun 20 22:00:08 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 20 Jun 2006 22:00:08 +0200
Subject: [Yake-svn] r1352 - trunk/yake/src/yake/model
Message-ID: <200606202000.k5KK08tK023717@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-20 22:00:02 +0200 (Tue, 20 Jun 2006)
New Revision: 1352

Added:
   trunk/yake/src/yake/model/yakeDotModelParser.cpp
   trunk/yake/src/yake/model/yakeModelTemplate.cpp
   trunk/yake/src/yake/model/yakeModelTemplateManager.cpp
Log:
added dotModel templates

Added: trunk/yake/src/yake/model/yakeDotModelParser.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeDotModelParser.cpp	2006-06-20 19:59:40 UTC (rev 1351)
+++ trunk/yake/src/yake/model/yakeDotModelParser.cpp	2006-06-20 20:00:02 UTC (rev 1352)
@@ -0,0 +1,150 @@
+/*
+	 ------------------------------------------------------------------------------------
+	 This file is part of YAKE
+	 Copyright	2004 The YAKE Team
+	 For the latest information visit http://www.yake.org 
+	 ------------------------------------------------------------------------------------
+	 This program is free software; you can redistribute it and/or modify it under
+	 the terms of the GNU Lesser General Public License as published by the Free Software
+	 Foundation; either version 2 of the License, or (at your option) any later
+	 version.
+ 
+	 This program is distributed in the hope that it will be useful, but WITHOUT
+	 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+	 FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+ 
+	 You should have received a copy of the GNU Lesser General Public License along with
+	 this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+	 Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+	 http://www.gnu.org/copyleft/lesser.txt.
+	 ------------------------------------------------------------------------------------
+	 If you are interested in another license model contact the Yake Team via
+	 E-Mail: team at yake.org.
+	 For more information see the LICENSE file in the root directory of the
+	 source code distribution.
+	 ------------------------------------------------------------------------------------
+*/
+#include <yake/model/pch.h>
+#include <yake/model/model.h>
+#include <yake/model/model_dotmodel_parser.h>
+
+namespace yake {
+namespace data {
+namespace parser {
+namespace dotmodel {
+
+    //------------------------------------------------------
+	DotModelParser::DotModelParser()
+    {}
+
+    //------------------------------------------------------
+    bool DotModelParser::load( const NodeSharedPtr docNode )
+    {
+		YAKE_LOG( "dotModel: load()" );
+
+		YAKE_ASSERT( docNode.get() );
+
+		mDocNode = docNode;
+
+		YAKE_LOG( "***********************" );
+		YAKE_LOG( "* Parsing dotModel... *" );
+		YAKE_LOG( "***********************" );
+
+		readDotModel( mDocNode );
+
+		return true;
+    }
+
+    //------------------------------------------------------
+    void DotModelParser::readDotModel( const NodeSharedPtr pNode )
+    {
+		YAKE_ASSERT( pNode.get() );
+
+		readModels( pNode );
+
+		// parse completed. Firing signal!
+		sigParseEnded_();
+    }
+
+    //------------------------------------------------------
+    void DotModelParser::readModels( const NodeSharedPtr pModelsNode )
+    {
+		const dom::NodeList& nodes = pModelsNode->getNodes();
+		for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
+		{
+			readModel( *it );
+		}
+    }
+
+    //------------------------------------------------------
+    void DotModelParser::readModel( const NodeSharedPtr pModelNode )
+    {
+		ModelDesc desc;
+		desc.name_ = yake::StringUtil::toLowerCase( pModelNode->getAttributeValueAs<String>("name") );
+		YAKE_LOG("xode: model '" << desc.name_ << "' found!");
+
+		this->sigModel_( desc );
+
+		const dom::NodeList& nodes = pModelNode->getNodes();
+		for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
+		{
+			const String name = yake::StringUtil::toLowerCase( (*it)->getName() );
+			YAKE_LOG("xode: item '" << name << "' found!");
+			if (name == "component")
+			{
+				this->readModelComponent( *it, desc );
+			}
+			else
+				YAKE_LOG_WARNING("xode: unhandled item '" << name << "'!");
+		}
+
+		this->sigModelFinished_( desc );
+    }
+
+    //------------------------------------------------------
+	void DotModelParser::readModelComponent( const NodeSharedPtr pCompNode, ModelDesc& modelDesc )
+	{
+		ModelComponentDesc desc;
+		desc.name = pCompNode->getAttributeValueAs<String>("name");
+		desc.type = pCompNode->getAttributeValueAs<String>("type");
+
+		const dom::NodeList& nodes = pCompNode->getNodes();
+		for (dom::NodeList::const_iterator it = nodes.begin(); it != nodes.end(); ++it)
+		{
+			const String name = yake::StringUtil::toLowerCase( (*it)->getName() );
+			YAKE_LOG("xode: item '" << name << "' found!");
+			if (name == "parameter")
+			{
+				String name;
+				String value;
+				this->readModelComponentParameter( *it, name, value );
+				desc.params[name] = value;
+			}
+			else
+				YAKE_LOG_WARNING("xode: unhandled item '" << name << "'!");
+		}
+
+		desc.params["name"] = desc.name;
+		desc.params["type"] = desc.type;
+		this->sigModelComponent_(desc);
+	}
+
+    //------------------------------------------------------
+	void DotModelParser::readModelComponentParameter( const NodeSharedPtr pParamNode, String& name, String& value )
+	{
+		name = pParamNode->getAttributeValueAs<String>("name");
+		value = pParamNode->getAttributeValueAs<String>("value");
+	}
+
+	//------------------------------------------------------
+    void DotModelParser::reset()
+    {
+		//TODO is this really needed?
+		mDocNode.reset();
+    }
+
+} //xode
+} //parser
+} //data
+} //yake
+

Added: trunk/yake/src/yake/model/yakeModelTemplate.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeModelTemplate.cpp	2006-06-20 19:59:40 UTC (rev 1351)
+++ trunk/yake/src/yake/model/yakeModelTemplate.cpp	2006-06-20 20:00:02 UTC (rev 1352)
@@ -0,0 +1,50 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"
+#include "yake/model/prerequisites.h"
+#include "yake/model/model.h"
+
+namespace yake {
+namespace model {
+
+	ModelTemplate::ModelTemplate()
+	{
+	}
+	ModelTemplate::~ModelTemplate()
+	{
+	}
+	void ModelTemplate::addComponentDesc(const ModelComponent::Desc& desc)
+	{
+		compDescList_.push_back( desc );
+	}
+	const ModelComponentDescList& ModelTemplate::getComponentDescriptions() const
+	{
+		return compDescList_;
+	}
+
+} // namespace model
+} // namespace yake

Added: trunk/yake/src/yake/model/yakeModelTemplateManager.cpp
===================================================================
--- trunk/yake/src/yake/model/yakeModelTemplateManager.cpp	2006-06-20 19:59:40 UTC (rev 1351)
+++ trunk/yake/src/yake/model/yakeModelTemplateManager.cpp	2006-06-20 20:00:02 UTC (rev 1352)
@@ -0,0 +1,135 @@
+/*
+   ------------------------------------------------------------------------------------
+   This file is part of YAKE
+   Copyright (c) The YAKE Team
+   For the latest information visit http://www.yake.org 
+   ------------------------------------------------------------------------------------
+   This program is free software; you can redistribute it and/or modify it under
+   the terms of the GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2 of the License, or (at your option) any later
+   version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+   Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+   http://www.gnu.org/copyleft/lesser.txt.
+   ------------------------------------------------------------------------------------
+   If you are interested in another license model contact the Yake Team via
+   E-Mail: team at yake.org.
+   For more information see the LICENSE file in the root directory of the
+   source code distribution.
+   ------------------------------------------------------------------------------------
+*/
+#include "yake/model/pch.h"
+#include "yake/model/prerequisites.h"
+#include "yake/model/model.h"
+#include "yake/model/model_dotmodel_parser.h"
+
+namespace yake {
+namespace model {
+
+	namespace detail {
+		struct DotModelListener
+		{
+			DotModelListener() : currTpl_(0)
+			{
+			}
+			void onBeginModel(const data::parser::dotmodel::DotModelParser::ModelDesc& desc)
+			{
+				YAKE_ASSERT( !desc.name_.empty() );
+				currTpl_ = new ModelTemplate();
+				tpls_.insert( std::make_pair(desc.name_,currTpl_) );
+			}
+			void onModelComponent(const data::parser::dotmodel::DotModelParser::ModelComponentDesc& desc)
+			{
+				YAKE_ASSERT( currTpl_ );
+				currTpl_->addComponentDesc( desc );
+			}
+			void onEndModel(const data::parser::dotmodel::DotModelParser::ModelDesc&)
+			{
+				currTpl_ = 0;
+			}
+
+			typedef std::map<String,ModelTemplate*> TplList;
+			TplList& getTemplates()
+			{ 
+				return tpls_; 
+			}
+			void reset()
+			{
+				currTpl_ = 0;
+				tpls_.clear();
+			}
+			void destroyTemplates()
+			{
+				ConstVectorIterator<TplList> it(tpls_);
+				while (it.hasMoreElements())
+					delete it.getNextRef().second;
+				tpls_.clear();
+			}
+		private:
+			TplList			tpls_;
+			ModelTemplate*	currTpl_;
+		};
+	} // namespace detail
+
+	bool ModelManager::loadTemplatesFromDotModel(const String& fn)
+	{
+		// Read dotscene file into DOM
+
+		yake::data::dom::xml::XmlSerializer ser;
+		ser.parse( fn, false );
+		YAKE_ASSERT( ser.getDocumentNode() )( fn ).error("Could not parse dotModel document!");
+
+		// Parse DOM and create objects
+
+		data::parser::dotmodel::DotModelParserV1 parser;
+
+		detail::DotModelListener listener;
+
+		parser.subscribeToModelSignal( Bind1( &detail::DotModelListener::onBeginModel,&listener ) );
+		parser.subscribeToModelComponentSignal( Bind1( &detail::DotModelListener::onModelComponent,&listener ) );
+		parser.subscribeToModelFinishedSignal( Bind1( &detail::DotModelListener::onEndModel,&listener ) );
+
+		if (!parser.load( ser.getDocumentNode() ))
+		{
+			listener.destroyTemplates();
+			return false;
+		}
+
+		// store templates
+		detail::DotModelListener::TplList& tpls = listener.getTemplates();
+		VectorIterator<detail::DotModelListener::TplList> itTpl(tpls);
+		while (itTpl.hasMoreElements())
+		{
+			detail::DotModelListener::TplList::value_type tpl = itTpl.getNext();
+			this->modelTemplates_[tpl.first] = SharedPtr<ModelTemplate>(tpl.second);
+		}
+		listener.reset();
+
+		return true;
+	}
+	Model* ModelManager::createModelFromTemplate(const String& modelName, const String& tplName)
+	{
+		YAKE_ASSERT( !modelName.empty() )(modelName)(tplName);
+		YAKE_ASSERT( !tplName.empty() )(modelName)(tplName);
+
+		// lookup template
+		ModelTemplateList::const_iterator it = this->modelTemplates_.find( tplName );
+		YAKE_ASSERT( it != this->modelTemplates_.end() )(modelName)(tplName);
+
+		// bail out if template could not be found
+		if (it == this->modelTemplates_.end())
+			return 0;
+
+		// create model using template
+		YAKE_ASSERT( it->second.get() )(modelName)(tplName);
+		return this->createModel(modelName, it->second->getComponentDescriptions());
+	}
+
+} // namespace model
+} // namespace yake



From codeandroid at berlios.de  Tue Jun 20 22:00:22 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 20 Jun 2006 22:00:22 +0200
Subject: [Yake-svn] r1353 - trunk/yake/src/yake/data
Message-ID: <200606202000.k5KK0Mqf023828@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-20 22:00:21 +0200 (Tue, 20 Jun 2006)
New Revision: 1353

Modified:
   trunk/yake/src/yake/data/yakeXMLSerializer.cpp
Log:
improved error handling/reporting

Modified: trunk/yake/src/yake/data/yakeXMLSerializer.cpp
===================================================================
--- trunk/yake/src/yake/data/yakeXMLSerializer.cpp	2006-06-20 20:00:02 UTC (rev 1352)
+++ trunk/yake/src/yake/data/yakeXMLSerializer.cpp	2006-06-20 20:00:21 UTC (rev 1353)
@@ -152,13 +152,21 @@
 
 		mXmlDoc = new TiXmlDocument( rFile.c_str() );
 		bool ret = mXmlDoc->LoadFile();
-		YAKE_ASSERT( ret && "Could not load xml file.")( rFile ).warning("Could not load xml file.");
+		YAKE_ASSERT( ret && "Could not load xml file.")( rFile )( mXmlDoc->ErrorDesc() ).debug("Could not load xml file.");
+		if (!ret)
+		{
+			reset();
+			return;
+		}
 
 		// read contents
 		mRootElem = mXmlDoc->RootElement();
-		YAKE_ASSERT( mRootElem ).warning("No root element found in document!");
+		YAKE_ASSERT( mRootElem ).debug("No root element found in document!");
 		if (!mRootElem)
+		{
+			reset();
 			return;
+		}
 		mRootNode.reset( new XmlNode( mRootElem ) );
 
 		// recursively traverse xml tree and fire events as needed



From codeandroid at berlios.de  Tue Jun 20 22:00:39 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 20 Jun 2006 22:00:39 +0200
Subject: [Yake-svn] r1354 - trunk/yake/src/yake/samples/model/dotScene
Message-ID: <200606202000.k5KK0dJH023937@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-20 22:00:39 +0200 (Tue, 20 Jun 2006)
New Revision: 1354

Modified:
   trunk/yake/src/yake/samples/model/dotScene/demo.cpp
Log:
added dotModel templates

Modified: trunk/yake/src/yake/samples/model/dotScene/demo.cpp
===================================================================
--- trunk/yake/src/yake/samples/model/dotScene/demo.cpp	2006-06-20 20:00:21 UTC (rev 1353)
+++ trunk/yake/src/yake/samples/model/dotScene/demo.cpp	2006-06-20 20:00:39 UTC (rev 1354)
@@ -142,10 +142,19 @@
 
 		// create models :)
 
+		// method #1
 		model::Model* m = modelMgr.createModel("m1","graphics/dotScene:name=gfx;file=../../media/samples/dotScene/DotScene1.scene");
 		YAKE_ASSERT( m );
 		((model::Graphical*)m->getComponentByTag("gfx"))->translate(Vector3(40,20,0));
 
+		// method #2 - using dotModel templates
+		bool success = modelMgr.loadTemplatesFromDotModel("E:/dev/yake.trunk/yake/common/media/samples/dotLink/DynTest/DotScene1.model");
+		YAKE_ASSERT( success );
+		m = modelMgr.createModelFromTemplate("m3", "dotscene1");
+		YAKE_ASSERT( m );
+		((model::Graphical*)m->getComponentByTag("gfx"))->translate(Vector3(-100,100,-200));
+
+		// method #1 - but more complex
 		m = modelMgr.createModel("m2",
 			"graphics/dotScene:name=baseGraphical;file=../../media/samples/dotLink/DynTest/DotScene1.scene"
 			"|physics/dotXODE:name=basePhysical;file=../../media/samples/dotLink/DynTest/DotScene1.xode"



From codeandroid at berlios.de  Tue Jun 20 22:06:37 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 20 Jun 2006 22:06:37 +0200
Subject: [Yake-svn] r1355 - trunk/yake/src/yapp
Message-ID: <200606202006.k5KK6bGg024783@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-20 22:06:36 +0200 (Tue, 20 Jun 2006)
New Revision: 1355

Removed:
   trunk/yake/src/yapp/loader/
   trunk/yake/src/yapp/model/
Log:
deleted because code got deprecated and was rewritten in yake/loader and yake/model.



From codeandroid at berlios.de  Tue Jun 20 22:07:23 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 20 Jun 2006 22:07:23 +0200
Subject: [Yake-svn] r1356 - trunk/yake/yapp
Message-ID: <200606202007.k5KK7Nw7024895@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-20 22:07:23 +0200 (Tue, 20 Jun 2006)
New Revision: 1356

Removed:
   trunk/yake/yapp/loader/
   trunk/yake/yapp/model/
Log:
deleted because code got deprecated and was rewritten in yake/loader and yake/model.



From codeandroid at berlios.de  Tue Jun 20 22:09:25 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 20 Jun 2006 22:09:25 +0200
Subject: [Yake-svn] r1357 - trunk/yake/common/media/samples/dotLink/DynTest
Message-ID: <200606202009.k5KK9Pna025493@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-20 22:09:24 +0200 (Tue, 20 Jun 2006)
New Revision: 1357

Modified:
   trunk/yake/common/media/samples/dotLink/DynTest/DotScene1.model
Log:
demo object

Modified: trunk/yake/common/media/samples/dotLink/DynTest/DotScene1.model
===================================================================
--- trunk/yake/common/media/samples/dotLink/DynTest/DotScene1.model	2006-06-20 20:07:23 UTC (rev 1356)
+++ trunk/yake/common/media/samples/dotLink/DynTest/DotScene1.model	2006-06-20 20:09:24 UTC (rev 1357)
@@ -0,0 +1,7 @@
+<models>
+	<model name="DotScene1">
+		<component name="gfx" type="graphics/dotScene">
+			<parameter name="file" value="../../media/samples/dotLink/DynTest/DotScene1.scene" />
+		</component>
+	</model>
+</models>
\ No newline at end of file



From codeandroid at berlios.de  Tue Jun 20 22:10:40 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Tue, 20 Jun 2006 22:10:40 +0200
Subject: [Yake-svn] r1358 - trunk/yake/scripts/msvc8
Message-ID: <200606202010.k5KKAegq025724@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-20 22:10:35 +0200 (Tue, 20 Jun 2006)
New Revision: 1358

Modified:
   trunk/yake/scripts/msvc8/model.vcproj
Log:
added dotModel templates

Modified: trunk/yake/scripts/msvc8/model.vcproj
===================================================================
--- trunk/yake/scripts/msvc8/model.vcproj	2006-06-20 20:09:24 UTC (rev 1357)
+++ trunk/yake/scripts/msvc8/model.vcproj	2006-06-20 20:10:35 UTC (rev 1358)
@@ -220,6 +220,10 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\yake\model\yakeDotModelParser.cpp"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\yake\model\yakeGraphical.cpp"
 				>
 			</File>
@@ -260,6 +264,14 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\yake\model\yakeModelTemplate.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\yake\model\yakeModelTemplateManager.cpp"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\yake\model\yakePhysical.cpp"
 				>
 			</File>
@@ -286,6 +298,10 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\yake\model\model_dotmodel_parser.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\yake\model\model_graphical_dotscene_loader.h"
 				>
 			</File>



From codeandroid at berlios.de  Wed Jun 21 20:30:55 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Wed, 21 Jun 2006 20:30:55 +0200
Subject: [Yake-svn] r1359 - in trunk/yake: src/yapp/plugins/modelLua src/yapp/plugins/terrainPhysMgr yapp/plugins/terrainPhysMgr
Message-ID: <200606211830.k5LIUtZ4020076@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-21 20:30:52 +0200 (Wed, 21 Jun 2006)
New Revision: 1359

Modified:
   trunk/yake/src/yapp/plugins/modelLua/yakeLuaBinder.cpp
   trunk/yake/src/yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.cpp
   trunk/yake/yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.h
Log:
ported to new 'model' component

Modified: trunk/yake/src/yapp/plugins/modelLua/yakeLuaBinder.cpp
===================================================================
--- trunk/yake/src/yapp/plugins/modelLua/yakeLuaBinder.cpp	2006-06-20 20:10:35 UTC (rev 1358)
+++ trunk/yake/src/yapp/plugins/modelLua/yakeLuaBinder.cpp	2006-06-21 18:30:52 UTC (rev 1359)
@@ -22,7 +22,7 @@
 #include <yapp/plugins/modelLua/yakeLuaBinder.h>
 #include <luabind/luabind.hpp>
 
-#include <yapp/model/yakeGraphical.h>
+#include <yake/model/model.h>
 
 namespace yake
 {
@@ -45,14 +45,40 @@
 
 				module( YAKE_MODEL_MODULE )
 				[
-				    class_<Graphical>( "Graphical" )
+				    class_<ModelComponent>( "ModelComponent" )
+					//.def( constructor<>() )
+				];
+
+				module( YAKE_MODEL_MODULE )
+				[
+				    class_<Graphical,ModelComponent>( "Graphical" )
 					.def( constructor<>() )
 					.def( "addSceneNode", &Graphical::addSceneNode )
-					.def( "getSceneNodes", &Graphical::getSceneNodes )
+					//.def( "getSceneNodes", &Graphical::getSceneNodes )
 					.def( "getSceneNode", &Graphical::getSceneNode )
-					.def( "fromDotScene", &Graphical::fromDotScene )
+					.def( "getEntity", &Graphical::getEntity )
+					.def( "getLight", &Graphical::getLight )
+					.def( "translate", &Graphical::translate )
 				];
 
+				module( YAKE_MODEL_MODULE )
+				[
+				    class_<Physical,ModelComponent>( "Physical" )
+					.def( constructor<>() )
+					.def( "addActor", &Physical::addActor )
+					.def( "addBody", &Physical::addBody )
+					.def( "addJoint", &Physical::addBody )
+					.def( "addAffector", &Physical::addAffector )
+					.def( "addAffectorTargetActor", &Physical::addAffectorTargetActor )
+					//void addAffectorTargetBody(physics::IBodyAffector*,physics::IBody*);
+					//void addAffectorTargetBody(physics::IBodyAffector*,const String& bodyXPath);
+					.def( "getActor", &Physical::getActor )
+					.def( "getBody", &Physical::getBody )
+					.def( "getJoint", &Physical::getJoint )
+					.def( "getAffector", &Physical::getAffector )
+					//.def( "translate", &Physical::translate )
+					.def( "updateAffectors", &Physical::updateAffectors )
+				];
 			}
 
 

Modified: trunk/yake/src/yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.cpp
===================================================================
--- trunk/yake/src/yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.cpp	2006-06-20 20:10:35 UTC (rev 1358)
+++ trunk/yake/src/yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.cpp	2006-06-21 18:30:52 UTC (rev 1359)
@@ -1,364 +1,364 @@
-#include <vector>
-
-#include <yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.h>
-
+#include <vector>
+
+#include <yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.h>
+
 #include <yake/base/yake.h>
-#include <yake/plugins/physicsODE/OdeWorld.h>
-#include <yake/plugins/physicsODE/OdeBody.h>
-#include <yake/plugins/physicsODE/OdeActor.h>
-#include <yake/plugins/physicsODE/OdeShapes.h>
-
-#include <yapp/plugins/terrainPhysMgr/TerrainOdeActor.h>
-#include <yapp/plugins/terrainPhysMgr/TerrainOdeShape.h>
-
-#include <yake/plugins/graphicsOgre/yakePCH.h>
-
-#include "OgrePagingLandScapeOptions.h"
-#include "OgrePagingLandScapeListener.h"
-#include "OgrePagingLandScapeTile.h"
-#include "OgrePagingLandScapeTileInfo.h"
-#include "OgrePagingLandScapeIndexBuffer.h"
-#include "OgrePagingLandScapeRenderable.h"
-#include "OgrePagingLandScapeTileManager.h"
-#include "OgrePagingLandScapeRaySceneQuery.h"
-
-using namespace std;
-using namespace Ogre;
-
-namespace yake
-{
-	namespace physics
-	{
-		PLSMTerrainPhysicsManager::PLSMTerrainPhysicsManager( ) :
-				sceneManager ( 0 ), pageLoadListener( 0 ), terrainCollisionDetectionActor( 0 ),  rayQuery(0),
-				graphicsWorld( 0)
-		{}
-		//---------------------------------------------------------------------------------------------
-
-		PLSMTerrainPhysicsManager::~PLSMTerrainPhysicsManager()
-		{
-			sceneManager->destroyQuery( rayQuery);
-			sceneManager->setOption( "removeLoadPageListener", pageLoadListener );
-			odeWorld->destroyActor( terrainCollisionDetectionActor );
-		}
-		//---------------------------------------------------------------------------------------------
-		
-		void PLSMTerrainPhysicsManager::init( Ogre::PagingLandScapeSceneManager * _sceneManager,
-				IWorld *_odeWorld, graphics::IWorld* _graphicsWorld)
-		{
-			this->graphicsWorld = _graphicsWorld;
-			
-			YAKE_LOG("Inititalizing Terrain Physics Manager...");
-			
-			this->odeWorld = dynamic_cast<OdeWorld *>( _odeWorld );
-
-			//add to physical world our new terrain actor
-			terrainCollisionDetectionActor = new TerrainCollisionDetectionActor( odeWorld );
-
-			odeWorld->addActor( terrainCollisionDetectionActor );
-
-			sceneManager = _sceneManager;
-
-			//create PageLoading event listener
-			pageLoadListener = new Ogre::PagingLandscapeDelegate( &( *this ),
-			                   &PLSMTerrainPhysicsManager::pageLoaded );
-
-			tileLoadListener = new Ogre::PagingLandscapeDelegate( &( *this ),
-			                   &PLSMTerrainPhysicsManager::tileLoaded );
-
-			// sceneManager->setOption( "addLoadPageListener", pageLoadListener );
-			sceneManager->setOption( "addLoadTileListener", tileLoadListener );
-			
-			rayQuery = sceneManager->createRayQuery( Ogre::Ray(Ogre::Vector3::ZERO, Ogre::Vector3::NEGATIVE_UNIT_Y));
-			
-			YAKE_ASSERT( rayQuery);
-		}
-		//---------------------------------------------------------------------------------------------
-
-		void PLSMTerrainPhysicsManager::tileLoaded( Ogre::PagingLandscapeEvent* event )
-		{
-			YAKE_LOG("Tile loaded event handler entered...");
-			//recover PLSM2's tile object
-			int pageX = event->mPagex;
-			int pageZ = event->mPagez;
-
-			Ogre::PagingLandScapePage * page = sceneManager->getPageManager()->getPage( pageX, pageZ );
-
-			PagingLandScapeTile * tile = page->getTile( event->mTilex, event->mTilez );
-
-			createCollisionBoundingBox( tile );
-		}
-		//---------------------------------------------------------------------------------------------
-
-		void PLSMTerrainPhysicsManager::pageLoaded( Ogre::PagingLandscapeEvent* event )
-		{
-			YAKE_LOG("Page loaded event handler entered...");
-			//recover PLSM2's tile object
-			int pageX = event->mPagex;
-			int pageZ = event->mPagez;
-			Ogre::PagingLandScapePage * page = sceneManager->getPageManager()->getPage( pageX, pageZ );
-
-			processAllTilesInPage( page, pageX, pageZ );
-		}
-		//---------------------------------------------------------------------------------------------
-
-		void PLSMTerrainPhysicsManager::processAllTilesInPage( Ogre::PagingLandScapePage * page, int pageX, int pageZ )
-		{
-			int tileQuantity = sceneManager->getOptions()->NumTiles;
-
-			PagingLandScapeTile * tile = 0;
-
-			for ( int i = 0; i < tileQuantity; ++i )
-			{
-				for ( int j = 0; j < tileQuantity; ++j )
-				{
-					tile = page->getTile( i, j );
-
-					createCollisionBoundingBox( tile );
-				}
-			}
-		}
-		//---------------------------------------------------------------------------------------------
-
-		void PLSMTerrainPhysicsManager::createCollisionBoundingBox( Ogre::PagingLandScapeTile* tile )
-		{
- 			if ( find( alreadyLoadedCollisionDetectionTiles.begin(), alreadyLoadedCollisionDetectionTiles.end(), tile ) !=
-						 alreadyLoadedCollisionDetectionTiles.end() )
- 				return;
- 			else
- 				alreadyLoadedCollisionDetectionTiles.push_back( tile);
-
-			Ogre::AxisAlignedBox tileBbox = tile->getWorldBbox();
-
-			Ogre::Vector3 tmpVector = tileBbox.getMaximum() - tileBbox.getMinimum();
-			math::Vector3 bboxDims = VEC_OGRE2YAKE( tmpVector );
-			
-			tmpVector = tile->getCenter();
- 			math::Vector3 bboxCenter = VEC_OGRE2YAKE( tmpVector );
-  			
- 			terrainCollisionDetectionActor ->createTerrainCollisionDetectionShape( bboxDims, bboxCenter, tile->getInfo() );
-			
-			 ///uncoment to create a tile visual BBox
-			if( graphicsWorld != 0)
-			{
-				graphics::ISceneNode* pTerrainSN = graphicsWorld->createSceneNode();
-	
-				graphics::IEntity* pTerrainE = graphicsWorld->createEntity( "box_1x1x1.mesh" );
-	
-				pTerrainE->setMaterial("box");
-	
-				pTerrainSN->attachEntity( pTerrainE );
-	
-				pTerrainSN->setScale( bboxDims );
-	
-				pTerrainSN->setPosition( bboxCenter );
-	
-				model::Graphical* pG = new model::Graphical();
-				
-				pG->addSceneNode( pTerrainSN );
-			}
-		}
-		//---------------------------------------------------------------------------------------------
-
-		void PLSMTerrainPhysicsManager::convertIndexDataForOde( Ogre::IndexData* indexData, TriangleMeshDesc::IndexVector &
-			destBuffer) 
-		{
-			// code snipet from OgreOde project
-			Ogre::HardwareIndexBufferSharedPtr ibuf = indexData->indexBuffer;
-			
-			bool use32bitindexes = ( ibuf->getType() == Ogre::HardwareIndexBuffer::IT_32BIT);
-			
-			unsigned short* pShort = 0;
-			unsigned int* pInt = 0;
-
-			if (use32bitindexes) 
-				pInt = static_cast<unsigned int*>(ibuf->lock( Ogre::HardwareBuffer::HBL_READ_ONLY));
-			else 
-				pShort = static_cast<unsigned short*>(ibuf->lock( Ogre::HardwareBuffer::HBL_READ_ONLY));
-
-			size_t numTris = indexData->indexCount / 3;
-			size_t index_offset = 0;
-			
-			destBuffer.resize( indexData->indexCount);
-						
-			for( size_t k = 0; k < numTris; ++k)
-			{
-				unsigned int vindex = use32bitindexes? *pInt++ : *pShort++;
-				destBuffer[index_offset + 0] = vindex;
-				
-				vindex = use32bitindexes? *pInt++ : *pShort++;
-				destBuffer[index_offset + 1] = vindex;
-				
-				vindex = use32bitindexes? *pInt++ : *pShort++;
-				destBuffer[index_offset + 2] = vindex;
-
-				index_offset += 3;
-			}
-			
-			ibuf->unlock();
-		}
-		//------------------------------------------------------------------------------------
-
-		class OdeVertexConverter
-		{
-			public:
-				OdeVertexConverter( Ogre::Vector3 & parentSNPosition) : pSN( parentSNPosition) {};
-				
-				math::Vector3 operator()( const Ogre::Vector3 & val)
-				{
-					Ogre::Vector3 result = val - pSN;
-					
-					return VEC_OGRE2YAKE( result);
-				}
-				//------------------------------------------------------------------------------------
-
-			protected:
-				Ogre::Vector3 pSN;
-		};
-		//------------------------------------------------------------------------------------
-
-		void PLSMTerrainPhysicsManager::processTile( Ogre::PagingLandScapeTileInfo * tileInfo )
-		{
-			Ogre::PagingLandScapePage * page = 
-					sceneManager->getPageManager()->getPage( tileInfo->pageX, tileInfo->pageZ );
-
-			YAKE_ASSERT( page ).error( "Page pointer is invalid!" );
-
-			Ogre::PagingLandScapeTile * tile = page->getTile( tileInfo->tileX, tileInfo->tileZ ) ;
-
-			YAKE_ASSERT( tile ).error( "Tile pointer is invalid!" );
-
- 			if ( find( alreadyLoadedCollisionTiles.begin(), alreadyLoadedCollisionTiles.end(), tile ) !=
-				alreadyLoadedCollisionTiles.end() )
- 				return; // nothing to be done because tile already processed 
- 			else
-			{
-// 				YAKE_LOG( ( "--->>>>Got new tile for creating ode trimesh<<<<---" ) );
-// 				std::cerr << "Page ( " << tileInfo->pageX << ", " << tileInfo->pageZ << ")" << std::endl;
-// 				std::cerr << "Tile ( " << tileInfo->tileX << ", " << tileInfo->tileZ << ")" << std::endl;
-
-				alreadyLoadedCollisionTiles.push_back( tile );
-			}
-			
-			Ogre::PagingLandScapeRenderable* rend = tile->getRenderable();
-
-			YAKE_ASSERT( rend ).error( "Renderable pointer is invalid!" );
-
-			vector< void*> params;
-			int renderLevel = 0;
-
-			params.push_back( &tileInfo->pageX );
-			params.push_back( &tileInfo->pageZ );
-			params.push_back( &tileInfo->tileX );
-			params.push_back( &tileInfo->tileZ );
-			params.push_back( &renderLevel );
-
-			sceneManager->getOption( "PageGetTileVertexData_2", &params );
-			
-			//get tile parenent SN position
-			Ogre::SceneNode * sceneNode = tile->getSceneNode();
-			Ogre::Vector3 parentSNPosition = sceneNode->getWorldPosition();
-		
-			// get vertices
-			int * numVtx = ( ( int* ) params[ 5 ] );
-			Ogre::Vector3 * ogreVertices = ( ( Ogre::Vector3* ) params[ 6 ] );
-			
-			TriangleMeshDesc::VertexVector vertices( *numVtx, math::Vector3( 0, 0, 0 ) );
-			
-			std::transform( ogreVertices, ogreVertices + *numVtx, vertices.begin(), OdeVertexConverter( parentSNPosition) );
-
-			// get  indexes
-			Ogre::IndexData* indexData = ( ( Ogre::IndexData* ) params[ 7 ] );
-			YAKE_ASSERT( indexData->indexCount).error( "There is no indexes!");
-			
-			TriangleMeshDesc::IndexVector indexes;
-			convertIndexDataForOde( indexData, indexes);
-					
-			terrainCollisionDetectionActor->createTerrainCollisionShape( VEC_OGRE2YAKE( parentSNPosition), vertices, indexes);
-			
-			delete[] ogreVertices;
-		}
-		//------------------------------------------------------------------------------------
-		
-		real PLSMTerrainPhysicsManager::getHeightAt( const math::Vector3& position)
-		{
-			return getHeightAt( VEC_YAKE2OGRE( position));
-		}
-		//------------------------------------------------------------------------------------
-		
-		real PLSMTerrainPhysicsManager::getHeightAt( const Ogre::Vector3& position)
-		{
-			// register ray query for getHeightAt function
-			ray.setOrigin( position);
-			ray.setDirection( Ogre::Vector3::UNIT_Y);
-	
-			rayQuery->setRay( ray);
-			rayQuery->setQueryMask( Ogre::RSQ_Height);
-			
-			Ogre::RaySceneQueryResult & result = rayQuery->execute(); 
-			Ogre::RaySceneQueryResult::iterator i = result.begin(); 
- 			
-			Ogre::Real terrainHeight;
-			
-			if (i != result.end() && i->worldFragment) 
-				terrainHeight = i->worldFragment->singleIntersection.y;
-			
-			std::cerr<<"Terrain Height  =  "<< terrainHeight;
-			
-			return position.y - terrainHeight;//helperQueryListener.heightAt;
-		}
-		//------------------------------------------------------------------------------------
-
-		Ogre::AxisAlignedBox PLSMTerrainPhysicsManager::calcActorAABB(  IActor * _actor)
-		{
-			OdeActor * actor = dynamic_cast<OdeActor * >( _actor);
-			YAKE_ASSERT( actor).error( "Wrong actor type - expected OdeActor...");
-			
-			IShapePtrList shapesList = actor->getShapes();
-			
-			ConstDequeIterator< IShapePtrList> itShape( shapesList );
-
-			Ogre::AxisAlignedBox resultAABB;
-			
-			// iterate over all shapes and found their containing AABB
-			while (itShape.hasMoreElements())
-			{
-				const physics::IShapePtr pShape = itShape.getNext();
-			
-				OdeGeom * odeGeom = dynamic_cast<OdeGeom*>( pShape);
-				YAKE_ASSERT( odeGeom).error( "Wrong shape type - expected OdeGeom...");
-				
-				dGeomID odeGeomID = odeGeom->_getOdeGeomID();
-				
-				dReal odeAABB[6];
-				dGeomGetAABB( odeGeomID, odeAABB); // catch ODE AABB
-				
-				Ogre::AxisAlignedBox  ogreAABB( odeAABB[0], odeAABB[2], odeAABB[4], //mx, my, mz 
-						odeAABB[1], odeAABB[3], odeAABB[5]); //Mx, My, Mz
-				
-				resultAABB.merge( ogreAABB);
-			}
-			return resultAABB;
-		}
-		//------------------------------------------------------------------------------------
-
-		void PLSMTerrainPhysicsManager::placeActorOnTerrain( const math::Vector3 & position, IActor * _actor)
-		{
-			//Actualy, on the ground we will place actor AABB 
-			Ogre::AxisAlignedBox actorAABB = calcActorAABB( _actor) ; 
-			
-			Ogre::Vector3 actorPosition = actorAABB.getCenter();
-			
-			Ogre::Vector3 actorDims = actorAABB.getMaximum() - actorAABB.getMinimum();
-			
-			real terrainHeightAtActorPos = getHeightAt( actorPosition);
-			
-			actorPosition.y -= terrainHeightAtActorPos;
-			actorPosition.y += actorDims.y / 2.0;
-			
-			_actor->setPosition( VEC_OGRE2YAKE( actorPosition));
-		}
-		//------------------------------------------------------------------------------------
-
-	}
-}
+#include <yake/plugins/physicsODE/OdeWorld.h>
+#include <yake/plugins/physicsODE/OdeBody.h>
+#include <yake/plugins/physicsODE/OdeActor.h>
+#include <yake/plugins/physicsODE/OdeShapes.h>
+
+#include <yapp/plugins/terrainPhysMgr/TerrainOdeActor.h>
+#include <yapp/plugins/terrainPhysMgr/TerrainOdeShape.h>
+
+#include <yake/plugins/graphicsOgre/yakePCH.h>
+
+#include "OgrePagingLandScapeOptions.h"
+#include "OgrePagingLandScapeListener.h"
+#include "OgrePagingLandScapeTile.h"
+#include "OgrePagingLandScapeTileInfo.h"
+#include "OgrePagingLandScapeIndexBuffer.h"
+#include "OgrePagingLandScapeRenderable.h"
+#include "OgrePagingLandScapeTileManager.h"
+#include "OgrePagingLandScapeRaySceneQuery.h"
+
+using namespace std;
+using namespace Ogre;
+
+namespace yake
+{
+	namespace physics
+	{
+		PLSMTerrainPhysicsManager::PLSMTerrainPhysicsManager( ) :
+				sceneManager ( 0 ), pageLoadListener( 0 ), terrainCollisionDetectionActor( 0 ),  rayQuery(0),
+				graphicsWorld( 0)
+		{}
+		//---------------------------------------------------------------------------------------------
+
+		PLSMTerrainPhysicsManager::~PLSMTerrainPhysicsManager()
+		{
+			sceneManager->destroyQuery( rayQuery);
+			sceneManager->setOption( "removeLoadPageListener", pageLoadListener );
+			odeWorld->destroyActor( terrainCollisionDetectionActor );
+		}
+		//---------------------------------------------------------------------------------------------
+		
+		void PLSMTerrainPhysicsManager::init( Ogre::PagingLandScapeSceneManager * _sceneManager,
+				IWorld *_odeWorld, graphics::IWorld* _graphicsWorld)
+		{
+			this->graphicsWorld = _graphicsWorld;
+			
+			YAKE_LOG("Inititalizing Terrain Physics Manager...");
+			
+			this->odeWorld = dynamic_cast<OdeWorld *>( _odeWorld );
+
+			//add to physical world our new terrain actor
+			terrainCollisionDetectionActor = new TerrainCollisionDetectionActor( odeWorld );
+
+			odeWorld->addActor( terrainCollisionDetectionActor );
+
+			sceneManager = _sceneManager;
+
+			//create PageLoading event listener
+			pageLoadListener = new Ogre::PagingLandscapeDelegate( &( *this ),
+			                   &PLSMTerrainPhysicsManager::pageLoaded );
+
+			tileLoadListener = new Ogre::PagingLandscapeDelegate( &( *this ),
+			                   &PLSMTerrainPhysicsManager::tileLoaded );
+
+			// sceneManager->setOption( "addLoadPageListener", pageLoadListener );
+			sceneManager->setOption( "addLoadTileListener", tileLoadListener );
+			
+			rayQuery = sceneManager->createRayQuery( Ogre::Ray(Ogre::Vector3::ZERO, Ogre::Vector3::NEGATIVE_UNIT_Y));
+			
+			YAKE_ASSERT( rayQuery);
+		}
+		//---------------------------------------------------------------------------------------------
+
+		void PLSMTerrainPhysicsManager::tileLoaded( Ogre::PagingLandscapeEvent* event )
+		{
+			YAKE_LOG("Tile loaded event handler entered...");
+			//recover PLSM2's tile object
+			int pageX = event->mPagex;
+			int pageZ = event->mPagez;
+
+			Ogre::PagingLandScapePage * page = sceneManager->getPageManager()->getPage( pageX, pageZ );
+
+			PagingLandScapeTile * tile = page->getTile( event->mTilex, event->mTilez );
+
+			createCollisionBoundingBox( tile );
+		}
+		//---------------------------------------------------------------------------------------------
+
+		void PLSMTerrainPhysicsManager::pageLoaded( Ogre::PagingLandscapeEvent* event )
+		{
+			YAKE_LOG("Page loaded event handler entered...");
+			//recover PLSM2's tile object
+			int pageX = event->mPagex;
+			int pageZ = event->mPagez;
+			Ogre::PagingLandScapePage * page = sceneManager->getPageManager()->getPage( pageX, pageZ );
+
+			processAllTilesInPage( page, pageX, pageZ );
+		}
+		//---------------------------------------------------------------------------------------------
+
+		void PLSMTerrainPhysicsManager::processAllTilesInPage( Ogre::PagingLandScapePage * page, int pageX, int pageZ )
+		{
+			int tileQuantity = sceneManager->getOptions()->NumTiles;
+
+			PagingLandScapeTile * tile = 0;
+
+			for ( int i = 0; i < tileQuantity; ++i )
+			{
+				for ( int j = 0; j < tileQuantity; ++j )
+				{
+					tile = page->getTile( i, j );
+
+					createCollisionBoundingBox( tile );
+				}
+			}
+		}
+		//---------------------------------------------------------------------------------------------
+
+		void PLSMTerrainPhysicsManager::createCollisionBoundingBox( Ogre::PagingLandScapeTile* tile )
+		{
+ 			if ( find( alreadyLoadedCollisionDetectionTiles.begin(), alreadyLoadedCollisionDetectionTiles.end(), tile ) !=
+						 alreadyLoadedCollisionDetectionTiles.end() )
+ 				return;
+ 			else
+ 				alreadyLoadedCollisionDetectionTiles.push_back( tile);
+
+			Ogre::AxisAlignedBox tileBbox = tile->getWorldBbox();
+
+			Ogre::Vector3 tmpVector = tileBbox.getMaximum() - tileBbox.getMinimum();
+			math::Vector3 bboxDims = VEC_OGRE2YAKE( tmpVector );
+			
+			tmpVector = tile->getCenter();
+ 			math::Vector3 bboxCenter = VEC_OGRE2YAKE( tmpVector );
+  			
+ 			terrainCollisionDetectionActor ->createTerrainCollisionDetectionShape( bboxDims, bboxCenter, tile->getInfo() );
+			
+			 ///uncoment to create a tile visual BBox
+			if( graphicsWorld != 0)
+			{
+				graphics::ISceneNode* pTerrainSN = graphicsWorld->createSceneNode();
+	
+				graphics::IEntity* pTerrainE = graphicsWorld->createEntity( "box_1x1x1.mesh" );
+	
+				pTerrainE->setMaterial("box");
+	
+				pTerrainSN->attachEntity( pTerrainE );
+	
+				pTerrainSN->setScale( bboxDims );
+	
+				pTerrainSN->setPosition( bboxCenter );
+	
+				model::Graphical* pG = new model::Graphical();
+				
+				pG->addSceneNode( pTerrainSN, uniqueName::create() );
+			}
+		}
+		//---------------------------------------------------------------------------------------------
+
+		void PLSMTerrainPhysicsManager::convertIndexDataForOde( Ogre::IndexData* indexData, TriangleMeshDesc::IndexVector &
+			destBuffer) 
+		{
+			// code snipet from OgreOde project
+			Ogre::HardwareIndexBufferSharedPtr ibuf = indexData->indexBuffer;
+			
+			bool use32bitindexes = ( ibuf->getType() == Ogre::HardwareIndexBuffer::IT_32BIT);
+			
+			unsigned short* pShort = 0;
+			unsigned int* pInt = 0;
+
+			if (use32bitindexes) 
+				pInt = static_cast<unsigned int*>(ibuf->lock( Ogre::HardwareBuffer::HBL_READ_ONLY));
+			else 
+				pShort = static_cast<unsigned short*>(ibuf->lock( Ogre::HardwareBuffer::HBL_READ_ONLY));
+
+			size_t numTris = indexData->indexCount / 3;
+			size_t index_offset = 0;
+			
+			destBuffer.resize( indexData->indexCount);
+						
+			for( size_t k = 0; k < numTris; ++k)
+			{
+				unsigned int vindex = use32bitindexes? *pInt++ : *pShort++;
+				destBuffer[index_offset + 0] = vindex;
+				
+				vindex = use32bitindexes? *pInt++ : *pShort++;
+				destBuffer[index_offset + 1] = vindex;
+				
+				vindex = use32bitindexes? *pInt++ : *pShort++;
+				destBuffer[index_offset + 2] = vindex;
+
+				index_offset += 3;
+			}
+			
+			ibuf->unlock();
+		}
+		//------------------------------------------------------------------------------------
+
+		class OdeVertexConverter
+		{
+			public:
+				OdeVertexConverter( Ogre::Vector3 & parentSNPosition) : pSN( parentSNPosition) {};
+				
+				math::Vector3 operator()( const Ogre::Vector3 & val)
+				{
+					Ogre::Vector3 result = val - pSN;
+					
+					return VEC_OGRE2YAKE( result);
+				}
+				//------------------------------------------------------------------------------------
+
+			protected:
+				Ogre::Vector3 pSN;
+		};
+		//------------------------------------------------------------------------------------
+
+		void PLSMTerrainPhysicsManager::processTile( Ogre::PagingLandScapeTileInfo * tileInfo )
+		{
+			Ogre::PagingLandScapePage * page = 
+					sceneManager->getPageManager()->getPage( tileInfo->pageX, tileInfo->pageZ );
+
+			YAKE_ASSERT( page ).error( "Page pointer is invalid!" );
+
+			Ogre::PagingLandScapeTile * tile = page->getTile( tileInfo->tileX, tileInfo->tileZ ) ;
+
+			YAKE_ASSERT( tile ).error( "Tile pointer is invalid!" );
+
+ 			if ( find( alreadyLoadedCollisionTiles.begin(), alreadyLoadedCollisionTiles.end(), tile ) !=
+				alreadyLoadedCollisionTiles.end() )
+ 				return; // nothing to be done because tile already processed 
+ 			else
+			{
+// 				YAKE_LOG( ( "--->>>>Got new tile for creating ode trimesh<<<<---" ) );
+// 				std::cerr << "Page ( " << tileInfo->pageX << ", " << tileInfo->pageZ << ")" << std::endl;
+// 				std::cerr << "Tile ( " << tileInfo->tileX << ", " << tileInfo->tileZ << ")" << std::endl;
+
+				alreadyLoadedCollisionTiles.push_back( tile );
+			}
+			
+			Ogre::PagingLandScapeRenderable* rend = tile->getRenderable();
+
+			YAKE_ASSERT( rend ).error( "Renderable pointer is invalid!" );
+
+			vector< void*> params;
+			int renderLevel = 0;
+
+			params.push_back( &tileInfo->pageX );
+			params.push_back( &tileInfo->pageZ );
+			params.push_back( &tileInfo->tileX );
+			params.push_back( &tileInfo->tileZ );
+			params.push_back( &renderLevel );
+
+			sceneManager->getOption( "PageGetTileVertexData_2", &params );
+			
+			//get tile parenent SN position
+			Ogre::SceneNode * sceneNode = tile->getSceneNode();
+			Ogre::Vector3 parentSNPosition = sceneNode->getWorldPosition();
+		
+			// get vertices
+			int * numVtx = ( ( int* ) params[ 5 ] );
+			Ogre::Vector3 * ogreVertices = ( ( Ogre::Vector3* ) params[ 6 ] );
+			
+			TriangleMeshDesc::VertexVector vertices( *numVtx, math::Vector3( 0, 0, 0 ) );
+			
+			std::transform( ogreVertices, ogreVertices + *numVtx, vertices.begin(), OdeVertexConverter( parentSNPosition) );
+
+			// get  indexes
+			Ogre::IndexData* indexData = ( ( Ogre::IndexData* ) params[ 7 ] );
+			YAKE_ASSERT( indexData->indexCount).error( "There is no indexes!");
+			
+			TriangleMeshDesc::IndexVector indexes;
+			convertIndexDataForOde( indexData, indexes);
+					
+			terrainCollisionDetectionActor->createTerrainCollisionShape( VEC_OGRE2YAKE( parentSNPosition), vertices, indexes);
+			
+			delete[] ogreVertices;
+		}
+		//------------------------------------------------------------------------------------
+		
+		real PLSMTerrainPhysicsManager::getHeightAt( const math::Vector3& position)
+		{
+			return getHeightAt( VEC_YAKE2OGRE( position));
+		}
+		//------------------------------------------------------------------------------------
+		
+		real PLSMTerrainPhysicsManager::getHeightAt( const Ogre::Vector3& position)
+		{
+			// register ray query for getHeightAt function
+			ray.setOrigin( position);
+			ray.setDirection( Ogre::Vector3::UNIT_Y);
+	
+			rayQuery->setRay( ray);
+			rayQuery->setQueryMask( Ogre::RSQ_Height);
+			
+			Ogre::RaySceneQueryResult & result = rayQuery->execute(); 
+			Ogre::RaySceneQueryResult::iterator i = result.begin(); 
+ 			
+			Ogre::Real terrainHeight;
+			
+			if (i != result.end() && i->worldFragment) 
+				terrainHeight = i->worldFragment->singleIntersection.y;
+			
+			std::cerr<<"Terrain Height  =  "<< terrainHeight;
+			
+			return position.y - terrainHeight;//helperQueryListener.heightAt;
+		}
+		//------------------------------------------------------------------------------------
+
+		Ogre::AxisAlignedBox PLSMTerrainPhysicsManager::calcActorAABB(  IActor * _actor)
+		{
+			OdeActor * actor = dynamic_cast<OdeActor * >( _actor);
+			YAKE_ASSERT( actor).error( "Wrong actor type - expected OdeActor...");
+			
+			IShapePtrList shapesList = actor->getShapes();
+			
+			ConstDequeIterator< IShapePtrList> itShape( shapesList );
+
+			Ogre::AxisAlignedBox resultAABB;
+			
+			// iterate over all shapes and found their containing AABB
+			while (itShape.hasMoreElements())
+			{
+				const physics::IShapePtr pShape = itShape.getNext();
+			
+				OdeGeom * odeGeom = dynamic_cast<OdeGeom*>( pShape);
+				YAKE_ASSERT( odeGeom).error( "Wrong shape type - expected OdeGeom...");
+				
+				dGeomID odeGeomID = odeGeom->_getOdeGeomID();
+				
+				dReal odeAABB[6];
+				dGeomGetAABB( odeGeomID, odeAABB); // catch ODE AABB
+				
+				Ogre::AxisAlignedBox  ogreAABB( odeAABB[0], odeAABB[2], odeAABB[4], //mx, my, mz 
+						odeAABB[1], odeAABB[3], odeAABB[5]); //Mx, My, Mz
+				
+				resultAABB.merge( ogreAABB);
+			}
+			return resultAABB;
+		}
+		//------------------------------------------------------------------------------------
+
+		void PLSMTerrainPhysicsManager::placeActorOnTerrain( const math::Vector3 & position, IActor * _actor)
+		{
+			//Actualy, on the ground we will place actor AABB 
+			Ogre::AxisAlignedBox actorAABB = calcActorAABB( _actor) ; 
+			
+			Ogre::Vector3 actorPosition = actorAABB.getCenter();
+			
+			Ogre::Vector3 actorDims = actorAABB.getMaximum() - actorAABB.getMinimum();
+			
+			real terrainHeightAtActorPos = getHeightAt( actorPosition);
+			
+			actorPosition.y -= terrainHeightAtActorPos;
+			actorPosition.y += actorDims.y / 2.0;
+			
+			_actor->setPosition( VEC_OGRE2YAKE( actorPosition));
+		}
+		//------------------------------------------------------------------------------------
+
+	}
+}

Modified: trunk/yake/yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.h
===================================================================
--- trunk/yake/yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.h	2006-06-20 20:10:35 UTC (rev 1358)
+++ trunk/yake/yapp/plugins/terrainPhysMgr/TerrainPhysicsManager.h	2006-06-21 18:30:52 UTC (rev 1359)
@@ -42,7 +42,7 @@
 #include <yapp/plugins/terrainPhysMgr/TerrainOdeActor.h>
 
 #include <yake/plugins/graphicsOgre/yakeGraphicsSystem.h>
-#include <yapp/model/yakeGraphical.h>
+#include <yake/model/model.h>
 
 namespace yake
 {



From codeandroid at berlios.de  Wed Jun 21 20:31:30 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Wed, 21 Jun 2006 20:31:30 +0200
Subject: [Yake-svn] r1360 - trunk/yake/scripts/msvc8/plugins/physics
Message-ID: <200606211831.k5LIVUrN020244@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-21 20:31:23 +0200 (Wed, 21 Jun 2006)
New Revision: 1360

Modified:
   trunk/yake/scripts/msvc8/plugins/physics/terrainPhysMgr.vcproj
Log:
now using ode 0.6

Modified: trunk/yake/scripts/msvc8/plugins/physics/terrainPhysMgr.vcproj
===================================================================
--- trunk/yake/scripts/msvc8/plugins/physics/terrainPhysMgr.vcproj	2006-06-21 18:30:52 UTC (rev 1359)
+++ trunk/yake/scripts/msvc8/plugins/physics/terrainPhysMgr.vcproj	2006-06-21 18:31:23 UTC (rev 1360)
@@ -63,10 +63,10 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="yapp.lib oded.lib physics.lib ogremain_d.lib Plugin_PagingLandScapeSceneManager2_d.lib"
+				AdditionalDependencies="yapp.lib ode.lib physics.lib ogremain_d.lib Plugin_PagingLandScapeSceneManager2_d.lib"
 				OutputFile="$(OutDir)/$(ProjectName).dll"
 				LinkIncremental="2"
-				AdditionalLibraryDirectories="../../../../common/lib/debug;../../../../dependencies/ode/lib;../../../../dependencies/lib;&quot;../../../../dependencies/ogrenew/ogremain/lib/$(ConfigurationName)&quot;;&quot;../../../../dependencies/ogreaddons/paginglandscape/plugins/paginglandscape2/bin/$(ConfigurationName)&quot;"
+				AdditionalLibraryDirectories="../../../../common/lib/debug;../../../../dependencies/ode/lib/debugdll;../../../../dependencies/lib;&quot;../../../../dependencies/ogrenew/ogremain/lib/$(ConfigurationName)&quot;;&quot;../../../../dependencies/ogreaddons/paginglandscape/plugins/paginglandscape2/bin/$(ConfigurationName)&quot;"
 				ModuleDefinitionFile=""
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
@@ -148,7 +148,7 @@
 				AdditionalDependencies="ode.lib physics.lib"
 				OutputFile="$(OutDir)/$(ProjectName).dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="../../../../common/lib/release;../../../../dependencies/ode/lib;../../../../dependencies/lib"
+				AdditionalLibraryDirectories="../../../../common/lib/release;../../../../dependencies/ode/lib/releasedll;../../../../dependencies/lib"
 				GenerateDebugInformation="false"
 				SubSystem="2"
 				OptimizeReferences="2"



From codeandroid at berlios.de  Wed Jun 21 21:00:43 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Wed, 21 Jun 2006 21:00:43 +0200
Subject: [Yake-svn] r1361 - trunk/yake
Message-ID: <200606211900.k5LJ0hA0028315@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-21 21:00:39 +0200 (Wed, 21 Jun 2006)
New Revision: 1361

Modified:
   trunk/yake/BUILD
Log:
updated for msvc8 and c::b

Modified: trunk/yake/BUILD
===================================================================
--- trunk/yake/BUILD	2006-06-21 18:31:23 UTC (rev 1360)
+++ trunk/yake/BUILD	2006-06-21 19:00:39 UTC (rev 1361)
@@ -22,23 +22,38 @@
 1. BUILD INSTRUCTIONS FOR YAKE ON PC/WINDOWS
 --------------------------------------------
 
-Last modified: 02/11/2005 by Stephan Kaiser (psy)
+Last modified: 21/06/2006 by Stephan Kaiser (psy)
 
 Please refer to the manual for detailed instructions.
+
+1.1 Building with Microsoft Visual C++ 2003/2005 (7.1/8.0)
+----------------------------------------------------------
+
 In essence, opening the workspace for Yake and starting
 a complete 'Build' is what you want to do.
 
-You can find the workspace here:
+You can find the workspaces for MSVC 2003 (7.1) and MSVC 2005 (8.0)
+respectively here:
 
-(yake_root_dir)/scripts/msvc71/yake.sln
+/yake/scripts/msvc71/yake.sln
+/yake/scripts/msvc8/yake.sln
 
+For stable releases of Yake for both compilers prebuilt
+dependencies packages are available.
+
 If you don't have or don't want to use the dependencies package
-containing prebuilt libraries then you have to compile these yourself
-as needed.
+then you have to compile these yourself as needed, of course.
 
-See the file <yakeroot>/dependencies/DEPENDENCIES for more information.
+See the file /yake/dependencies/DEPENDENCIES for more information.
 
+1.2 Building with Code::Blocks
+------------------------------
 
+The Code Blocks project files can be found in this directory:
+
+/yake/scripts/cb/
+
+
 2. BUILD INSTRUCTIONS FOR YAKE ON PC/LINUX
 ------------------------------------------
 



From codeandroid at berlios.de  Wed Jun 21 22:57:41 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Wed, 21 Jun 2006 22:57:41 +0200
Subject: [Yake-svn] r1362 - in trunk/yake: src/yake/net/detail yake/net yake/net/detail yake/samples/net/roclient
Message-ID: <200606212057.k5LKvfi9008078@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-21 22:57:41 +0200 (Wed, 21 Jun 2006)
New Revision: 1362

Modified:
   trunk/yake/src/yake/net/detail/netCommon.cpp
   trunk/yake/src/yake/net/detail/netEnetClientPacketConnection.cpp
   trunk/yake/src/yake/net/detail/netEnetServerPacketConnection.cpp
   trunk/yake/src/yake/net/detail/netEventConnection.cpp
   trunk/yake/yake/net/detail/netEnetClientPacketConnection.h
   trunk/yake/yake/net/detail/netEnetServerPacketConnection.h
   trunk/yake/yake/net/netCommon.h
   trunk/yake/yake/net/netPacket.h
   trunk/yake/yake/samples/net/roclient/pch.h
Log:
cleanup, various improvements,
two step connection

Modified: trunk/yake/src/yake/net/detail/netCommon.cpp
===================================================================
--- trunk/yake/src/yake/net/detail/netCommon.cpp	2006-06-21 19:00:39 UTC (rev 1361)
+++ trunk/yake/src/yake/net/detail/netCommon.cpp	2006-06-21 20:57:41 UTC (rev 1362)
@@ -134,16 +134,16 @@
 	// SendOptions
 	//-------------------------------------------------------------------------
 	SendOptions::SendOptions() :
-		peerId(0xffffffff),
-		reliability(R_RELIABLE),
-		ordering(O_ORDERED),
-		channelId(0)
+		peerId_(PEERID_BROADCAST),
+		reliability_(R_RELIABLE),
+		ordering_(O_ORDERED),
+		channelId_(0)
 	{}
 	SendOptions::SendOptions(const SendOptions& other) :
-		peerId(other.peerId),
-		reliability(other.reliability),
-		ordering(other.ordering),
-		channelId(other.channelId)
+		peerId_(other.peerId_),
+		reliability_(other.reliability_),
+		ordering_(other.ordering_),
+		channelId_(other.channelId_)
 	{}
 	SendOptions::~SendOptions()
 	{}
@@ -151,32 +151,48 @@
 	{
 		if (this == &rhs)
 			return *this;
-		peerId = rhs.peerId;
-		reliability = rhs.reliability;
-		ordering = rhs.ordering;
-		channelId = rhs.channelId;
+		peerId_ = rhs.peerId_;
+		reliability_ = rhs.reliability_;
+		ordering_ = rhs.ordering_;
+		channelId_ = rhs.channelId_;
 		return *this;
 	}
-	SendOptions& SendOptions::setPeerId(const PeerId id)
+	SendOptions& SendOptions::peerId(const PeerId id)
 	{
-		peerId = id;
+		peerId_ = id;
 		return *this;
 	}
-	SendOptions& SendOptions::setReliability(const Reliability rel)
+	SendOptions& SendOptions::reliability(const Reliability rel)
 	{
-		reliability = rel;
+		reliability_ = rel;
 		return *this;
 	}
-	SendOptions& SendOptions::setOrdering(const Ordering ord)
+	SendOptions& SendOptions::ordering(const Ordering ord)
 	{
-		ordering = ord;
+		ordering_ = ord;
 		return *this;
 	}
-	SendOptions& SendOptions::setChannel(const ChannelId id)
+	SendOptions& SendOptions::channel(const ChannelId id)
 	{
-		channelId = id;
+		channelId_ = id;
 		return *this;
 	}
+	PeerId SendOptions::getPeerId() const
+	{
+		return peerId_;
+	}
+	Reliability SendOptions::getReliability() const
+	{
+		return reliability_;
+	}
+	Ordering SendOptions::getOrdering() const
+	{
+		return ordering_;
+	}
+	ChannelId SendOptions::getChannel() const
+	{
+		return channelId_;
+	}
 
 	//-------------------------------------------------------------------------
 	// NativeTimer & Timer

Modified: trunk/yake/src/yake/net/detail/netEnetClientPacketConnection.cpp
===================================================================
--- trunk/yake/src/yake/net/detail/netEnetClientPacketConnection.cpp	2006-06-21 19:00:39 UTC (rev 1361)
+++ trunk/yake/src/yake/net/detail/netEnetClientPacketConnection.cpp	2006-06-21 20:57:41 UTC (rev 1362)
@@ -11,8 +11,14 @@
 	}
 namespace impl {
 
-	EnetClientPacketConnection::EnetClientPacketConnection() : m_host(0), m_ready(false), m_id(0), m_waitingForConnect(false),
-			m_peer(0), m_serverPeer(0), lastPacketReceivedCbHandle_(0)
+	EnetClientPacketConnection::EnetClientPacketConnection() : 
+		m_host(0), 
+		m_ready(false), 
+		m_id(0), 
+		m_waitingForConnect(false),
+		m_peer(0), 
+		m_serverPeer(0), 
+		lastPacketReceivedCbHandle_(0)
 	{
 	}
 	EnetClientPacketConnection::~EnetClientPacketConnection()
@@ -34,7 +40,7 @@
 	{
 		timeOutFnList_.push_back( fn );
 	}
-	void EnetClientPacketConnection::connect(const Address& addr)
+	void EnetClientPacketConnection::connect(const Address& addr, const bool doBlock, const uint32 timeOut)
 	{
 		NET_ASSERT( !m_ready );
 		if (m_ready)
@@ -83,6 +89,13 @@
 
 		m_connTimer.reset();
 		m_id = UpdateThread::instance().add( boost::bind(&EnetClientPacketConnection::update,this) );
+
+		if (doBlock)
+		{
+			//@todo timeout
+			while (m_waitingForConnect && !m_ready)
+				net::native::sleep(10);
+		}
 	}
 	void EnetClientPacketConnection::disconnect()
 	{
@@ -99,7 +112,7 @@
 			if (m_serverPeer)
 			{
 				boost::mutex::scoped_lock enetLock(getEnetMtx());
-				enet_peer_disconnect( m_serverPeer );
+				enet_peer_disconnect( m_serverPeer, 0 /*@todo data*/ );
 			}
 			Timer timer;
 			timer.start();
@@ -149,16 +162,16 @@
 			{
 			case ENET_EVENT_TYPE_CONNECT:
 				NET_ASSERT( event.peer );
-				NET_LOG("net_packet_client: connected to " << ipToString(event.peer->address.host) << ":" << event.peer->address.port << ".");
+				NET_LOG("net_packet_client: (stage1) connected to " << ipToString(event.peer->address.host) << ":" << event.peer->address.port << ".");
 				{
 					m_serverPeer = event.peer;
-					m_waitingForConnect = false;
-					m_ready = true;
+					m_ready = true; // we can now start sending packets
 
 					const uint32 host = event.peer->address.host;
 					m_serverIp = ipToString( host );
 
-					this->fireCallback_Started();
+					const uint8 tmp = 0x7F;
+					this->send(&tmp,1,SendOptions().reliability(R_RELIABLE));
 				}
 				break;
 			case ENET_EVENT_TYPE_RECEIVE:
@@ -166,8 +179,14 @@
 				NET_ASSERT( m_serverPeer );
 				NET_ASSERT( event.packet->dataLength > 0 );
 				NET_ASSERT( event.packet->data );
-				if (event.packet)
+				if (m_waitingForConnect)
 				{
+					NET_LOG("net_packet_client: (stage2) connected to " << ipToString(event.peer->address.host) << ":" << event.peer->address.port << ".");
+					m_waitingForConnect = false;
+					this->fireCallback_Started();
+				}
+				else if (event.packet)
+				{
 					this->fireCallback_PacketReceived(0,event.packet->data,event.packet->dataLength,ChannelId(event.channelID));
 				}
 				{
@@ -188,11 +207,11 @@
 	}
 	void EnetClientPacketConnection::send( const void* dataPtr, const size_t dataSize, const net::SendOptions& opt )
 	{
-		this->sendBroadcast( dataPtr, dataSize, opt.reliability, opt.ordering, opt.channelId );
+		this->sendBroadcast( dataPtr, dataSize, opt.getReliability(), opt.getOrdering(), opt.getChannel() );
 	}
 	void EnetClientPacketConnection::send(const PeerId, const void* dataPtr, const size_t dataSize, const SendOptions& opt )
 	{
-		this->sendBroadcast( dataPtr, dataSize, opt.reliability, opt.ordering, opt.channelId );
+		this->sendBroadcast( dataPtr, dataSize, opt.getReliability(), opt.getOrdering(), opt.getChannel() );
 	}
 	void EnetClientPacketConnection::sendTo(const PeerId clientId, const void* dataPtr, const size_t dataSize, const Reliability rel, const Ordering ord, const ChannelId channel)
 	{

Modified: trunk/yake/src/yake/net/detail/netEnetServerPacketConnection.cpp
===================================================================
--- trunk/yake/src/yake/net/detail/netEnetServerPacketConnection.cpp	2006-06-21 19:00:39 UTC (rev 1361)
+++ trunk/yake/src/yake/net/detail/netEnetServerPacketConnection.cpp	2006-06-21 20:57:41 UTC (rev 1362)
@@ -126,7 +126,7 @@
 						boost::mutex::scoped_lock enetLock(getEnetMtx());
 						// try to gracefully disconnect clients
 						for (size_t i=0; i<m_host->peerCount; ++i)
-							enet_peer_disconnect( &m_host->peers[i] );
+							enet_peer_disconnect( &m_host->peers[i], 0 /*@todo data*/ );
 					}
 					Timer timer;
 					timer.start();
@@ -174,7 +174,7 @@
 		// disconnect enet client
 		{
 			boost::mutex::scoped_lock enetLock(getEnetMtx());
-			enet_peer_disconnect( itFindClient->second->peer );
+			enet_peer_disconnect( itFindClient->second->peer, 0 /*@todo data*/ );
 		}
 	}
 	EnetServerPacketConnection::ClientState EnetServerPacketConnection::getClientState(ENetPeer* peer) const
@@ -218,7 +218,7 @@
 			switch(event.type)
 			{
 			case ENET_EVENT_TYPE_CONNECT:
-				NET_LOG("net_packet_server: new client connected.");
+				NET_LOG("net_packet_server: new client attempts to connect.");
 				NET_ASSERT( event.peer );
 				if (event.peer && state != S_STOPPING)
 				{
@@ -235,12 +235,12 @@
 						enet_peer_reset( event.peer ); // hard!
 					}
 
-					PeerId peerId = 0xffffffff;
+					PeerId peerId = PEERID_BROADCAST;
 					{
 						boost::mutex::scoped_lock lockClients(m_clientsMtx);
 
 						Client* c = new Client();
-						c->state = CS_CONNECTED;
+						c->state = CS_CONNECTING;
 						c->peer = event.peer;
 						c->id = m_nextPeerId++;
 						peerId = c->id;
@@ -251,40 +251,56 @@
 						m_id2client.insert( std::make_pair( c->id, c ) );
 					}
 
-					fireCallback_ClientConnected( peerId, Address(host,event.peer->address.port) );
+					const uint8 tmp = 0x7F;
+					this->send(peerId,&tmp,1,SendOptions().reliability(R_RELIABLE));
 				}
 				break;
 			case ENET_EVENT_TYPE_RECEIVE:
 				NET_ASSERT( event.packet );
 				NET_ASSERT( event.peer );
 				NET_ASSERT( event.peer->data );
-				if (getClientState( event.peer ) == CS_CONNECTED
-					&& state != S_STOPPING)
 				{
-					// create packet object
-					NET_ASSERT( event.packet->dataLength > 0 );
-					NET_ASSERT( event.packet->data );
-
-					// get "id"
-					PeerId peerId = 0xffffffff;
+					const ClientState cs = getClientState( event.peer );
+					if (cs == CS_CONNECTING)
 					{
+						const std::string host = ipToStringCached( event.peer->address.host );
+						NET_LOG("net_packet_server: client finished connecting: '" << host << ":" << event.peer->address.port << "'.");
 						boost::mutex::scoped_lock lockClients(m_clientsMtx);
-						peerId = (reinterpret_cast<Client*>(event.peer->data))->id;
+						PeerToClientMap::iterator it = m_clients.find(event.peer);
+						NET_ASSERT( it != m_clients.end() );
+						NET_ASSERT( it->second );
+						Client* c = it->second;
+						c->state = CS_CONNECTED;
+						fireCallback_ClientConnected( c->id, Address(host,event.peer->address.port) );
+						// throw away the packet. => don't inform callbacks.
 					}
+					else if (cs == CS_CONNECTED && state != S_STOPPING)
+					{
+						// create packet object
+						NET_ASSERT( event.packet->dataLength > 0 );
+						NET_ASSERT( event.packet->data );
 
-					fireCallback_PacketReceived(peerId,event.packet->data,event.packet->dataLength,event.channelID);
+						// get "id"
+						PeerId peerId = PEERID_BROADCAST;
+						{
+							boost::mutex::scoped_lock lockClients(m_clientsMtx);
+							peerId = (reinterpret_cast<Client*>(event.peer->data))->id;
+						}
+
+						fireCallback_PacketReceived(peerId,event.packet->data,event.packet->dataLength,event.channelID);
+					}
+					{
+						// destroy enet packet
+						boost::mutex::scoped_lock enetLock(getEnetMtx());
+						enet_packet_destroy( event.packet );
+					}
 				}
-				{
-					// destroy enet packet
-					boost::mutex::scoped_lock enetLock(getEnetMtx());
-					enet_packet_destroy( event.packet );
-				}
 				break;
 			case ENET_EVENT_TYPE_DISCONNECT:
 				{
 					NET_ASSERT( event.peer );
 					uint32 host = event.peer ? event.peer->address.host : 0;
-					PeerId peerId = 0xffffffff;
+					PeerId peerId = PEERID_BROADCAST;
 					if (event.peer)
 					{
 						boost::mutex::scoped_lock lockClients(m_clientsMtx);
@@ -313,15 +329,16 @@
 	}
 	void EnetServerPacketConnection::send( const void* dataPtr, const size_t dataSize, const net::SendOptions& opt )
 	{
-		if (opt.peerId != 0xffffffff)
-			this->sendTo( opt.peerId, dataPtr, dataSize, opt.reliability, opt.ordering, opt.channelId );
+		const PeerId peerId = opt.getPeerId();
+		if (peerId != PEERID_BROADCAST)
+			this->sendTo( peerId, dataPtr, dataSize, opt.getReliability(), opt.getOrdering(), opt.getChannel() );
 		else
-			this->sendBroadcast( dataPtr, dataSize, opt.reliability, opt.ordering, opt.channelId );
+			this->sendBroadcast( dataPtr, dataSize, opt.getReliability(), opt.getOrdering(), opt.getChannel() );
 	}
 	void EnetServerPacketConnection::send(const PeerId peerId, const void* dataPtr, const size_t dataSize, const SendOptions& opt )
 	{
 		SendOptions options = opt;
-		options.setPeerId( peerId );
+		options.peerId( peerId );
 		send( dataPtr, dataSize, options );
 	}
 	void EnetServerPacketConnection::sendTo(const PeerId clientId, const void* dataPtr, const size_t dataSize, const Reliability rel, const Ordering, const ChannelId channel)

Modified: trunk/yake/src/yake/net/detail/netEventConnection.cpp
===================================================================
--- trunk/yake/src/yake/net/detail/netEventConnection.cpp	2006-06-21 19:00:39 UTC (rev 1361)
+++ trunk/yake/src/yake/net/detail/netEventConnection.cpp	2006-06-21 20:57:41 UTC (rev 1362)
@@ -133,9 +133,7 @@
 	}
 	void EventConnection::sendEvent(const PeerId peerId, const NetEvent& evt, const SendOptions& opt)
 	{
-		SendOptions options = opt;
-		options.setPeerId(peerId);
-		this->sendEvent( evt, options );
+		this->sendEvent( evt, SendOptions(opt).peerId(peerId) );
 	}
 	void EventConnection::sendEvent(const NetEvent& evt, const SendOptions& opt)
 	{

Modified: trunk/yake/yake/net/detail/netEnetClientPacketConnection.h
===================================================================
--- trunk/yake/yake/net/detail/netEnetClientPacketConnection.h	2006-06-21 19:00:39 UTC (rev 1361)
+++ trunk/yake/yake/net/detail/netEnetClientPacketConnection.h	2006-06-21 20:57:41 UTC (rev 1362)
@@ -11,7 +11,7 @@
 		EnetClientPacketConnection();
 		virtual ~EnetClientPacketConnection();
 
-		virtual void connect( const Address& );
+		virtual void connect( const Address&, const bool doBlock, const uint32 timeOut );
 		virtual void disconnect();
 
 		virtual void send(const void*, const size_t, const SendOptions& opt = SendOptions());

Modified: trunk/yake/yake/net/detail/netEnetServerPacketConnection.h
===================================================================
--- trunk/yake/yake/net/detail/netEnetServerPacketConnection.h	2006-06-21 19:00:39 UTC (rev 1361)
+++ trunk/yake/yake/net/detail/netEnetServerPacketConnection.h	2006-06-21 20:57:41 UTC (rev 1362)
@@ -16,6 +16,19 @@
 
 		virtual void setAllowedClientIps(const std::vector<std::string>&);
 
+		virtual size_t getNumConnectedClients() const
+		{
+			boost::mutex::scoped_lock lockClients(m_clientsMtx);
+			PeerToClientMap::const_iterator itEnd = m_clients.end();
+			size_t count = 0;
+			for (PeerToClientMap::const_iterator it = m_clients.begin(); it != itEnd; ++it)
+			{
+				if (it->second->state == CS_CONNECTED)
+					++count;
+			}
+			return count;
+		}
+
 		virtual void disconnect( const PeerId client );
 
 		virtual void send(const void*, const size_t, const SendOptions& opt = SendOptions());
@@ -112,6 +125,7 @@
 
 		enum ClientState
 		{
+			CS_CONNECTING,
 			CS_CONNECTED,
 			CS_DISCONNECTING,
 			CS_DEAD
@@ -123,6 +137,13 @@
 			PeerId		id;
 			uint32		host;
 			//Address		addr;
+
+			/*
+			void onConnectStage1(...);
+			void onConnectStage2(...);
+			void onConnected(...);
+			void onDisconnected();
+			*/
 		};
 		typedef std::map<ENetPeer*,Client*> PeerToClientMap;
 		PeerToClientMap			m_clients; // access only via update()

Modified: trunk/yake/yake/net/netCommon.h
===================================================================
--- trunk/yake/yake/net/netCommon.h	2006-06-21 19:00:39 UTC (rev 1361)
+++ trunk/yake/yake/net/netCommon.h	2006-06-21 20:57:41 UTC (rev 1362)
@@ -5,20 +5,31 @@
 
 namespace net {
 
+	/** Used to define packet transport channels. */
 	typedef uint8 ChannelId;
+
+	/** Used to identify network peers. */
 	typedef uint32 PeerId;
+	const PeerId PEERID_BROADCAST = 0xffffffff;
 
+	/** Specifies the reliability method a packet will be transferred with. */
 	enum Reliability
 	{
 		R_RELIABLE = 0,
 		R_UNRELIABLE
 	};
+	/** Specifies the ordering method a packet will be transferred with. */
 	enum Ordering
 	{
 		O_ORDERED = 0,
 		O_UNORDERED
 	};
 
+	/** Represents a specifically configured set of options.
+		It used for specifying additional information and hints
+		when sending data/packets.
+		Usage example: conn.send(buf.data(),buf.size(), SendOptions().setOrdering(O_ORDERED).setReliability(R_RELIABLED));
+	*/
 	struct NET_API SendOptions
 	{
 		SendOptions();
@@ -26,19 +37,30 @@
 		~SendOptions();
 		SendOptions& operator=(const SendOptions&);
 
-		SendOptions& setPeerId(const PeerId);
-		SendOptions& setReliability(const Reliability);
-		SendOptions& setOrdering(const Ordering);
-		SendOptions& setChannel(const ChannelId);
+		/** Set the target peer id.
+			@Remarks This setting is ignored by broadcast functions!
+		*/
+		SendOptions& peerId(const PeerId);
+		SendOptions& reliability(const Reliability);
+		SendOptions& ordering(const Ordering);
+		SendOptions& channel(const ChannelId);
 
-		PeerId			peerId;
-		Reliability		reliability;
-		Ordering		ordering;
-		ChannelId		channelId;
+		PeerId getPeerId() const;
+		Reliability getReliability() const;
+		Ordering getOrdering() const;
+		ChannelId getChannel() const;
+	private:
+		PeerId			peerId_;
+		Reliability		reliability_;
+		Ordering		ordering_;
+		ChannelId		channelId_;
 	};
 
+	/** Represents a network address (IP + port pair).
+	*/
 	struct NET_API Address
 	{
+		/** Initializes the IP with "127.0.0.1". */
 		Address(const uint16 port);
 		Address(const std::string& ip = std::string("127.0.0.1"), const uint16 port = 0);
 		Address(const Address&);
@@ -54,12 +76,20 @@
 		uint16			port_;
 	};
 
+	/** Converts the 32-bit integer representation of an IPv4 IP
+		to a string representation.
+	*/
 	NET_API std::string ipToString(const uint32);
 
 	namespace native {
+		/** Sleeps the active thread for a certain number of milliseconds.
+			This also yields the thread! (For example, a Win32 implementation
+			may use ::Sleep().)
+		*/
 		NET_API void sleep(const uint32 ms);
 	} // namespace native
 
+	/** Represents an exception in the network component. */
 	struct NET_API Exception : public std::exception
 	{
 		Exception(const std::string& msg, const char* file = 0, const int line = 0);
@@ -69,6 +99,8 @@
 		std::string	msg_;
 	};
 
+	/** Cross-platform timer interface.
+	*/
 	class NET_API Timer
 	{
 	public:

Modified: trunk/yake/yake/net/netPacket.h
===================================================================
--- trunk/yake/yake/net/netPacket.h	2006-06-21 19:00:39 UTC (rev 1361)
+++ trunk/yake/yake/net/netPacket.h	2006-06-21 20:57:41 UTC (rev 1362)
@@ -5,6 +5,8 @@
 
 	typedef std::vector<uint8> byte_chunk;
 
+	/** Interface for packet sending objects.
+	*/
 	class NET_API IPacketSender
 	{
 	public:
@@ -31,6 +33,8 @@
 	};
 #pragma warning(pop)
 
+	/** Interface for packet receiving objects.
+	*/
 	class NET_API IPacketReceiver
 	{
 	public:
@@ -40,6 +44,8 @@
 		virtual CallbackConnection addPacketReceivedCallback( const OnPacketReceivedFn&) = 0;
 	};
 
+	/** Interface for packet sending and receiving objects (connections).
+	*/
 	class NET_API IPacketConnection : public IPacketSender, public IPacketReceiver
 	{
 	public:
@@ -48,17 +54,23 @@
 		virtual void addStartedCallback(const OnStartedFn&) = 0;
 	};
 
+	/** A packet connection interface specific to packet servers.
+		Packet servers manage zero or more connected clients.
+		@see IClientPacketConnection
+	*/
 	class NET_API IServerPacketConnection : public IPacketConnection
 	{
 	public:
 
-		/*** May throw exception. */
+		/*** @Remarks May throw exception. */
 		virtual void start( const Address&, const size_t ) = 0;
 		virtual void stop() = 0;
 
 		virtual void setAllowedClientIps(const std::vector<std::string>&) = 0;
 		//virtual void setAllowedClientIps(const std::vector<uint32>&) = 0;
 
+		virtual size_t getNumConnectedClients() const = 0;
+
 		virtual void disconnect( const PeerId ) = 0;
 
 		typedef boost::function<void(const PeerId, const Address&)> OnClientConnectedFn;
@@ -68,15 +80,21 @@
 		virtual void addClientConnectedCallback(const OnClientConnectedFn&) = 0;
 		virtual void addClientDisconnectedCallback(const OnClientDisconnectedFn&) = 0;
 	};
+	/** A packet connection interface specific to packet clients.
+		Packet clients manage a single connection to a packet server.
+		@see IClientPacketConnection
+	*/
 	class NET_API IClientPacketConnection : public IPacketConnection
 	{
 	public:
-		virtual void connect( const Address& ) = 0;
+		virtual void connect( const Address&, const bool doBlock = false, const uint32 timeOut = 2000 ) = 0;
 		virtual void disconnect() = 0;
 
 		virtual void addTimeOutCallback(const OnTimeOutFn&) = 0;
 	};
+	/** @Remarks User code is responsible for destroying the connection objects!*/
 	NET_API IServerPacketConnection* createServerPacketConnection();
+	/** @Remarks User code is responsible for destroying the connection objects!*/
 	NET_API IClientPacketConnection* createClientPacketConnection();
 
 } // namespace net

Modified: trunk/yake/yake/samples/net/roclient/pch.h
===================================================================
--- trunk/yake/yake/samples/net/roclient/pch.h	2006-06-21 19:00:39 UTC (rev 1361)
+++ trunk/yake/yake/samples/net/roclient/pch.h	2006-06-21 20:57:41 UTC (rev 1362)
@@ -4,4 +4,4 @@
 #include <boost/function.hpp>
 #include <boost/bind.hpp>
 
-#endif
\ No newline at end of file
+#endif



From codeandroid at berlios.de  Thu Jun 22 00:06:03 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Thu, 22 Jun 2006 00:06:03 +0200
Subject: [Yake-svn] r1363 - in trunk/yake: src/yake/net/detail src/yake/samples/net src/yake/samples/net/packet src/yake/samples/net/roclient src/yake/samples/net/roserver yake/net yake/net/detail yake/samples/net yake/samples/net/packet yake/samples/net/roclient yake/samples/net/roserver
Message-ID: <200606212206.k5LM63Vt014304@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-22 00:06:02 +0200 (Thu, 22 Jun 2006)
New Revision: 1363

Added:
   trunk/yake/src/yake/samples/net/packet/
   trunk/yake/src/yake/samples/net/packet/demo.cpp
   trunk/yake/src/yake/samples/net/packet/pch.cpp
   trunk/yake/src/yake/samples/net/roclient/ROClient.cpp
   trunk/yake/src/yake/samples/net/roserver/ROServer.cpp
   trunk/yake/yake/samples/net/packet/
   trunk/yake/yake/samples/net/packet/pch.h
   trunk/yake/yake/samples/net/roclient/ROClient.h
   trunk/yake/yake/samples/net/roserver/ROServer.h
Modified:
   trunk/yake/src/yake/net/detail/netEnetClientPacketConnection.cpp
   trunk/yake/src/yake/net/detail/netEnetServerPacketConnection.cpp
   trunk/yake/src/yake/net/detail/netEventConnection.cpp
   trunk/yake/src/yake/net/detail/netInternal.cpp
   trunk/yake/src/yake/samples/net/roclient/demo.cpp
   trunk/yake/src/yake/samples/net/roserver/demo.cpp
   trunk/yake/yake/net/detail/netEnetClientPacketConnection.h
   trunk/yake/yake/net/detail/netEnetServerPacketConnection.h
   trunk/yake/yake/net/detail/netInternal.h
   trunk/yake/yake/net/net.h
Log:
added sampleNetPacket,
refactored yake::net

Modified: trunk/yake/src/yake/net/detail/netEnetClientPacketConnection.cpp
===================================================================
--- trunk/yake/src/yake/net/detail/netEnetClientPacketConnection.cpp	2006-06-21 20:57:41 UTC (rev 1362)
+++ trunk/yake/src/yake/net/detail/netEnetClientPacketConnection.cpp	2006-06-21 22:06:02 UTC (rev 1363)
@@ -32,7 +32,7 @@
 	}
 	CallbackConnection EnetClientPacketConnection::addPacketReceivedCallback(const OnPacketReceivedFn& fn)
 	{
-		boost::mutex::scoped_lock lck(packetReceivedFnListMtx_);
+		//boost::mutex::scoped_lock lck(packetReceivedFnListMtx_);
 		packetReceivedFnList_.insert( std::make_pair(++lastPacketReceivedCbHandle_, fn) );
 		return CallbackConnection(lastPacketReceivedCbHandle_,boost::bind(&EnetClientPacketConnection::disconnectPacketReceivedCallback,this,_1));
 	}
@@ -56,7 +56,7 @@
 		}
 
 		{
-			boost::mutex::scoped_lock enetLock(getEnetMtx());
+			//boost::mutex::scoped_lock enetLock(getEnetMtx());
 			m_host = enet_host_create (			0 /* create a client host */,
 												1 /* only allow 1 outgoing connection */,
 										57600 / 8 /* 56K modem with 56 Kbps downstream bandwidth */,
@@ -94,7 +94,10 @@
 		{
 			//@todo timeout
 			while (m_waitingForConnect && !m_ready)
+			{
 				net::native::sleep(10);
+				net::update();
+			}
 		}
 	}
 	void EnetClientPacketConnection::disconnect()
@@ -111,18 +114,18 @@
 		{
 			if (m_serverPeer)
 			{
-				boost::mutex::scoped_lock enetLock(getEnetMtx());
+				//boost::mutex::scoped_lock enetLock(getEnetMtx());
 				enet_peer_disconnect( m_serverPeer, 0 /*@todo data*/ );
 			}
 			Timer timer;
 			timer.start();
 			while (timer.getTime() < 1)
 			{
-				this->update();
-				::Sleep(10);
+				net::update();
+				net::native::sleep(10);
 			}
 			{
-				boost::mutex::scoped_lock enetLock(getEnetMtx());
+				//boost::mutex::scoped_lock enetLock(getEnetMtx());
 				enet_peer_reset( m_peer );
 				enet_host_destroy( m_host );
 				m_host = 0;
@@ -141,7 +144,7 @@
 		ENetEvent event;
 		int ret = 0;
 		{
-			boost::mutex::scoped_lock enetLock(getEnetMtx());
+			//boost::mutex::scoped_lock enetLock(getEnetMtx());
 			ret = enet_host_service(m_host, &event, 5);
 		}
 		if (ret == 0) // no events
@@ -190,7 +193,7 @@
 					this->fireCallback_PacketReceived(0,event.packet->data,event.packet->dataLength,ChannelId(event.channelID));
 				}
 				{
-					boost::mutex::scoped_lock enetLock(getEnetMtx());
+					//boost::mutex::scoped_lock enetLock(getEnetMtx());
 					enet_packet_destroy( event.packet );
 				}
 				break;
@@ -226,7 +229,7 @@
 		NET_ASSERT( dataPtr );
 		NET_ASSERT( m_serverPeer );
 		{
-			boost::mutex::scoped_lock enetLock(getEnetMtx());
+			//boost::mutex::scoped_lock enetLock(getEnetMtx());
 			ENetPacket* packet = enet_packet_create( 
 									dataPtr, dataSize,
 									//rPacket.m_data, 

Modified: trunk/yake/src/yake/net/detail/netEnetServerPacketConnection.cpp
===================================================================
--- trunk/yake/src/yake/net/detail/netEnetServerPacketConnection.cpp	2006-06-21 20:57:41 UTC (rev 1362)
+++ trunk/yake/src/yake/net/detail/netEnetServerPacketConnection.cpp	2006-06-21 22:06:02 UTC (rev 1363)
@@ -34,18 +34,18 @@
 	}
 	CallbackConnection EnetServerPacketConnection::addPacketReceivedCallback( const OnPacketReceivedFn& fn)
 	{
-		boost::mutex::scoped_lock lck(packetReceivedFnListMtx_);
+		//boost::mutex::scoped_lock lck(packetReceivedFnListMtx_);
 		packetReceivedFnList_.insert( std::make_pair(++lastPacketReceivedCbHandle_,fn) );
 		return CallbackConnection(lastPacketReceivedCbHandle_,boost::bind(&EnetServerPacketConnection::disconnectPacketReceivedCallback,this,_1));
 	}
 	void EnetServerPacketConnection::setAllowedClientIps(const std::vector<std::string> &ips)
 	{
-		boost::mutex::scoped_lock ipsLock(m_ipListMtx);
+		//boost::mutex::scoped_lock ipsLock(m_ipListMtx);
 		m_ipWhiteList = ips;
 	}
 	bool EnetServerPacketConnection::isIpAllowed( const std::string& ip )
 	{
-		boost::mutex::scoped_lock ipsLock(m_ipListMtx);
+		//boost::mutex::scoped_lock ipsLock(m_ipListMtx);
 		if (m_ipWhiteList.empty() && m_ipBlackList.empty())
 			return true;
 		if (contains(m_ipBlackList,ip))
@@ -85,7 +85,7 @@
 		}
 
 		{
-			boost::mutex::scoped_lock enetLock(getEnetMtx());
+			//boost::mutex::scoped_lock enetLock(getEnetMtx());
 			m_address.port = addr.port();
 			m_host = enet_host_create( &m_address,
 										maxClients, // up to 'maxClients' clients
@@ -100,6 +100,8 @@
 		}
 
 		m_state.set(S_RUNNING);
+		m_timer.start();
+		m_timeOfLastUpdate = m_timer.getTime();
 		this->fireCallback_Started();
 		m_id = UpdateThread::instance().add( boost::bind(&EnetServerPacketConnection::update,this) );
 	}
@@ -123,7 +125,7 @@
 				if (m_host->peerCount > 0)
 				{
 					{
-						boost::mutex::scoped_lock enetLock(getEnetMtx());
+						//boost::mutex::scoped_lock enetLock(getEnetMtx());
 						// try to gracefully disconnect clients
 						for (size_t i=0; i<m_host->peerCount; ++i)
 							enet_peer_disconnect( &m_host->peers[i], 0 /*@todo data*/ );
@@ -132,19 +134,19 @@
 					timer.start();
 					while (timer.getTime() < 2) // wait 2 seconds for acknowledgement
 					{
-						::Sleep(10);
-						this->update();
+						net::update();
+						net::native::sleep(10);
 					}
 					// forcefully disconnect remaining clients
 					if (m_host->peerCount > 0)
 					{
-						boost::mutex::scoped_lock enetLock(getEnetMtx());
+						//boost::mutex::scoped_lock enetLock(getEnetMtx());
 						for (size_t i=0; i<m_host->peerCount; ++i)
 							enet_peer_reset( &m_host->peers[i] );
 					}
 				}
 				{
-					boost::mutex::scoped_lock enetLock(getEnetMtx());
+					//boost::mutex::scoped_lock enetLock(getEnetMtx());
 					enet_host_destroy( m_host );
 					m_host = 0;
 				}
@@ -153,7 +155,7 @@
 		m_ip2string.clear();
 		m_ipWhiteList.clear();
 		{
-			boost::mutex::scoped_lock lockClients(m_clientsMtx);
+			//boost::mutex::scoped_lock lockClients(m_clientsMtx);
 			for (PeerToClientMap::iterator it = m_clients.begin(); it != m_clients.end(); ++it)
 				delete it->second;
 			m_clients.clear();
@@ -161,10 +163,12 @@
 		}
 		//m_events.clear();
 		m_state.set(S_DEAD);
+		m_timer.stop();
+		m_timer.reset();
 	}
 	void EnetServerPacketConnection::disconnect( const PeerId client )
 	{
-		boost::mutex::scoped_lock lockClients(m_clientsMtx);
+		//boost::mutex::scoped_lock lockClients(m_clientsMtx);
 		IdToClientMap::iterator itFindClient = m_id2client.find( client );
 		NET_ASSERT( itFindClient != m_id2client.end() );
 		if (itFindClient == m_id2client.end())
@@ -173,7 +177,7 @@
 		itFindClient->second->state = CS_DISCONNECTING;
 		// disconnect enet client
 		{
-			boost::mutex::scoped_lock enetLock(getEnetMtx());
+			//boost::mutex::scoped_lock enetLock(getEnetMtx());
 			enet_peer_disconnect( itFindClient->second->peer, 0 /*@todo data*/ );
 		}
 	}
@@ -182,7 +186,7 @@
 		if (peer == 0)
 			return CS_DEAD;
 
-		boost::mutex::scoped_lock lockClients(m_clientsMtx);
+		//boost::mutex::scoped_lock lockClients(m_clientsMtx);
 		PeerToClientMap::const_iterator it = m_clients.find( peer );
 		if (it == m_clients.end())
 			return CS_DEAD;
@@ -204,11 +208,34 @@
 		if (state != S_RUNNING && state != S_STOPPING)
 			return;
 
+		// timeouts
+		{
+			const double currT = m_timer.getTime();
+			const double deltaT = max(currT - m_timeOfLastUpdate, 0.0001);
+			NET_ASSERT( deltaT > 0. )(deltaT);
+			PeerToClientMap::iterator itEnd = m_clients.end();
+			for (PeerToClientMap::iterator it = m_clients.begin(); it != itEnd; ++it)
+			{
+				Client* c = it->second;
+				NET_ASSERT(c);
+				if (c->state == CS_CONNECTING) // connection attempts
+				{
+					c->timeLeft_ -= deltaT;
+					if (c->timeLeft_ < 0.)
+					{
+						NET_LOG("net_packet_server: client connection attempt timed out.");
+						this->disconnect( c->id );
+					}
+				}
+			}
+			m_timeOfLastUpdate = currT;
+		}
+
 		// packet handling
 		ENetEvent event;
 		int ret = 0;
 		{
-			boost::mutex::scoped_lock enetLock(getEnetMtx());
+			//boost::mutex::scoped_lock enetLock(getEnetMtx());
 			ret = enet_host_service(m_host, &event, 5);
 		}
 		if (ret == 0) // no events
@@ -230,16 +257,17 @@
 					if (!isIpAllowed(host))
 					{
 						NET_LOG("net_packet_server: new client '" << host << "' is NOT ALLOWED to connect. disconnecting.");
-						boost::mutex::scoped_lock enetLock(getEnetMtx());
+						//boost::mutex::scoped_lock enetLock(getEnetMtx());
 						//enet_disconnect_peer( event.peer ); // gracefully
 						enet_peer_reset( event.peer ); // hard!
 					}
 
 					PeerId peerId = PEERID_BROADCAST;
 					{
-						boost::mutex::scoped_lock lockClients(m_clientsMtx);
+						//boost::mutex::scoped_lock lockClients(m_clientsMtx);
 
 						Client* c = new Client();
+						c->timeLeft_ = 5.; // 5 seconds to complete connection.
 						c->state = CS_CONNECTING;
 						c->peer = event.peer;
 						c->id = m_nextPeerId++;
@@ -265,7 +293,7 @@
 					{
 						const std::string host = ipToStringCached( event.peer->address.host );
 						NET_LOG("net_packet_server: client finished connecting: '" << host << ":" << event.peer->address.port << "'.");
-						boost::mutex::scoped_lock lockClients(m_clientsMtx);
+						//boost::mutex::scoped_lock lockClients(m_clientsMtx);
 						PeerToClientMap::iterator it = m_clients.find(event.peer);
 						NET_ASSERT( it != m_clients.end() );
 						NET_ASSERT( it->second );
@@ -283,7 +311,7 @@
 						// get "id"
 						PeerId peerId = PEERID_BROADCAST;
 						{
-							boost::mutex::scoped_lock lockClients(m_clientsMtx);
+							//boost::mutex::scoped_lock lockClients(m_clientsMtx);
 							peerId = (reinterpret_cast<Client*>(event.peer->data))->id;
 						}
 
@@ -291,7 +319,7 @@
 					}
 					{
 						// destroy enet packet
-						boost::mutex::scoped_lock enetLock(getEnetMtx());
+						//boost::mutex::scoped_lock enetLock(getEnetMtx());
 						enet_packet_destroy( event.packet );
 					}
 				}
@@ -303,7 +331,7 @@
 					PeerId peerId = PEERID_BROADCAST;
 					if (event.peer)
 					{
-						boost::mutex::scoped_lock lockClients(m_clientsMtx);
+						//boost::mutex::scoped_lock lockClients(m_clientsMtx);
 						Client* c = reinterpret_cast<Client*>(event.peer->data);
 						if (c)
 							peerId = c->id;
@@ -351,12 +379,12 @@
 				return;
 		}
 		{
-			boost::mutex::scoped_lock enetLock(getEnetMtx());
+			//boost::mutex::scoped_lock enetLock(getEnetMtx());
 			ENetPacket* packet = enet_packet_create(
 														dataPtr, dataSize,
 														(rel == R_RELIABLE) ? ENET_PACKET_FLAG_RELIABLE : 0 );
 			// send
-			boost::mutex::scoped_lock clientsLock(m_clientsMtx);
+			//boost::mutex::scoped_lock clientsLock(m_clientsMtx);
 			IdToClientMap::const_iterator it = m_id2client.find( clientId );
 			NET_ASSERT( it != m_id2client.end() );
 			enet_peer_send( it->second->peer, channel, packet );
@@ -372,7 +400,7 @@
 				return;
 		}
 		{
-			boost::mutex::scoped_lock enetLock(getEnetMtx());
+			//boost::mutex::scoped_lock enetLock(getEnetMtx());
 			ENetPacket* packet = enet_packet_create(
 														dataPtr, dataSize,
 														(rel == R_RELIABLE) ? ENET_PACKET_FLAG_RELIABLE : 0 );

Modified: trunk/yake/src/yake/net/detail/netEventConnection.cpp
===================================================================
--- trunk/yake/src/yake/net/detail/netEventConnection.cpp	2006-06-21 20:57:41 UTC (rev 1362)
+++ trunk/yake/src/yake/net/detail/netEventConnection.cpp	2006-06-21 22:06:02 UTC (rev 1363)
@@ -105,8 +105,6 @@
 	void EventConnection::stop()
 	{
 		boost::mutex::scoped_lock lck(startedMtx_);
-		NET_ASSERT( started_ );
-		NET_ASSERT( conn_ );
 		if (conn_)
 		{
 			//@todo fixme unsubscribe from packet connection 'conn_'

Modified: trunk/yake/src/yake/net/detail/netInternal.cpp
===================================================================
--- trunk/yake/src/yake/net/detail/netInternal.cpp	2006-06-21 20:57:41 UTC (rev 1362)
+++ trunk/yake/src/yake/net/detail/netInternal.cpp	2006-06-21 22:06:02 UTC (rev 1363)
@@ -3,6 +3,10 @@
 #include <yake/net/detail/netInternal.h>
 
 namespace net {
+	void update()
+	{
+		impl::UpdateThread::instance().__update__();
+	}
 namespace impl {
 
 	//--------------------------------------------------------------------------
@@ -21,7 +25,10 @@
 		{
 			instance_->requestQuit();
 			while (!instance_->dead())
+			{
 				native::sleep(10);
+				net::update();
+			}
 			delete instance_;
 			instance_ = 0;
 		}
@@ -33,7 +40,7 @@
 	}
 	UpdateThread::UpdateThread() : nextId_(1), thread_(0), quitRequested_(false), dead_(false)
 	{
-		thread_ = new boost::thread( boost::bind(&UpdateThread::callFns,this) );
+		//thread_ = new boost::thread( boost::bind(&UpdateThread::callFns,this) );
 	}
 	UpdateThread::~UpdateThread()
 	{
@@ -47,24 +54,22 @@
 	}
 	void UpdateThread::requestQuit()
 	{
-		boost::mutex::scoped_lock lock(mtx_);
 		quitRequested_ = true;
 	}
 	bool UpdateThread::dead() const
 	{
-		boost::mutex::scoped_lock lock(deadMtx_);
 		return dead_;
 	}
 	void UpdateThread::callFns()
 	{
-		while (true)
+		//while (true)
 		{
 			{
-				boost::mutex::scoped_lock lock(mtx_);
+				//boost::mutex::scoped_lock lock(mtx_);
 
 				if (quitRequested_)
 				{
-					boost::mutex::scoped_lock lock(deadMtx_);
+					//boost::mutex::scoped_lock lock(deadMtx_);
 					fns_.clear();
 					dead_ = true;
 					return;
@@ -80,14 +85,14 @@
 	}
 	uint32 UpdateThread::add( const UpdateFn& fn )
 	{
-		boost::mutex::scoped_lock lock(mtx_);
+		//boost::mutex::scoped_lock lock(mtx_);
 		std::cout << "UpdateThread::add()\n";
 		fns_[ nextId_++ ] = fn;
 		return nextId_-1;
 	}
 	void UpdateThread::remove( const uint32 id )
 	{
-		boost::mutex::scoped_lock lock(mtx_);
+		//boost::mutex::scoped_lock lock(mtx_);
 		std::cout << "UpdateThread::remove()\n";
 		UpdateFnMap::iterator it = fns_.find( id );
 		if (it != fns_.end())
@@ -106,11 +111,13 @@
 	//	}
 	//}
 
+	/*
 	boost::mutex& getEnetMtx()
 	{
 		static boost::mutex mtx;
 		return mtx;
 	}
+	*/
 
 } // namespace impl
 } // namespace net

Added: trunk/yake/src/yake/samples/net/packet/demo.cpp
===================================================================
--- trunk/yake/src/yake/samples/net/packet/demo.cpp	2006-06-21 20:57:41 UTC (rev 1362)
+++ trunk/yake/src/yake/samples/net/packet/demo.cpp	2006-06-21 22:06:02 UTC (rev 1363)
@@ -0,0 +1,152 @@
+#include <yake/samples/net/packet/pch.h>
+#include <yake/net/net.h>
+#include <yake/base/yake.h> // for YAKE_ASSERT etc
+#include <yake/samples/net/common/common.h>
+
+/** A simple server class for managing packet connections.
+*/
+struct server
+{
+private:
+	server& operator=(const server&);
+	server(const server&);
+public:
+	server(const net::Address&, const net::uint32 maxClients);
+	~server();
+
+	bool start();
+	void stop();
+
+	void broadcastHello();
+	size_t numConnectedClients() const
+	{
+		return conn_ ? conn_->getNumConnectedClients() : 0;
+	}
+private:
+	void onStarted();
+private:
+	safe_var<bool>					started_;
+	net::Address					addr_;
+	net::uint32						maxClients_;
+	net::IServerPacketConnection*	conn_;
+};
+server::server(const net::Address& addr, const net::uint32 maxClients) : 
+	addr_(addr), 
+	maxClients_(maxClients),
+	conn_(0), 
+	started_(false)
+{
+	YAKE_ASSERT( maxClients > 0 );
+}
+server::~server()
+{
+	stop();
+}
+void server::onStarted()
+{
+	started_ = true;
+}
+bool server::start()
+{
+	YAKE_ASSERT( !started_.getCopy() );
+	YAKE_ASSERT( !conn_ );
+
+	YAKE_LOG("creating server...\n");
+	conn_ = net::createServerPacketConnection();
+	YAKE_ASSERT( conn_ );
+
+	YAKE_LOG("starting server...\n");
+	started_ = false;
+	conn_->addStartedCallback(boost::bind(&server::onStarted,this));
+	try {
+		conn_->start(addr_, maxClients_);
+	} 
+	catch (net::Exception& e)
+	{
+		YAKE_LOG_ERROR( yake::String("NET Exception\n") + e.what() );
+		YAKE_SAFE_DELETE( conn_ );
+		return false;
+	}
+	while (!started_.getCopy())
+	{
+		net::native::sleep(10);
+		net::update();
+	}
+	COUTLN("server is running.");
+
+	return true;
+}
+void server::stop()
+{
+	if (!conn_)
+		return;
+	conn_->stop();
+	YAKE_SAFE_DELETE( conn_ );
+}
+void server::broadcastHello()
+{
+	YAKE_ASSERT( conn_ );
+	YAKE_ASSERT( started_.getCopy() );
+	std::string hello("hello!");
+	conn_->send( hello.c_str(), hello.size(), net::SendOptions().reliability(net::R_RELIABLE) );
+	COUTLN("server:broadcastHello() " << conn_->getNumConnectedClients() << " client(s)");
+}
+
+void client_onPacketReceived(const net::PeerId peerId, const void* data, const size_t len, const net::ChannelId channel)
+{
+	COUTLN("  client " << peerId << " packet(size=" << len << ") on channel " << channel << "\n");
+}
+
+int main(int argc, char* argv[])
+{
+	net::initialize();
+
+	// server
+	server theServer(net::Address(4000), 16);
+	if (!theServer.start())
+		return 0;
+
+	// client(s)
+	YAKE_LOG("creating clients...\n");
+	typedef std::deque<yake::SharedPtr<net::IClientPacketConnection> > ClientConnections;
+	ClientConnections clients;
+	for (size_t i=0; i<3; ++i)
+	{
+		net::IClientPacketConnection* client = net::createClientPacketConnection();
+		YAKE_ASSERT( client );
+		client->connect(net::Address(4000), false /*true=block until connection established or timeout.*/);
+		client->addPacketReceivedCallback( client_onPacketReceived );
+		clients.push_back( yake::SharedPtr<net::IClientPacketConnection>(client) );
+	}
+
+	//net::native::sleep(500); // unfortunately, this is still necessary...
+
+	// main loop
+	YAKE_LOG("waiting for key press...");
+	bool sentHello = false;
+	while (!_kbhit())
+	{
+		net::native::sleep(10);
+		net::update();
+		if (!sentHello && theServer.numConnectedClients() > 0)
+		{
+			theServer.broadcastHello();
+			sentHello = true;
+		}
+	}
+	if (_kbhit())
+		_getch();
+
+	// cleanup
+	YAKE_LOG("stopping clients...\n");
+	yake::ConstVectorIterator<ClientConnections> itClient(clients);
+	while (itClient.hasMoreElements())
+		itClient.getNext()->disconnect();
+	clients.clear();
+
+	theServer.stop();
+
+	net::shutdown();
+	return 0;
+}
+

Added: trunk/yake/src/yake/samples/net/packet/pch.cpp
===================================================================
--- trunk/yake/src/yake/samples/net/packet/pch.cpp	2006-06-21 20:57:41 UTC (rev 1362)
+++ trunk/yake/src/yake/samples/net/packet/pch.cpp	2006-06-21 22:06:02 UTC (rev 1363)
@@ -0,0 +1 @@
+#include <yake/samples/net/packet/pch.h>

Added: trunk/yake/src/yake/samples/net/roclient/ROClient.cpp
===================================================================
--- trunk/yake/src/yake/samples/net/roclient/ROClient.cpp	2006-06-21 20:57:41 UTC (rev 1362)
+++ trunk/yake/src/yake/samples/net/roclient/ROClient.cpp	2006-06-21 22:06:02 UTC (rev 1363)
@@ -0,0 +1,180 @@
+#include <yake/samples/net/roclient/pch.h>
+#include <yake/net/net.h>
+#include <yake/samples/net/common/common.h>
+#include <yake/samples/net/common/commonEvents.h>
+#include <yake/samples/net/roclient/ROClient.h>
+
+namespace ro {
+
+client::client() : timedOut_(false), conn_(false), running_(false), evtConn_(0), stage_(CS_JOINING)
+{
+}
+client::~client()
+{
+	stop();
+}
+bool client::running() const
+{
+	boost::mutex::scoped_lock lck(runningMtx_);
+	return running_;
+}
+bool client::start(const net::Address& serverAddr)
+{
+	try {
+		// create connection & register callbacks
+		conn_ = net::createClientPacketConnection();
+		assert( conn_ );
+
+		conn_->addTimeOutCallback( boost::bind(&client::onTimeOut,this) );
+		conn_->addStartedCallback( boost::bind(&client::onClientStarted,this) );
+
+		// attempt to connect to server
+		conn_->connect( serverAddr );
+
+		return true;
+	}
+	catch (const net::Exception& e)
+	{
+		COUTLN("Caught net exception: " << e.what());
+		if (conn_)
+		{
+			delete conn_;
+			conn_ = 0;
+		}
+	}
+	return false;
+}
+void client::waitForStart()
+{
+	while (!timedOut_.getCopy() && !running())
+	{
+		net::native::sleep(10);
+		net::update();
+	}
+	if (timedOut_.getCopy())
+		return;
+	// set up event connection
+	assert( conn_ );
+	assert( !evtConn_ );
+	evtConn_ = net::createEventConnection();
+	assert( evtConn_ );
+
+	evtConn_->setPolling( true );
+
+	evtConn_->registerEvent( c2sEvtJoinReq::ID, net::NetEvent::DIR_ANY,
+		c2sEvtJoinReq::create, c2sEvtJoinReq::destroy );
+	evtConn_->registerEvent( s2cEvtJoinReqReply::ID, net::NetEvent::DIR_ANY,
+		s2cEvtJoinReqReply::create, s2cEvtJoinReqReply::destroy );
+	evtConn_->registerEvent( s2cEvtClassTable::ID, net::NetEvent::DIR_ANY,
+			s2cEvtClassTable::create, s2cEvtClassTable::destroy );
+
+	evtConn_->setProcessEventCallback( boost::bind(&client::init_onProcessEvent,this,_1,_2,_3) );
+	evtConn_->setPacketConnection( conn_, net::NetEvent::DIR_ANY );
+
+	evtConn_->start();
+
+	// initiate "join" sequence
+	this->stage_ = CS_JOINING;
+
+	c2sEvtJoinReq evt;
+	evtConn_->sendEvent( evt, net::SendOptions().channel(CHANNELID_CONTROL) );
+
+#if NET_STRESS_TEST_LEVEL >= 1
+	// send a second time to test our server logic :)
+	for (size_t i=0; i<3; ++i)
+		evtConn_->sendEvent( evt, net::SendOptions().channel(CHANNELID_CONTROL) );
+#endif
+
+	evt.setId( 23 ); // invalid id!
+	evtConn_->sendEvent( evt, net::SendOptions().channel(CHANNELID_CONTROL) );
+
+	while (stage_ == CS_JOINING)
+	{
+		evtConn_->poll();
+		net::update();
+		net::native::sleep(1);
+	}
+}
+void client::step()
+{
+	if (!running())
+		return;
+
+	evtConn_->poll();
+
+	if (stage_ == CS_RUNNING)
+	{
+	}
+}
+void client::stop()
+{
+	{
+		boost::mutex::scoped_lock lck(runningMtx_);
+		running_ = false;
+	}
+	// clean up
+	if (evtConn_)
+	{
+		evtConn_->stop();
+		delete evtConn_;
+		evtConn_ = 0;
+	}
+	if (conn_)
+	{
+		conn_->disconnect();
+		delete conn_;
+		conn_ = 0;
+	}
+}
+void client::onClientStarted()
+{
+	COUTLN("client started.");
+
+	{
+		boost::mutex::scoped_lock lck(runningMtx_);
+		running_ = true;
+	}
+}
+void client::onTimeOut()
+{
+	COUTLN("client could not connect to server. destroying connection object.");
+
+	// Do NOT destroy the connection object here! It may still be inside the callback loop!
+	// We can call disconnect(), though.
+	timedOut_ = true;
+	//conn->disconnect();
+}
+void client::running_onProcessEvent(const net::PeerId, const net::NetEvent& evt, const net::ChannelId)
+{
+	COUTLN("client (running) received event (" << (int)evt.id() << ").");
+	if (evt.id() == s2cEvtClassTable::ID)
+	{
+		COUTLN("starting sim " << evt.id());
+	}
+}
+void client::init_onProcessEvent(const net::PeerId, const net::NetEvent& evt, const net::ChannelId)
+{
+	COUTLN("client (init) received event (" << (int)evt.id() << ").");
+	if (stage_ == CS_JOINING)
+	{
+		if (evt.id() == s2cEvtJoinReqReply::ID)
+		{
+			const s2cEvtJoinReqReply& reply = static_cast<const s2cEvtJoinReqReply&>( evt );
+			if (reply.accepted)
+			{
+				COUTLN("CONNECTED TO SERVER.");
+				stage_ = CS_RUNNING;
+			}
+			else
+			{
+				COUTLN("SERVER DENIED ACCESS!");
+				stage_ = CS_DEAD;
+				evtConn_->setProcessEventCallback( boost::bind(&client::init_onProcessEvent,this,_1,_2,_3) );
+			}
+		}
+	}
+}
+
+
+} // namespace ro
+

Modified: trunk/yake/src/yake/samples/net/roclient/demo.cpp
===================================================================
--- trunk/yake/src/yake/samples/net/roclient/demo.cpp	2006-06-21 20:57:41 UTC (rev 1362)
+++ trunk/yake/src/yake/samples/net/roclient/demo.cpp	2006-06-21 22:06:02 UTC (rev 1363)
@@ -19,6 +19,7 @@
 		while (!_kbhit())
 		{
 			net::native::sleep(10);
+			net::update();
 			clientApp.step();
 		}
 		if (_kbhit())

Added: trunk/yake/src/yake/samples/net/roserver/ROServer.cpp
===================================================================
--- trunk/yake/src/yake/samples/net/roserver/ROServer.cpp	2006-06-21 20:57:41 UTC (rev 1362)
+++ trunk/yake/src/yake/samples/net/roserver/ROServer.cpp	2006-06-21 22:06:02 UTC (rev 1363)
@@ -0,0 +1,212 @@
+#include <yake/samples/net/roserver/pch.h>
+#include <yake/net/net.h>
+#include <yake/samples/net/common/common.h>
+#include <yake/samples/net/common/commonEvents.h>
+#include <yake/samples/net/roserver/ROServer.h>
+
+namespace ro {
+	//-----------------------------------------------------------------------------
+	namespace server_impl {
+		class client
+		{
+		public:
+			enum stage_t
+			{
+				CS_WAIT_FOR_REQ = 1, // waiting for "req join"
+				CS_JOINED, // server acknowledged "join" request & sent ...
+				CS_RUNNING,
+				CS_DEAD
+			};
+			enum access_mode_t {
+				AM_ADMIN = 0,
+				AM_MODERATOR,
+				AM_REGULAR,
+				AM_SPECTATOR
+			};
+			net::PeerId						id;
+			stage_t							stage;
+			access_mode_t					accessMode;
+			net::INetEventConnection*	evtConn;
+
+			client() : id(net::NetEvent::EVTID_NONE), stage(CS_DEAD), accessMode(AM_REGULAR), evtConn(0)
+			{
+				processEventFn_ = boost::bind(&client::init_onProcessEvent,this,_1,_2);
+			}
+			void onProcessEvent(const net::NetEvent& evt, const net::ChannelId channel)
+			{
+				YAKE_ASSERT( !processEventFn_.empty() );
+				if (!processEventFn_.empty())
+					processEventFn_(evt,channel);
+			}
+		private:
+			void init_onProcessEvent(const net::NetEvent& evt, const net::ChannelId);
+			void running_onProcessEvent(const net::NetEvent& evt, const net::ChannelId);
+		private:
+			typedef boost::function<void(const net::NetEvent&,const net::ChannelId)> ProcessNetEventFn;
+			ProcessNetEventFn	processEventFn_;
+		};
+	} // namespace server_impl
+
+	//-----------------------------------------------------------------------------
+
+	server::server() : conn_(0), running_(false), evtConn_(0)
+	{
+	}
+	server::~server()
+	{
+		stop();
+	}
+	bool server::start()
+	{
+		if (conn_)
+			return true;
+
+		const net::uint16 port = 40000;
+		const size_t maxClients = 32;
+
+		conn_ = net::createServerPacketConnection();
+		YAKE_ASSERT( conn_ );
+
+		conn_->addStartedCallback( boost::bind(&server::onServerStarted,this) );
+		conn_->addPacketReceivedCallback( boost::bind(&server::onReceivePacket,this,_1,_2,_3,_4) );
+
+		COUTLN("starting server at port " << port << " with max. " << maxClients << " clients...");
+		conn_->start( net::Address(port), maxClients );
+
+		while (!running())
+		{
+			net::update();
+			net::native::sleep(10);
+		}
+
+		return true;
+	}
+	void server::stop()
+	{
+		{
+			boost::mutex::scoped_lock lck(runningMtx_);
+			running_ = false;
+		}
+		if (conn_)
+		{
+			conn_->stop();
+			delete conn_;
+			conn_ = 0;
+		}
+		if (evtConn_)
+		{
+			evtConn_->stop();
+			delete evtConn_;
+			evtConn_ = 0;
+		}
+	}
+	void server::step()
+	{
+		if (!running())
+			return;
+		if (evtConn_)
+			evtConn_->poll();
+	}
+	bool server::running() const
+	{
+		boost::mutex::scoped_lock lck(runningMtx_);
+		return running_;
+	}
+	void server::onServerStarted()
+	{
+		COUTLN("server started.");
+		{
+			boost::mutex::scoped_lock lck(runningMtx_);
+			running_ = true;
+		}
+		YAKE_ASSERT( !evtConn_ );
+		evtConn_ = net::createEventConnection();
+		YAKE_ASSERT( evtConn_ );
+
+		evtConn_->setPolling(true);
+
+		evtConn_->registerEvent( c2sEvtJoinReq::ID, net::NetEvent::DIR_ANY, c2sEvtJoinReq::create, c2sEvtJoinReq::destroy );
+		evtConn_->registerEvent( s2cEvtJoinReqReply::ID, net::NetEvent::DIR_ANY, s2cEvtJoinReqReply::create, s2cEvtJoinReqReply::destroy );
+		evtConn_->registerEvent( s2cEvtClassTable::ID, net::NetEvent::DIR_ANY, s2cEvtClassTable::create, s2cEvtClassTable::destroy );
+		evtConn_->registerEvent( c2sEvtSimOk::ID, net::NetEvent::DIR_ANY, c2sEvtSimOk::create, c2sEvtSimOk::destroy );
+
+		evtConn_->setProcessEventCallback( boost::bind(&server::onProcessEvent,this,_1,_2,_3) );
+		evtConn_->setPacketConnection( conn_, net::NetEvent::DIR_ANY );
+
+		evtConn_->start();
+	}
+	void server::onReceivePacket(const net::PeerId peerId, const void* data, const size_t len, const net::ChannelId channel)
+	{
+		COUTLN("server received packet.");
+		//echoing...
+		//conn_->send( peerId, data, len, net::SendOptions().channel(channel) );
+	}
+	void server::onProcessEvent(const net::PeerId peerId, const net::NetEvent& evt, const net::ChannelId channel)
+	{
+		try {
+			COUTLN("server received event (" << (int)evt.id() << ").");
+
+			// get client object
+			client* c = 0;
+			ClientPtrMap::iterator it = clients_.find( peerId );
+			if (it == clients_.end())
+			{
+				c = new client();
+				c->id = peerId;
+				c->stage = client::CS_WAIT_FOR_REQ;
+				c->evtConn = evtConn_;
+				clients_.insert(std::make_pair(peerId,c));
+			}
+			else
+				c = it->second;
+
+			// handle event
+			c->onProcessEvent( evt, channel );
+		}
+		catch (...)
+		{
+		}
+	}
+	//-----------------------------------------------------------------------------
+	namespace server_impl {
+
+		void client::init_onProcessEvent(const net::NetEvent& evt, const net::ChannelId channel)
+		{
+			YAKE_ASSERT( stage == CS_WAIT_FOR_REQ );
+			if (stage != CS_WAIT_FOR_REQ)
+				return;
+			if (evt.id() == c2sEvtJoinReq::ID)
+			{
+				const c2sEvtJoinReq& evtJoinReq = static_cast<const c2sEvtJoinReq&>(evt);
+				COUTLN("   evt: Join Request");
+
+				// send reply: OK
+				COUTLN("   => accepted");
+				s2cEvtJoinReqReply joinReply;
+				joinReply.accepted = true;
+				evtConn->sendEvent( this->id, joinReply, net::SendOptions().channel(CHANNELID_CONTROL) );
+#if NET_STRESS_TEST_LEVEL >= 1
+				for (size_t i=0; i<3; ++i)
+					evtConn->sendEvent( this->id, joinReply, net::SendOptions().channel(CHANNELID_CONTROL) );
+#endif
+				this->stage = CS_JOINED;
+
+				// use different event callback for the CS_RUNNING stage:
+				COUTLN("   => RUNNING");
+				processEventFn_ = boost::bind(&client::running_onProcessEvent,this,_1,_2);
+				this->stage = CS_RUNNING;
+			}
+		}
+		void client::running_onProcessEvent(const net::NetEvent& evt, const net::ChannelId channel)
+		{
+			COUTLN("server::client::running_onProcessEvent()");
+			YAKE_ASSERT( stage == CS_RUNNING );
+			if (stage != CS_RUNNING)
+				return;
+			//@todo put events in a queue - it is then processed in the main simulation thread!
+			//// send class table & start sim
+			//s2cEvtClassTable evtClassTbl;
+			//evtConn->sendEvent( this->id, evtClassTbl, net::SendOptions().channel(CHANNELID_SIMCTRL) );
+		}
+	} // namespace server_impl
+} // namespace ro

Modified: trunk/yake/src/yake/samples/net/roserver/demo.cpp
===================================================================
--- trunk/yake/src/yake/samples/net/roserver/demo.cpp	2006-06-21 20:57:41 UTC (rev 1362)
+++ trunk/yake/src/yake/samples/net/roserver/demo.cpp	2006-06-21 22:06:02 UTC (rev 1363)
@@ -20,6 +20,7 @@
 		COUTLN("waiting for key press...");
 		while (!_kbhit())
 		{
+			net::update();
 			serverApp.step();
 			net::native::sleep(10);
 		}

Modified: trunk/yake/yake/net/detail/netEnetClientPacketConnection.h
===================================================================
--- trunk/yake/yake/net/detail/netEnetClientPacketConnection.h	2006-06-21 20:57:41 UTC (rev 1362)
+++ trunk/yake/yake/net/detail/netEnetClientPacketConnection.h	2006-06-21 22:06:02 UTC (rev 1363)
@@ -23,7 +23,7 @@
 
 		void disconnectPacketReceivedCallback(const CallbackHandle h)
 		{
-			boost::mutex::scoped_lock lck(packetReceivedFnListMtx_);
+			//boost::mutex::scoped_lock lck(packetReceivedFnListMtx_);
 			OnPacketReceivedFnList::iterator it = packetReceivedFnList_.find(h);
 			if (it == packetReceivedFnList_.end())
 				return;
@@ -42,7 +42,7 @@
 		}
 		void fireCallback_PacketReceived(const PeerId peerId, const void* data, const size_t dataLen, const ChannelId channel)
 		{
-			boost::mutex::scoped_lock lck(packetReceivedFnListMtx_);
+			//boost::mutex::scoped_lock lck(packetReceivedFnListMtx_);
 			for (OnPacketReceivedFnList::const_iterator it = packetReceivedFnList_.begin(); it != packetReceivedFnList_.end(); ++it)
 				(it->second)(peerId,data,dataLen,channel);
 		}
@@ -57,7 +57,7 @@
 		typedef std::deque<OnTimeOutFn> OnTimeOutFnList;
 		OnStartedFnList					startedFnList_;
 		OnPacketReceivedFnList			packetReceivedFnList_;
-		boost::mutex						packetReceivedFnListMtx_;
+		//boost::mutex						packetReceivedFnListMtx_;
 		OnTimeOutFnList					timeOutFnList_;
 		CallbackHandle						lastPacketReceivedCbHandle_;
 

Modified: trunk/yake/yake/net/detail/netEnetServerPacketConnection.h
===================================================================
--- trunk/yake/yake/net/detail/netEnetServerPacketConnection.h	2006-06-21 20:57:41 UTC (rev 1362)
+++ trunk/yake/yake/net/detail/netEnetServerPacketConnection.h	2006-06-21 22:06:02 UTC (rev 1363)
@@ -18,7 +18,6 @@
 
 		virtual size_t getNumConnectedClients() const
 		{
-			boost::mutex::scoped_lock lockClients(m_clientsMtx);
 			PeerToClientMap::const_iterator itEnd = m_clients.end();
 			size_t count = 0;
 			for (PeerToClientMap::const_iterator it = m_clients.begin(); it != itEnd; ++it)
@@ -41,11 +40,20 @@
 
 		void disconnectPacketReceivedCallback(const CallbackHandle h)
 		{
-			boost::mutex::scoped_lock lck(packetReceivedFnListMtx_);
 			OnPacketReceivedFnList::iterator it = packetReceivedFnList_.find( h );
 			if (it != packetReceivedFnList_.end())
 				packetReceivedFnList_.erase( it );
 		}
+
+		struct statistics_t
+		{
+			size_t		numConnectionAttempts_;
+			size_t		numSuccessfulConnectionAttempts_;
+			size_t		numRefusedConnectionAttempts_;
+			size_t		numConnectionAttemptTimeouts_;
+			size_t		numConnectionTimeouts_;
+			size_t		numMaxLiveClients_;
+		};
 	private:
 		void sendTo(const PeerId clientId, const void* dataPtr, const size_t dataSize, const Reliability rel, const Ordering, const ChannelId channel);
 		void sendBroadcast(const void* dataPtr, const size_t dataSize, const Reliability rel, const Ordering, const ChannelId channel);
@@ -71,7 +79,6 @@
 		}
 		void fireCallback_PacketReceived(const PeerId peerId, const void* data, const size_t dataLen, const ChannelId channel)
 		{
-			boost::mutex::scoped_lock lck(packetReceivedFnListMtx_);
 			for (OnPacketReceivedFnList::const_iterator it = packetReceivedFnList_.begin(); it != packetReceivedFnList_.end(); ++it)
 				(it->second)(peerId,data,dataLen,channel);
 		}
@@ -84,8 +91,7 @@
 		OnClientConnectedFnList			clientConnectedFnList_;
 		OnClientDisconnectedFnList		clientDisconnectedFnList_;
 		OnPacketReceivedFnList			packetReceivedFnList_;
-		CallbackHandle						lastPacketReceivedCbHandle_;
-		boost::mutex						packetReceivedFnListMtx_;
+		CallbackHandle					lastPacketReceivedCbHandle_;
 
 	private:
 		enum State {
@@ -97,17 +103,14 @@
 		struct state_t {
 			State get() const
 			{
-				boost::mutex::scoped_lock lock(mtx_);
 				return state_;
 			}
 			void set(const State state)
 			{
-				boost::mutex::scoped_lock lock(mtx_);
 				state_ = state;
 			}
 		private:
 			State					state_;
-			mutable boost::mutex mtx_;
 		} m_state;
 
 		ENetAddress				m_address;
@@ -118,7 +121,6 @@
 		typedef std::vector<std::string> HostList;
 		HostList				m_ipWhiteList;
 		HostList				m_ipBlackList;
-		mutable boost::mutex	m_ipListMtx;
 
 		typedef std::map<uint32,std::string> IpToString;
 		IpToString				m_ip2string;
@@ -132,6 +134,7 @@
 		};
 		struct Client
 		{
+			double		timeLeft_;
 			ENetPeer*	peer;
 			ClientState	state;
 			PeerId		id;
@@ -150,7 +153,8 @@
 		typedef std::map<PeerId,Client*> IdToClientMap;
 		IdToClientMap			m_id2client;
 		PeerId					m_nextPeerId;
-		mutable boost::mutex m_clientsMtx;
+		net::Timer				m_timer;
+		double					m_timeOfLastUpdate;
 	private:
 		ClientState getClientState(ENetPeer* peer) const; // access only via update()
 	};

Modified: trunk/yake/yake/net/detail/netInternal.h
===================================================================
--- trunk/yake/yake/net/detail/netInternal.h	2006-06-21 20:57:41 UTC (rev 1362)
+++ trunk/yake/yake/net/detail/netInternal.h	2006-06-21 22:06:02 UTC (rev 1363)
@@ -35,8 +35,6 @@
 namespace net {
 namespace impl {
 
-	boost::mutex& getEnetMtx();
-
 	typedef boost::function<void(void)> UpdateFn;
 	class UpdateThread
 	{
@@ -64,11 +62,8 @@
 		UpdateFnMap		fns_;
 		uint32			nextId_;
 		boost::thread*	thread_;
-		mutable boost::mutex	mtx_;
 		bool			quitRequested_;
-
 		bool			dead_;
-		mutable boost::mutex	deadMtx_;
 
 		static UpdateThread* instance_;
 	};

Modified: trunk/yake/yake/net/net.h
===================================================================
--- trunk/yake/yake/net/net.h	2006-06-21 20:57:41 UTC (rev 1362)
+++ trunk/yake/yake/net/net.h	2006-06-21 22:06:02 UTC (rev 1363)
@@ -9,6 +9,7 @@
 namespace net {
 
 	NET_API bool initialize();
+	NET_API void update();
 	NET_API void shutdown();
 
 } // namespace net

Added: trunk/yake/yake/samples/net/packet/pch.h
===================================================================
--- trunk/yake/yake/samples/net/packet/pch.h	2006-06-21 20:57:41 UTC (rev 1362)
+++ trunk/yake/yake/samples/net/packet/pch.h	2006-06-21 22:06:02 UTC (rev 1363)
@@ -0,0 +1,7 @@
+#ifndef PCH_H
+#define PCH_H
+
+#include <boost/function.hpp>
+#include <boost/bind.hpp>
+
+#endif

Added: trunk/yake/yake/samples/net/roclient/ROClient.h
===================================================================
--- trunk/yake/yake/samples/net/roclient/ROClient.h	2006-06-21 20:57:41 UTC (rev 1362)
+++ trunk/yake/yake/samples/net/roclient/ROClient.h	2006-06-21 22:06:02 UTC (rev 1363)
@@ -0,0 +1,78 @@
+#ifndef RO_CLIENT_H
+#define RO_CLIENT_H
+
+namespace ro {
+
+	struct client
+	{
+	public:
+		client();
+		~client();
+		bool start( const net::Address& );
+		void waitForStart();
+		void stop();
+		bool running() const;
+		void step();
+	private:
+		net::IClientPacketConnection*	conn_;
+		safe_var<bool>					timedOut_;
+		net::INetEventConnection*	evtConn_;
+
+		bool								running_;
+		mutable boost::mutex			runningMtx_;
+
+		enum stage_t {
+			CS_DEAD = 1,
+			CS_JOINING,
+			CS_RUNNING
+		};
+		stage_t							stage_;
+	private:
+		void onClientStarted();
+		void onTimeOut();
+		void running_onProcessEvent(const net::PeerId, const net::NetEvent& , const net::ChannelId);
+		void init_onProcessEvent(const net::PeerId, const net::NetEvent& , const net::ChannelId);
+	};
+
+} // namespace ro
+
+#endif
+#ifndef RO_CLIENT_H
+#define RO_CLIENT_H
+
+namespace ro {
+
+	struct client
+	{
+	public:
+		client();
+		~client();
+		bool start( const net::Address& );
+		void waitForStart();
+		void stop();
+		bool running() const;
+		void step();
+	private:
+		net::IClientPacketConnection*	conn_;
+		safe_var<bool>					timedOut_;
+		net::INetEventConnection*	evtConn_;
+
+		bool								running_;
+		mutable boost::mutex			runningMtx_;
+
+		enum stage_t {
+			CS_DEAD = 1,
+			CS_JOINING,
+			CS_RUNNING
+		};
+		stage_t							stage_;
+	private:
+		void onClientStarted();
+		void onTimeOut();
+		void running_onProcessEvent(const net::PeerId, const net::NetEvent& , const net::ChannelId);
+		void init_onProcessEvent(const net::PeerId, const net::NetEvent& , const net::ChannelId);
+	};
+
+} // namespace ro
+
+#endif

Added: trunk/yake/yake/samples/net/roserver/ROServer.h
===================================================================
--- trunk/yake/yake/samples/net/roserver/ROServer.h	2006-06-21 20:57:41 UTC (rev 1362)
+++ trunk/yake/yake/samples/net/roserver/ROServer.h	2006-06-21 22:06:02 UTC (rev 1363)
@@ -0,0 +1,106 @@
+#ifndef RO_SERVER_H
+#define RO_SERVER_H
+
+namespace ro {
+	namespace server_impl {
+		class client;
+	}
+	struct server
+	{
+	public:
+		server();
+		~server();
+		bool start();
+		void stop();
+		void step();
+
+		void queueEvent(const net::PeerId, net::NetEvent*, const net::ChannelId);
+		void queueEventBroadcast(net::NetEvent*, const net::ChannelId);
+	private:
+		void onServerStarted();
+		void onReceivePacket(const net::PeerId, const void*, const size_t, const net::ChannelId);
+		void onProcessEvent(const net::PeerId, const net::NetEvent&, const net::ChannelId);
+	private:
+		bool									running_;
+		mutable boost::mutex				runningMtx_;
+
+		bool running() const;
+
+		//
+		net::IServerPacketConnection*	conn_;
+		net::INetEventConnection*		evtConn_;
+
+		typedef server_impl::client client;
+
+		typedef std::map<net::PeerId,client*> ClientPtrMap;
+		ClientPtrMap	clients_;
+
+		//@todo put into specialized object "NetEventQueue"
+		struct EventQEntry
+		{
+			net::NetEvent*	evt_;
+			net::PeerId		peerId_;
+			net::ChannelId	channelId_;
+			EventQEntry(const net::PeerId, const net::NetEvent*, const net::ChannelId);
+		};
+		typedef std::deque<EventQEntry> EventQ;
+		EventQ								outEvtQ_;
+		mutable boost::mutex				outEvtQMtx_;
+	};
+
+} // namespace ro
+
+#endif
+#ifndef RO_SERVER_H
+#define RO_SERVER_H
+
+namespace ro {
+	namespace server_impl {
+		class client;
+	}
+	struct server
+	{
+	public:
+		server();
+		~server();
+		bool start();
+		void stop();
+		void step();
+
+		void queueEvent(const net::PeerId, net::NetEvent*, const net::ChannelId);
+		void queueEventBroadcast(net::NetEvent*, const net::ChannelId);
+	private:
+		void onServerStarted();
+		void onReceivePacket(const net::PeerId, const void*, const size_t, const net::ChannelId);
+		void onProcessEvent(const net::PeerId, const net::NetEvent&, const net::ChannelId);
+	private:
+		bool									running_;
+		mutable boost::mutex				runningMtx_;
+
+		bool running() const;
+
+		//
+		net::IServerPacketConnection*	conn_;
+		net::INetEventConnection*		evtConn_;
+
+		typedef server_impl::client client;
+
+		typedef std::map<net::PeerId,client*> ClientPtrMap;
+		ClientPtrMap	clients_;
+
+		//@todo put into specialized object "NetEventQueue"
+		struct EventQEntry
+		{
+			net::NetEvent*	evt_;
+			net::PeerId		peerId_;
+			net::ChannelId	channelId_;
+			EventQEntry(const net::PeerId, const net::NetEvent*, const net::ChannelId);
+		};
+		typedef std::deque<EventQEntry> EventQ;
+		EventQ								outEvtQ_;
+		mutable boost::mutex				outEvtQMtx_;
+	};
+
+} // namespace ro
+
+#endif



From codeandroid at berlios.de  Thu Jun 22 00:06:25 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Thu, 22 Jun 2006 00:06:25 +0200
Subject: [Yake-svn] r1364 - trunk/yake/scripts/msvc8/samples/net
Message-ID: <200606212206.k5LM6PgJ014427@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-22 00:06:24 +0200 (Thu, 22 Jun 2006)
New Revision: 1364

Added:
   trunk/yake/scripts/msvc8/samples/net/sampleNetPacket.vcproj
Log:
added sampleNetPacket

Added: trunk/yake/scripts/msvc8/samples/net/sampleNetPacket.vcproj
===================================================================
--- trunk/yake/scripts/msvc8/samples/net/sampleNetPacket.vcproj	2006-06-21 22:06:02 UTC (rev 1363)
+++ trunk/yake/scripts/msvc8/samples/net/sampleNetPacket.vcproj	2006-06-21 22:06:24 UTC (rev 1364)
@@ -0,0 +1,225 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="sampleNetPacket"
+	ProjectGUID="{5473599B-AB7B-4259-B052-4DDC68CBEA54}"
+	RootNamespace="sampleDotScene"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../../../common/bin/debug"
+			IntermediateDirectory="../../../../common/obj/debug/$(ProjectName)"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../../;../../../../dependencies/boost/;../../../../dependencies/ttl/"
+				PreprocessorDefinitions="_STLP_DEBUG;WIN32;_DEBUG;_CONSOLE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="yake/samples/net/packet/pch.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="base.lib graphics.lib physics.lib audio.lib data.lib input.lib yapp.lib scripting.lib"
+				OutputFile="$(OutDir)/$(ProjectName).exe"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../../common/lib;../../../../common/lib/debug;../../../../dependencies/lib"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../../../common/bin/release"
+			IntermediateDirectory="../../../../common/obj/release/$(ProjectName)"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../../;../../../../dependencies/boost/;../../../../dependencies/ttl/"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				RuntimeLibrary="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="yake/samples/net/packet/pch.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="base.lib graphics.lib physics.lib audio.lib data.lib input.lib yapp.lib scripting.lib"
+				OutputFile="$(OutDir)/$(ProjectName).exe"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../../common/lib;../../../../common/lib/release;../../../../dependencies/lib"
+				GenerateDebugInformation="false"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="inc"
+			>
+			<File
+				RelativePath="..\..\..\..\yake\samples\net\packet\pch.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="src"
+			>
+			<File
+				RelativePath="..\..\..\..\src\yake\samples\net\packet\demo.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\..\..\src\yake\samples\net\packet\pch.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>



From codeandroid at berlios.de  Sun Jun 25 20:15:09 2006
From: codeandroid at berlios.de (codeandroid at BerliOS)
Date: Sun, 25 Jun 2006 20:15:09 +0200
Subject: [Yake-svn] r1365 - trunk/yake/yake/base/templates
Message-ID: <200606251815.k5PIF94M011504@sheep.berlios.de>

Author: codeandroid
Date: 2006-06-25 20:15:03 +0200 (Sun, 25 Jun 2006)
New Revision: 1365

Modified:
   trunk/yake/yake/base/templates/yakeSignals.h
Log:
fixed macro (thanks, brainless)

Modified: trunk/yake/yake/base/templates/yakeSignals.h
===================================================================
--- trunk/yake/yake/base/templates/yakeSignals.h	2006-06-21 22:06:24 UTC (rev 1364)
+++ trunk/yake/yake/base/templates/yakeSignals.h	2006-06-25 18:15:03 UTC (rev 1365)
@@ -151,7 +151,7 @@
 #define YAKE_MEMBERSIGNAL_FIRE_FN2(ACCESS, NAME, PARAM0, PARAM0TYPE, PARAM1, PARAM1TYPE) \
 ACCESS: \
 	void fire ## NAME(PARAM0TYPE PARAM0,PARAM1TYPE PARAM1) \
-	{ mSig ## NAME(PARAM0CALL,PARAM1CALL); }
+	{ mSig ## NAME(PARAM0,PARAM1); }
 
 #define YAKE_MEMBERSIGNAL( ACCESS, SIGNATURE, NAME ) \
 ACCESS: \



